--------------------------------------------------------------------------------
-- This file provides the data structures and functions for the theory of
-- cedille core extended with the constructs for metaprogramming.
--------------------------------------------------------------------------------

{-# OPTIONS --type-in-type #-}

module CoreTheory where

import Data.Product

open import Class.Map
open import Class.Monad.Except
open import Data.HSTrie
open import Data.Word using (to‚Ñï; from‚Ñï)
open import Monads.Except

open import Prelude
open import Prelude.Nat

open import Theory.Names public
open import Theory.TermLike public
open import Theory.PrimMeta public
open import Theory.Terms public

private
  variable
    A B C : Set
    M : Set ‚Üí Set

data Def : Set where
  Let : AnnTerm ‚Üí AnnTerm ‚Üí Def
  Axiom : AnnTerm ‚Üí Def

instance
  Def-Show : Show Def
  Def-Show .show (Let x x‚ÇÅ) = " :=" <+> show x <+> ":" <+> show x‚ÇÅ
  Def-Show .show (Axiom x) = " :" <+> show x

private
  data EfficientDef : Set where
    EfficientLet : AnnTerm ‚Üí PureTerm ‚Üí AnnTerm ‚Üí EfficientDef
    EfficientAxiom : AnnTerm ‚Üí EfficientDef

  toDef : EfficientDef ‚Üí Def
  toDef (EfficientLet x x‚ÇÅ x‚ÇÇ)   = Let x x‚ÇÇ
  toDef (EfficientAxiom x)       = Axiom x

  getNorm : EfficientDef ‚Üí Maybe PureTerm
  getNorm (EfficientLet x x‚ÇÅ x‚ÇÇ) = return x‚ÇÅ
  getNorm (EfficientAxiom x)     = nothing

  typeOfDef : Def ‚Üí AnnTerm
  typeOfDef (Let _ x) = x
  typeOfDef (Axiom x) = x

GlobalContext : Set
GlobalContext = HSTrie EfficientDef

emptyGlobalContext : GlobalContext
emptyGlobalContext = emptyMap

Context : Set
Context = GlobalContext √ó List AnnTerm

private
  instance
    Context-Show : Show Context
    Context-Show .show (fst , snd) = (show $ length snd) <+> "local variables:" + show snd

globalToContext : GlobalContext ‚Üí Context
globalToContext Œì = Œì , []

contextToGlobal : Context ‚Üí GlobalContext
contextToGlobal (fst , snd) = fst

private
  -- add variable to context, so that index 0 points to that variable
  pushVar : AnnTerm ‚Üí Context ‚Üí Context
  pushVar v (fst , snd) = fst , v ‚à∑ snd

  localContextLength : Context ‚Üí ‚Ñï
  localContextLength (fst , snd) = length snd

  efficientLookupInContext : Name ‚Üí Context ‚Üí Maybe EfficientDef
  efficientLookupInContext (Bound x) (fst , snd) =
    EfficientAxiom ‚àò weakenBy (sucùïÄ x) <$> lookupMaybe (to‚Ñï x) snd
  efficientLookupInContext (Free x) (fst , snd) = lookup x fst

  lookupInContext : Name ‚Üí Context ‚Üí Maybe Def
  lookupInContext n Œì = toDef <$> efficientLookupInContext n Œì

  {-# TERMINATING #-}
  validInContext : PureTerm ‚Üí Context ‚Üí Bool
  validInContext = helper 0
    where
      -- instead of modifying the context here, we just count how many variables we would have added if we did
      helper : ùïÄ ‚Üí PureTerm ‚Üí Context ‚Üí Bool
      helper k (Var-P (Bound x)) Œì = x <ùïÄ (from‚Ñï (localContextLength Œì) +ùïÄ k)
      helper k (Var-P n@(Free x)) Œì = maybe (Œª _ ‚Üí true) false $ lookupInContext n Œì
      helper k (Sort-P x) Œì = true
      helper k (Const-P x) Œì = true
      helper k (App-P t t‚ÇÅ) Œì = helper k t Œì ‚àß helper k t‚ÇÅ Œì
      helper k (Lam-P _ t) Œì = helper (sucùïÄ k) t Œì
      helper k (Pi-P _ t t‚ÇÅ) Œì = helper k t Œì ‚àß helper (sucùïÄ k) t‚ÇÅ Œì
      helper k (All-P _ t t‚ÇÅ) Œì = helper k t Œì ‚àß helper (sucùïÄ k) t‚ÇÅ Œì
      helper k (Iota-P _ t t‚ÇÅ) Œì = helper k t Œì ‚àß helper (sucùïÄ k) t‚ÇÅ Œì
      helper k (Eq-P t t‚ÇÅ) Œì = helper k t Œì ‚àß helper k t‚ÇÅ Œì
      helper k (M-P t) Œì = helper k t Œì
      helper k (Mu-P t t‚ÇÅ) Œì = helper k t Œì ‚àß helper k t‚ÇÅ Œì
      helper k (Epsilon-P t) Œì = helper k t Œì
      helper k (Gamma-P t t‚ÇÅ) Œì = helper k t Œì ‚àß helper k t‚ÇÅ Œì
      helper k (Ev-P m t) Œì = primMetaArgsAnd $ mapPrimMetaArgs (Œª x ‚Üí helper k x Œì) t
      helper k (Char-P c) Œì = true
      helper k (CharEq-P t t‚ÇÅ) Œì = helper k t Œì ‚àß helper k t‚ÇÅ Œì

  {-# TERMINATING #-}
  checkFree : Name ‚Üí PureTerm ‚Üí Bool
  checkFree = helper 0
    where
      helper : ùïÄ ‚Üí Name ‚Üí PureTerm ‚Üí Bool
      helper k n (Var-P (Bound x)) = case n of Œª where
        (Bound x‚ÇÅ) ‚Üí x ‚â£ (k +ùïÄ x‚ÇÅ)
        (Free x‚ÇÅ) ‚Üí false
      helper k n (Var-P (Free x)) = case n of Œª where
        (Bound x‚ÇÅ) ‚Üí false
        (Free x‚ÇÅ) ‚Üí x ‚â£ x‚ÇÅ
      helper k n (Sort-P x) = false
      helper k n (Const-P x) = false
      helper k n (App-P t t‚ÇÅ) = helper k n t ‚àß helper k n t‚ÇÅ
      helper k n (Lam-P _ t) = helper (sucùïÄ k) n t
      helper k n (Pi-P _ t t‚ÇÅ) = helper k n t ‚àß helper (sucùïÄ k) n t‚ÇÅ
      helper k n (All-P _ t t‚ÇÅ) = helper k n t ‚àß helper (sucùïÄ k) n t‚ÇÅ
      helper k n (Iota-P _ t t‚ÇÅ) = helper k n t ‚àß helper (sucùïÄ k) n t‚ÇÅ
      helper k n (Eq-P t t‚ÇÅ) = helper k n t ‚àß helper k n t‚ÇÅ
      helper k n (M-P t) = helper k n t
      helper k n (Mu-P t t‚ÇÅ) = helper k n t ‚àß helper k n t‚ÇÅ
      helper k n (Epsilon-P t) = helper k n t
      helper k n (Gamma-P t t‚ÇÅ) = helper k n t ‚àß helper k n t‚ÇÅ
      helper k n (Ev-P m t) = primMetaArgsAnd $ mapPrimMetaArgs (helper k n) t
      helper k n (Char-P c) = false
      helper k n (CharEq-P t t‚ÇÅ) = helper k n t ‚àß helper k n t‚ÇÅ

-- something in is head normal form, if its outermost constructor is not one of the following: Var-A (if the lookup fails), App-A, AppE-A
{-# TERMINATING #-}
hnfNorm : Context ‚Üí AnnTerm ‚Üí AnnTerm
hnfNorm Œì v@(Var-A x) with lookupInContext x Œì
... | just (Let x‚ÇÅ x‚ÇÇ)  = hnfNorm Œì x‚ÇÅ
... | just (Axiom x‚ÇÅ)   = v -- we cannot reduce axioms
... | nothing           = v -- in case the lookup fails, we cannot reduce
hnfNorm Œì (App-A t t‚ÇÅ)  = maybe (Œª t' ‚Üí hnfNorm Œì $ subst t' t‚ÇÅ) (t ‚ü™$‚ü´ t‚ÇÅ) $ stripBinder (hnfNorm Œì t)
hnfNorm Œì (AppE-A t t‚ÇÅ) = maybe (Œª t' ‚Üí hnfNorm Œì $ subst t' t‚ÇÅ) (t ‚ü™$‚ü´ t‚ÇÅ) $ stripBinder (hnfNorm Œì t)
{-# CATCHALL #-}
hnfNorm Œì v             = v

hnfNormPure normalizePure : Context ‚Üí PureTerm ‚Üí PureTerm

{-# NON_TERMINATING #-}
hnfNormPure Œì v@(Var-P x) with lookupInContext x Œì
... | just (Let x‚ÇÅ x‚ÇÇ)         = hnfNormPure Œì $ Erase x‚ÇÅ
... | just (Axiom x‚ÇÅ)          = v -- we cannot reduce axioms
... | nothing                  = v -- in case the lookup fails, we cannot reduce
hnfNormPure Œì v@(App-P t t‚ÇÅ) with stripBinder (hnfNormPure Œì t)
... | (just t')                = hnfNormPure Œì $ subst t' t‚ÇÅ
... | nothing                  = v
hnfNormPure Œì v@(CharEq-P _ _) = normalizePure Œì v -- reduce to a bool, if possible
{-# CATCHALL #-}
hnfNormPure Œì v                = v

{-# NON_TERMINATING #-}
normalizePure Œì v@(Var-P x) with efficientLookupInContext x Œì
... | just (EfficientLet x‚ÇÅ x‚ÇÇ x‚ÇÉ) = x‚ÇÇ
... | just (EfficientAxiom x‚ÇÅ)     = v -- we cannot reduce axioms
... | nothing                      = v -- in case the lookup fails, we cannot reduce
normalizePure Œì v@(Sort-P x)       = v
normalizePure Œì v@(Const-P x)      = v
normalizePure Œì (App-P t t‚ÇÅ) with hnfNormPure Œì t
...| t' = case stripBinder t' of Œª where
    (just t'') ‚Üí normalizePure Œì (subst t'' t‚ÇÅ)
    nothing    ‚Üí normalizePure Œì t' ‚ü™$‚ü´ normalizePure Œì t‚ÇÅ
normalizePure Œì (Lam-P n t) with normalizePure Œì t
... | t''@(App-P t' (Var-P (Bound i))) = if i ‚â£ 0 ‚àß validInContext t' Œì
  then normalizePure Œì (strengthen t') else Lam-P n t'' -- eta reduce here
... | t'' = Lam-P n t''
normalizePure Œì (Pi-P n t t‚ÇÅ)      = Pi-P n (normalizePure Œì t) (normalizePure Œì t‚ÇÅ)
normalizePure Œì (All-P n t t‚ÇÅ)     = All-P n (normalizePure Œì t) (normalizePure Œì t‚ÇÅ)
normalizePure Œì (Iota-P n t t‚ÇÅ)    = Iota-P n (normalizePure Œì t) (normalizePure Œì t‚ÇÅ)
normalizePure Œì (Eq-P t t‚ÇÅ)        = Eq-P (normalizePure Œì t) (normalizePure Œì t‚ÇÅ)
normalizePure Œì (M-P t)            = M-P (normalizePure Œì t)
normalizePure Œì (Mu-P t t‚ÇÅ)        = Mu-P (normalizePure Œì t) (normalizePure Œì t‚ÇÅ)
normalizePure Œì (Epsilon-P t)      = Epsilon-P (normalizePure Œì t)
normalizePure Œì (Gamma-P t t‚ÇÅ)     = Gamma-P (normalizePure Œì t) (normalizePure Œì t‚ÇÅ)
normalizePure Œì (Ev-P m args)      = Ev-P m (mapPrimMetaArgs (normalizePure Œì) args)
normalizePure Œì (Char-P c)         = (Char-P c)
normalizePure Œì (CharEq-P t t‚ÇÅ) with normalizePure Œì t | normalizePure Œì t‚ÇÅ
... | (Char-P c) | (Char-P c')     = normalizePure Œì $ FreeVar $ show (c ‚â£ c')
{-# CATCHALL #-}
... | x | x‚ÇÅ                       = CharEq-P x x‚ÇÅ

insertInGlobalContext : GlobalName ‚Üí Def ‚Üí GlobalContext ‚Üí String ‚äé GlobalContext
insertInGlobalContext n d Œì =
  if is-just $ lookup n Œì
    then inj‚ÇÅ ("The name" <+> n <+> "is already defined!")
    else (inj‚ÇÇ $ insert n (toEfficientDef d Œì) Œì)
  where
    toEfficientDef : Def ‚Üí GlobalContext ‚Üí EfficientDef
    toEfficientDef (Let x x‚ÇÅ) Œì = EfficientLet x (normalizePure (globalToContext Œì) $ Erase x) x‚ÇÅ
    toEfficientDef (Axiom x) Œì = EfficientAxiom x

private
  beqMonadHelper : {{_ : EqB A}} {{_ : Show A}} {{_ : Monad M}} {{_ : MonadExcept M String}}
                ‚Üí A ‚Üí A ‚Üí String ‚Üí M ‚ä§
  beqMonadHelper a a' s =
    if a ‚â£ a'
      then return tt
      else throwError (s <+> show a <+> "isn't equal to" <+> s <+> show a')

  {-# TERMINATING #-}
  pureTermBeq : {{_ : Monad M}} {{_ : MonadExcept M String}}
    ‚Üí PureTerm ‚Üí PureTerm ‚Üí M ‚ä§
  pureTermBeq (Var-P x) (Var-P x‚ÇÅ) = beqMonadHelper x x‚ÇÅ "Name"
  pureTermBeq (Sort-P x) (Sort-P x‚ÇÅ) = beqMonadHelper x x‚ÇÅ "Sort"
  pureTermBeq (Const-P x) (Const-P x‚ÇÅ) = beqMonadHelper x x‚ÇÅ "Const"
  pureTermBeq (App-P t t‚ÇÅ) (App-P x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  pureTermBeq (Lam-P _ t) (Lam-P _ t‚ÇÅ) = pureTermBeq t t‚ÇÅ
  pureTermBeq (Pi-P _ t t‚ÇÅ) (Pi-P _ x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  pureTermBeq (All-P _ t t‚ÇÅ) (All-P _ x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  pureTermBeq (Iota-P _ t t‚ÇÅ) (Iota-P _ x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  pureTermBeq (Eq-P t t‚ÇÅ) (Eq-P x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  pureTermBeq (M-P t) (M-P x) = pureTermBeq x t
  pureTermBeq (Mu-P t t‚ÇÅ) (Mu-P x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  pureTermBeq (Epsilon-P t) (Epsilon-P x) = pureTermBeq t x
  pureTermBeq (Gamma-P t t‚ÇÅ) (Gamma-P x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  pureTermBeq (Ev-P m t) (Ev-P m' x) with m ‚âü m'
  ... | yes refl = void $ primMetaArgsSequence $ primMetaArgsZipWith pureTermBeq t x
  ... | no  _    = throwError $ show m <+> "and" <+> show m' <+> "aren't equal!"
  pureTermBeq (Char-P c) (Char-P c') = beqMonadHelper c c' "Char"
  pureTermBeq (CharEq-P t t‚ÇÅ) (CharEq-P x x‚ÇÅ) = pureTermBeq t x >> pureTermBeq t‚ÇÅ x‚ÇÅ
  {-# CATCHALL #-}
  pureTermBeq t t' =
    throwError $ "The terms" <+> show t <+> "and" <+> show t' <+> "aren't equal!"

module _ {{_ : Monad M}} {{_ : MonadExcept M String}} (Œì : Context) where
  compareNames : PureTerm ‚Üí PureTerm ‚Üí M ‚ä§
  compareNames (Var-P x) (Var-P x‚ÇÅ) =
    if x ‚â£ x‚ÇÅ
      then return tt
      else throwError "Names not equal! If you see this message, this is a bug!"
  {-# CATCHALL #-}
  compareNames _ _ = throwError "Terms are not names! If you see this message, this is a bug!"

  {-# NON_TERMINATING #-}
  checkŒ≤Œ∑Pure : PureTerm ‚Üí PureTerm ‚Üí M ‚ä§
  checkŒ≤Œ∑Pure t t' =
    tryElse (compareNames t t') $
    compareHnfs (hnfNormPure Œì t) (hnfNormPure Œì t')
    -- tryElse (compareHnfs (hnfNormPure Œì t) (hnfNormPure Œì t')) $
    -- pureTermBeq t t'
    where
      hnfError : PureTerm ‚Üí PureTerm ‚Üí M ‚ä§
      hnfError t t' =
        throwError $ "The terms" <+> show t <+> "and" <+> show t' <+> "aren't equal!"

      compareHnfs : PureTerm ‚Üí PureTerm ‚Üí M ‚ä§
      compareHnfs (Var-P x) (Var-P x‚ÇÅ) = beqMonadHelper x x‚ÇÅ "Name"
      compareHnfs (Sort-P x) (Sort-P x‚ÇÅ) = beqMonadHelper x x‚ÇÅ "Sort"
      compareHnfs (Const-P x) (Const-P x‚ÇÅ) = beqMonadHelper x x‚ÇÅ "Const"
      compareHnfs (App-P t t‚ÇÅ) (App-P x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs (Lam-P _ t) (Lam-P _ t‚ÇÅ) = checkŒ≤Œ∑Pure t t‚ÇÅ
      compareHnfs (Pi-P _ t t‚ÇÅ) (Pi-P _ x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs (All-P _ t t‚ÇÅ) (All-P _ x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs (Iota-P _ t t‚ÇÅ) (Iota-P _ x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs (Eq-P t t‚ÇÅ) (Eq-P x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs (M-P t) (M-P x) = checkŒ≤Œ∑Pure x t
      compareHnfs (Mu-P t t‚ÇÅ) (Mu-P x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs (Epsilon-P t) (Epsilon-P x) = checkŒ≤Œ∑Pure t x
      compareHnfs (Gamma-P t t‚ÇÅ) (Gamma-P x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs t@(Ev-P m x) t'@(Ev-P m' x') with m ‚âü m'
      ... | yes refl = void $ primMetaArgsSequence $ primMetaArgsZipWith checkŒ≤Œ∑Pure x x'
      ... | no  _    = hnfError t t'
      compareHnfs (Char-P c) (Char-P c') = beqMonadHelper c c' "Char"
      compareHnfs (CharEq-P t t‚ÇÅ) (CharEq-P x x‚ÇÅ) = checkŒ≤Œ∑Pure t x >> checkŒ≤Œ∑Pure t‚ÇÅ x‚ÇÅ
      compareHnfs (Lam-P _ t) t‚ÇÅ = case normalizePure Œì t of Œª where
        t''@(App-P t' (Var-P (Bound i))) ‚Üí if i ‚â£ 0 ‚àß validInContext t' Œì
          then (compareHnfs (strengthen t') t‚ÇÅ) else hnfError t'' t‚ÇÅ
        t'' ‚Üí hnfError t'' t‚ÇÅ
      compareHnfs t (Lam-P _ t‚ÇÅ) = case normalizePure Œì t‚ÇÅ of Œª where
        t''@(App-P t' (Var-P (Bound i))) ‚Üí if i ‚â£ 0 ‚àß validInContext t' Œì
          then (compareHnfs t (strengthen t')) else hnfError t t''
        t'' ‚Üí hnfError t t''
      {-# CATCHALL #-}
      compareHnfs t t' = hnfError t t'

  checkŒ≤Œ∑ : AnnTerm ‚Üí AnnTerm ‚Üí M ‚ä§
  checkŒ≤Œ∑ t t' = checkŒ≤Œ∑Pure (Erase t) (Erase t')

{-# TERMINATING #-}
synthType synthType' :
  {{_ : Monad M}} {{_ : MonadExcept M String}} ‚Üí Context ‚Üí AnnTerm ‚Üí M AnnTerm

synthType Œì t =
  appendIfError (synthType' Œì t) $
    "\n\nWhile synthesizing type for" <+> shortenString 1000 (show t) <+> "in context:\n" + show {{Context-Show}} Œì

synthType' Œì (Var-A x) =
  maybeToError
    (typeOfDef <$> lookupInContext x Œì)
    ("Lookup failed:" <+> show x <+> "in context" <+> show {{Context-Show}} Œì)
synthType' Œì (Sort-A Ast) = return ‚ñ°
synthType' Œì (Sort-A Sq) = throwError "Cannot synthesize type for the superkind"

synthType' Œì (Const-A CharT) = return ‚ãÜ

synthType' Œì (Pr1-A t) = do
  T ‚Üê synthType Œì t
  case (hnfNorm Œì T) of Œª
    { (Iota-A _ u u‚ÇÅ) ‚Üí return u
    ; _ ‚Üí throwError "Term does not normalize to an iota term" }

synthType' Œì (Pr2-A t) = do
  T ‚Üê synthType Œì t
  case (hnfNorm Œì T) of Œª
    { (Iota-A _ u u‚ÇÅ) ‚Üí return $ subst u‚ÇÅ (Pr1-A t)
    ; _ ‚Üí throwError "Term does not normalize to an iota term" }

synthType' Œì (Beta-A t t‚ÇÅ) = do
  T ‚Üê synthType Œì (Eq-A t t)
  case (hnfNorm Œì T) of Œª
    { (Sort-A Ast) ‚Üí return $ Eq-A t t
    ; _ ‚Üí throwError "Equality type does not have the right type. Is this a bug?" }

synthType' Œì (Delta-A t t‚ÇÅ) = do
  T ‚Üê synthType Œì t‚ÇÅ
  case (hnfNorm Œì T) of Œª
    { (Eq-A u u‚ÇÅ) ‚Üí do
      catchError
        (pureTermBeq (normalizePure Œì $ Erase u) (Lam-P "" $ Lam-P "" $ BoundVar 1) >>
         pureTermBeq (normalizePure Œì $ Erase u‚ÇÅ) (Lam-P "" $ Lam-P "" $ BoundVar 0))
        (Œª e ‚Üí throwError $
          "This equality cannot be used for the delta term:" <+> show u
          <+> "=" <+> show u‚ÇÅ + "\nError:" <+> e)
      return t
    ; _ ‚Üí throwError "The second argument of a delta needs to be of an eq type" }

synthType' Œì (Sigma-A t) = do
  T ‚Üê synthType Œì t
  case (hnfNorm Œì T) of Œª
    { (Eq-A u u‚ÇÅ) ‚Üí return $ Eq-A u‚ÇÅ u
    ; _ ‚Üí throwError "Sigma needs an inhabitant of an eq type as argument" }

synthType' Œì (App-A t t‚ÇÅ) = do
  T ‚Üê synthType Œì t
  T‚ÇÅ ‚Üê synthType Œì t‚ÇÅ
  case (hnfNorm Œì T) of Œª
    { (Pi-A _ u u‚ÇÅ) ‚Üí do
      catchError
        (checkŒ≤Œ∑ Œì T‚ÇÅ u)
        (Œª e ‚Üí throwError ("Type mismatch in application, the type of" <+> show t‚ÇÅ
          <+> ":" <+> show T‚ÇÅ +  " is not Œ≤Œ∑-equivalent to" <+> show u + "\nError:" <+> e))
      return $ subst u‚ÇÅ t‚ÇÅ
    ; v ‚Üí throwError $
      "The left term in an application needs to have a pi type, while it has type" <+> show v }

synthType' Œì (AppE-A t t‚ÇÅ) = do
  T ‚Üê synthType Œì t
  T‚ÇÅ ‚Üê synthType Œì t‚ÇÅ
  case (hnfNorm Œì T) of Œª
    { (All-A _ u u‚ÇÅ) ‚Üí do
      catchError (checkŒ≤Œ∑ Œì u T‚ÇÅ)
        (Œª e ‚Üí throwError
          ("Type mismatch in erased application, the following types are not Œ≤Œ∑-equivalent:\n"
            + show u + "\n" + show T‚ÇÅ + "\nError:\n" + e))
      return $ subst u‚ÇÅ t‚ÇÅ
    ; v ‚Üí throwError $
      "The left term in an erased application needs to have a forall type, while it has type "
        + show v + "\nTest:" <+> show T }

synthType' Œì (Rho-A t t‚ÇÅ t‚ÇÇ) = do
  T ‚Üê synthType Œì t
  T‚ÇÅ ‚Üê synthType Œì t‚ÇÇ
  case (hnfNorm Œì T) of Œª
    { (Eq-A u u‚ÇÅ) ‚Üí do
      catchError (checkŒ≤Œ∑ Œì (subst t‚ÇÅ u‚ÇÅ) T‚ÇÅ)
        (Œª e ‚Üí throwError $ "Type mismatch in rho:" <+> show (subst t‚ÇÅ u‚ÇÅ)
          <+> "should be Œ≤Œ∑-equivalent to the synthesized type of" <+> show t‚ÇÇ <+> ": "
          + show T‚ÇÅ + "\nError:\n" + e)
      return $ subst t‚ÇÅ u
    ; _ ‚Üí throwError "The type of the first argument of a rho needs to be an equality" }

synthType' Œì (All-A _ t t‚ÇÅ) = do
  u ‚Üê synthType Œì t
  case (hnfNorm Œì u) of Œª
    { (Sort-A s) ‚Üí do
      let Œì' = pushVar t Œì
      u‚ÇÅ ‚Üê synthType Œì' t‚ÇÅ
      case (hnfNorm Œì' u‚ÇÅ) of Œª
        { (Sort-A Ast) ‚Üí return ‚ãÜ
        ; v ‚Üí throwError $
          "The type family in forall should have type star, while it has type "
          + show v <+> "(" + show t‚ÇÅ + ")\nContext:" <+> show {{Context-Show}} Œì' }
    ; _ ‚Üí throwError "The type of the parameter type in forall should be star or square" }

synthType' Œì (Pi-A _ t t‚ÇÅ) = do
  u ‚Üê synthType Œì t
  case (hnfNorm Œì u) of Œª
    { (Sort-A s) ‚Üí do
      let Œì' = pushVar t Œì
      u‚ÇÅ ‚Üê synthType Œì' t‚ÇÅ
      case (hnfNorm Œì u‚ÇÅ) of Œª
        { (Sort-A s') ‚Üí return $ Sort-A s'
        ; v ‚Üí throwError $
          "The type family in pi should have type star or square, while it has type" <+> show v }
    ; _ ‚Üí throwError "The type of the parameter type in pi should be star or square" }

synthType' Œì (Iota-A _ t t‚ÇÅ) = do
  u ‚Üê synthType Œì t
  case (hnfNorm Œì u) of Œª
    { (Sort-A Ast) ‚Üí do
      let Œì' = pushVar t Œì
      u‚ÇÅ ‚Üê synthType Œì' t‚ÇÅ
      case (hnfNorm Œì' u‚ÇÅ) of Œª
        { (Sort-A Ast) ‚Üí return ‚ãÜ
        ; _ ‚Üí throwError "The type family in iota should have type star"}
    ; _ ‚Üí throwError "The type of the parameter type in iota should be star" }

synthType' Œì (Lam-A n t t‚ÇÅ) = do
  synthType Œì t
  u ‚Üê synthType (pushVar t Œì) t‚ÇÅ
  return (Pi-A n t u)

synthType' Œì (LamE-A n t t‚ÇÅ) =
  if checkFree (Bound 0) (Erase t‚ÇÅ)
    then throwError "Erased arguments cannot appear bound in a term"
    else do
      synthType Œì t
      u ‚Üê synthType (pushVar t Œì) t‚ÇÅ
      return $ All-A n t u

synthType' Œì (Pair-A t t‚ÇÅ t‚ÇÇ) = do
  catchError (checkŒ≤Œ∑ Œì t t‚ÇÅ)
    (Œª e ‚Üí throwError $
      "The terms in dependent intersection introduction have to be Œ≤Œ∑-equivalent. They normalize to:\n"
        + show (normalizePure Œì $ Erase t) + "\n"
        + show (normalizePure Œì $ Erase t‚ÇÅ) + "\nError:\n" + e)
  u ‚Üê synthType Œì t
  u‚ÇÅ ‚Üê synthType Œì t‚ÇÅ
  catchError
    (checkŒ≤Œ∑ Œì (subst t‚ÇÇ t) u‚ÇÅ)
    (Œª e ‚Üí throwError
      ("Type mismatch in the second argument of the dependent intersection: "
        + show (subst t‚ÇÇ t) <+> "should be Œ≤Œ∑-equivalent to the synthesized type "
        + show u‚ÇÅ + "\n" + e))
  let res = Iota-A "" u t‚ÇÇ
  u‚ÇÇ ‚Üê synthType Œì res
  case (hnfNorm Œì u‚ÇÇ) of Œª
    { (Sort-A Ast) ‚Üí return res
    ; _ ‚Üí throwError
      "The resulting iota type of the dependent intersection doesn't have type star. Is this a Bug?" }

synthType' Œì (Phi-A t t‚ÇÅ t‚ÇÇ) = do
  T ‚Üê synthType Œì t
  case (hnfNorm Œì T) of Œª
    { (Eq-A u u‚ÇÅ) ‚Üí do
      catchError
        (checkŒ≤Œ∑ Œì t‚ÇÅ u >> checkŒ≤Œ∑ Œì t‚ÇÇ u‚ÇÅ)
        (Œª e ‚Üí throwError $
          "The arguments to phi are not equivalent to the sides of the equality. Error:\n" + e)
      synthType Œì t‚ÇÅ
    ; _ ‚Üí throwError "The first argument to phi should be of an equality type" }

synthType' Œì (Eq-A x x‚ÇÅ) =
  if validInContext (Erase x) Œì
    then if validInContext (Erase x‚ÇÅ) Œì
      then return ‚ãÜ
      else throwError
        ("The right term in the equality type needs to be valid in the context:" <+> show x‚ÇÅ)
    else throwError
      ("The left term in the equality type needs to be valid in the context:" <+> show x)

synthType' Œì (M-A t) = do
  T ‚Üê synthType Œì t
  case (hnfNorm Œì T) of Œª
    { (Sort-A Ast) ‚Üí return ‚ãÜ
    ; _ ‚Üí throwError "The term M is applied to should have type ‚àó"}

synthType' Œì (Mu-A t t‚ÇÅ) = do
  T ‚Üê synthType Œì t
  T' ‚Üê synthType Œì t‚ÇÅ
  case (hnfNorm Œì T) of Œª
    { (M-A u) ‚Üí
      case (hnfNorm Œì T') of Œª
        { (Pi-A _ v v‚ÇÅ) ‚Üí do
          T'' ‚Üê if checkFree (Bound 0) (Erase v‚ÇÅ)
            then throwError ("Index 0 is not allowed to appear in" <+> show v‚ÇÅ)
            else synthType (pushVar v Œì) v‚ÇÅ
          case (hnfNorm Œì T'') of Œª
            { (Sort-A ‚àó) ‚Üí
              case (hnfNorm Œì v‚ÇÅ) of Œª
                { (M-A v‚ÇÇ) ‚Üí
                  appendIfError
                    (checkŒ≤Œ∑ Œì u v)
                    "The types in Œº need to be compatible" >> return (M-A $ strengthen v‚ÇÇ)
                ; _ ‚Üí throwError
                  "The second term in a Œº needs to have a Pi type that maps to 'M t' for some 't'" }
            ; _ ‚Üí throwError "The second term in a Œº needs to have a non-dependent Pi type" }
        ; _ ‚Üí throwError "The second term in a Œº needs to have a Pi type" }
    ; _ ‚Üí throwError "The first term in a Œº needs to have type 'M t' for some 't'" }

synthType' Œì (Epsilon-A t) = M-A <$> synthType Œì t

synthType' Œì (Ev-A m t) = do
  T ‚Üê traversePrimMetaArgs (synthType Œì) t
  appendIfError
    (primMetaArgsSequence $ primMetaArgsZipWith (checkŒ≤Œ∑ Œì) T $ primMetaS m)
    ("The arguments for primitive" <+> show m <+> "have incorrect types!")
  return $ M-A $ primMetaT m t

synthType' Œì (Gamma-A t t‚ÇÅ) = do
  T ‚Üê synthType Œì t
  T‚ÇÅ ‚Üê synthType Œì t‚ÇÅ
  case (hnfNorm Œì T) of Œª
    { (M-A u) ‚Üí do
      appendIfError (checkŒ≤Œ∑ Œì T‚ÇÅ (Pi-A "" (FreeVar "init$err") (weakenBy 1 $ M-A u)))
        ("The second term supplied to CatchErr has type" <+> show T‚ÇÅ +
         ", while it should have type 'init$err ‚Üí M" <+> show u)
      return $ M-A u
    ; _ ‚Üí throwError "The first term in CatchErr needs to have type 'M t' for some 't'" }

synthType' Œì (Char-A c) = return (Const-A CharT)
synthType' Œì (CharEq-A t t') = do
  T ‚Üê synthType Œì t
  T' ‚Üê synthType Œì t'
  case (hnfNorm Œì T) of Œª
    { (Const-A CharT) ‚Üí case (hnfNorm Œì T') of Œª
      { (Const-A CharT) ‚Üí return $ FreeVar "Bool"
      ; _ ‚Üí throwError "The second term in CharEq needs to have type Char" }
    ; _ ‚Üí throwError "The first term in CharEq needs to have type Char" }
