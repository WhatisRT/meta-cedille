{-# OPTIONS --type-in-type #-}

module meta-cedille where

open import Data.String using (toList)
open import IO using (Main; run)
open import Monads.Except
open import Monads.ExceptT

open import Prelude
open import Prelude.Strings

open import Parse.Generate
open import Parse.TreeConvert using (preCoreGrammar)
open import Bootstrap.InitEnv

open import CoreTheory
open import Execution

record EvalFlags : Set where
  field
    printAnything : Bool
    printInfo     : Bool -- print the results generated by a top level command

initFlagsDefault : EvalFlags
initFlagsDefault = record
  { printAnything = false
  ; printInfo     = false
  }

runtimeFlagsDefault : EvalFlags
runtimeFlagsDefault = record
  { printAnything = true
  ; printInfo     = true
  }

eval : MetaContext → String → EvalFlags → IO (MetaContext × Bool)
eval Γ ""    _     = return (Γ , true)
eval Γ input flags = let open EvalFlags flags in do
  (s , (inj₂ (out , _))) ← execute (parseAndExecute input) Γ
    where (_ , (inj₁ err)) → putStrErr err >> return (Γ , false)
  if printAnything ∧ printInfo
    then putStr $ unlines out
    else return tt
  return (contextFromState s , true)

rep : MetaContext → IO MetaContext
rep Γ = do
  putStr "\nλ> "
  flushStdout
  input ← getLine
  proj₁ <$> eval Γ input runtimeFlagsDefault

{-# NON_TERMINATING #-}
loop : ∀ {a} {A : Set a} → A → (A → IO A) → IO ⊤
loop start f = do
  res ← f start
  loop res f

repl : MetaContext → IO ⊤
repl start = loop start rep

record Options : Set where
  field
    startRepl   : Bool
    importFiles : List String
    verbose     : Bool
    showHelp    : Bool

defaultOptions : Options
defaultOptions = record
  { startRepl   = true
  ; importFiles = []
  ; verbose     = false
  ; showHelp    = false }

{-# TERMINATING #-}
readOptions : ExceptT IO String Options
readOptions = do
  args ← getArgs
  return $ readArgs args defaultOptions
  where
    argumentDec : Decidable _
    argumentDec s = false ≟ isInit "--" (toList s)

    readArgs : List String → Options → Except String Options
    readArgs [] current = return current
    readArgs ("--no-repl" ∷ input) current = readArgs input record current { startRepl = false }
    readArgs ("--verbose" ∷ input) current = readArgs input record current { verbose = true }
    readArgs ("--help"    ∷ input) current = readArgs input record current { showHelp = true }
    readArgs ("--load"    ∷ input) current with span argumentDec input
    ... | (files , rest)                   = readArgs rest record current { importFiles = files }
    readArgs (x           ∷ input) current = inj₁ ("Unknown option: " + x)

helpString : String
helpString = "Usage: meta-cedille [OPTIONS...]\n" +
  "  Version: 0.9\n\n" +
  concat ((λ { (fst , snd) → "    --" + padRight ' ' padLength fst + snd + "\n" }) <$> helpTable)
  where
    helpTable : List (String × String)
    helpTable =
      ("help"         , "Show this help") ∷
      ("load [FILES]" , "Loads a list of files before starting the REPL") ∷
      ("verbose"      , "Print supressed output before starting the REPL") ∷
      ("no-repl"      , "Exits the program when the REPL would start") ∷ []

    padLength : ℕ
    padLength = 4 + maximum (Data.String.length ∘ proj₁ <$> helpTable)

-- this is never actually used, `parseBootstrap` provides its own copy of this
-- TODO: remove this, or rework the bootstrapping phase
initGrammar : Grammar
initGrammar = from-inj₂ $ preCoreGrammar {{Except-Monad}} {{Except-MonadExcept}}

bootstrapMetaContext : MetaContext
bootstrapMetaContext =
  emptyGlobalContext , record { grammar = initGrammar ; namespace = "" ; evaluator = □ }

loadFiles : MetaContext → EvalFlags → List String → IO (MetaContext × Bool)
loadFiles context flags []    = return (context , true)
loadFiles context flags files =
  eval context (concat $ map (λ file → "import " + file + ".") files) flags

main : Main
main = run $ do
  (inj₂ o) ← readOptions
    where (inj₁ x) → putStr x
  let open Options o in
    if showHelp then putStr helpString else do
      (init , successInit) ← eval bootstrapMetaContext initEnv initFlagsDefault
      let initFlags = if verbose then runtimeFlagsDefault else initFlagsDefault
      (postLoad , successLoad) ← loadFiles init initFlags importFiles
      if startRepl
        then repl postLoad
        else if successInit ∧ successLoad
          then exitSuccess
          else exitFailure
