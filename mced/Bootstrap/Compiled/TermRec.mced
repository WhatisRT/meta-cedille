let mapAppList := Λ X : * Λ Y : * λ f : Π _ : X Y λ l : [List [[Product Bool] X]] [[<<map [[Product Bool] X]> [[Product Bool] Y]> [<<<recursionProduct Bool> X> [[Product Bool] Y]> λ b : Bool λ x : X [[<<prodPair Bool> Y> b] [f x]]]] l] : ∀ X : * ∀ Y : * Π f : Π _ : X Y Π l : [List [[Product Bool] X]] [List [[Product Bool] Y]].
let distList := Λ X : * Λ Y : * Λ Z : * λ l : [List [[[TripleProduct X] Y] Z]] [[<l [[Product [List [[Product X] Y]]] [List [[Product X] Z]]]> [[<<prodPair [List [[Product X] Y]]> [List [[Product X] Z]]> <nil [[Product X] Y]>] <nil [[Product X] Z]>]] [<<<<recursionTripleProduct X> Y> Z> Π _ : [[Product [List [[Product X] Y]]] [List [[Product X] Z]]] [[Product [List [[Product X] Y]]] [List [[Product X] Z]]]> λ x : X λ y : Y λ z : Z [<<<recursionProduct [List [[Product X] Y]]> [List [[Product X] Z]]> [[Product [List [[Product X] Y]]] [List [[Product X] Z]]]> λ l : [List [[Product X] Y]] λ r : [List [[Product X] Z]] [[<<prodPair [List [[Product X] Y]]> [List [[Product X] Z]]> [[<cons [[Product X] Y]> [[<<prodPair X> Y> x] y]] l]] [[<cons [[Product X] Z]> [[<<prodPair X> Z> x] z]] r]]]]] : ∀ X : * ∀ Y : * ∀ Z : * Π l : [List [[[TripleProduct X] Y] Z]] [[Product [List [[Product X] Y]]] [List [[Product X] Z]]].
let recursionTerm := Λ X : * λ fvar : Π _ : Var X λ fsort : Π _ : Sort X λ fbind : Π _ : Binder Π _ : String Π _ : Term Π _ : Term Π _ : X Π _ : X X λ fapp : Π _ : Term Π _ : [List App] Π _ : X Π _ : [List [[Product Bool] X]] X λ fchar : Π _ : Char X λ funk : X λ funq : Π _ : Term Π _ : X X λ term : Term [<<pr1 X> Term> [[[[[[[<term [[Product X] Term]> λ v : Var [[<<prodPair X> Term> [fvar v]] [varTerm v]]] λ s : Sort [[<<prodPair X> Term> [fsort s]] [sortTerm s]]] λ b : Binder λ n : String [<<<recursionProduct X> Term> Π _ : [[Product X] Term] [[Product X] Term]> λ T1 : X λ T2 : Term [<<<recursionProduct X> Term> [[Product X] Term]> λ t1 : X λ t2 : Term [[<<prodPair X> Term> [[[[[[fbind b] n] T2] t2] T1] t1]] [[[[binderTerm b] n] T2] t2]]]]] [<<<recursionProduct X> Term> Π _ : [List [[Product Bool] [[Product X] Term]]] [[Product X] Term]> λ t1 : X λ t2 : Term λ l : [List [[Product Bool] [[Product X] Term]]] [[<<<recursionProduct [List [[Product Bool] X]]> [List [[Product Bool] Term]]> [[Product X] Term]> λ l1 : [List [[Product Bool] X]] λ l2 : [List [[Product Bool] Term]] [[<<prodPair X> Term> [[[[fapp t2] l2] t1] l1]] [[appLTerm t2] l2]]] [<<<distList Bool> X> Term> l]]]] λ c : Char [[<<prodPair X> Term> [fchar c]] [charTerm c]]] [[<<prodPair X> Term> funk] unknownTerm]] [<<<recursionProduct X> Term> [[Product X] Term]> λ u1 : X λ u2 : Term [[<<prodPair X> Term> [[funq u2] u1]] [unquoteTerm u2]]]]] : ∀ X : * Π fvar : Π _ : Var X Π fsort : Π _ : Sort X Π fbind : Π _ : Binder Π _ : String Π _ : Term Π _ : Term Π _ : X Π _ : X X Π fapp : Π _ : Term Π _ : [List App] Π _ : X Π _ : [List [[Product Bool] X]] X Π fchar : Π _ : Char X Π funk : X Π funq : Π _ : Term Π _ : X X Π term : Term X.
let matchTerm := Λ X : * λ fvar : Π _ : Var X λ fsort : Π _ : Sort X λ fbind : Π _ : Binder Π _ : String Π _ : Term Π _ : Term X λ fapp : Π _ : Term Π _ : [List App] X λ fchar : Π _ : Char X λ funk : X λ funq : Π _ : Term X [[[[[[[<recursionTerm X> fvar] fsort] λ b : Binder λ n : String λ T : Term λ t : Term λ _ : X λ _ : X [[[[fbind b] n] T] t]] λ t : Term λ app : [List App] λ _ : X λ _ : [List [[Product Bool] X]] [[fapp t] app]] fchar] funk] λ t : Term λ _ : X [funq t]] : ∀ X : * Π fvar : Π _ : Var X Π fsort : Π _ : Sort X Π fbind : Π _ : Binder Π _ : String Π _ : Term Π _ : Term X Π fapp : Π _ : Term Π _ : [List App] X Π fchar : Π _ : Char X Π funk : X Π funq : Π _ : Term X Π _ : Term X.
let stripLambda := λ term : Term [<<pr1 [Maybe Term]> Term> [[[[[[[<term [[Product [Maybe Term]] Term]> λ v : Var [[<<prodPair [Maybe Term]> Term> [λ _ : Var <nothing Term> v]] [varTerm v]]] λ s : Sort [[<<prodPair [Maybe Term]> Term> [λ _ : Sort <nothing Term> s]] [sortTerm s]]] λ b : Binder λ n : String [<<<recursionProduct [Maybe Term]> Term> Π _ : [[Product [Maybe Term]] Term] [[Product [Maybe Term]] Term]> λ T1 : [Maybe Term] λ T2 : Term [<<<recursionProduct [Maybe Term]> Term> [[Product [Maybe Term]] Term]> λ t1 : [Maybe Term] λ t2 : Term [[<<prodPair [Maybe Term]> Term> [[[[[[λ b : Binder λ n : String λ T : Term λ t : Term λ _ : [Maybe Term] λ _ : [Maybe Term] [[[[λ b : Binder λ _ : String λ T : Term λ t : Term [[[[<b [Maybe Term]> [<just Term> t]] [<just Term> t]] <nothing Term>] <nothing Term>] b] n] T] t] b] n] T2] t2] T1] t1]] [[[[binderTerm b] n] T2] t2]]]]] [<<<recursionProduct [Maybe Term]> Term> Π _ : [List [[Product Bool] [[Product [Maybe Term]] Term]]] [[Product [Maybe Term]] Term]> λ t1 : [Maybe Term] λ t2 : Term λ l : [List [[Product Bool] [[Product [Maybe Term]] Term]]] [[<<<recursionProduct [List [[Product Bool] [Maybe Term]]]> [List [[Product Bool] Term]]> [[Product [Maybe Term]] Term]> λ l1 : [List [[Product Bool] [Maybe Term]]] λ l2 : [List [[Product Bool] Term]] [[<<prodPair [Maybe Term]> Term> [[[[λ t : Term λ app : [List App] λ _ : [Maybe Term] λ _ : [List [[Product Bool] [Maybe Term]]] [[λ _ : Term λ _ : [List App] <nothing Term> t] app] t2] l2] t1] l1]] [[appLTerm t2] l2]]] [<<<distList Bool> [Maybe Term]> Term> l]]]] λ c : Char [[<<prodPair [Maybe Term]> Term> [λ _ : Char <nothing Term> c]] [charTerm c]]] [[<<prodPair [Maybe Term]> Term> <nothing Term>] unknownTerm]] [<<<recursionProduct [Maybe Term]> Term> [[Product [Maybe Term]] Term]> λ u1 : [Maybe Term] λ u2 : Term [[<<prodPair [Maybe Term]> Term> [[λ t : Term λ _ : [Maybe Term] [λ _ : Term <nothing Term> t] u2] u1]] [unquoteTerm u2]]]]] : Π _ : Term [Maybe Term].
let stripLambdas := λ n : Nat [[<n Π _ : Term [Maybe Term]> <just Term>] λ rec : Π _ : Term [Maybe Term] λ t : Term [[<<bindMaybe Term> Term> [stripLambda t]] rec]] : Π n : Nat Π _ : Term [Maybe Term].
let stripPi := λ term : Term [<<pr1 [Maybe Term]> Term> [[[[[[[<term [[Product [Maybe Term]] Term]> λ v : Var [[<<prodPair [Maybe Term]> Term> [λ _ : Var <nothing Term> v]] [varTerm v]]] λ s : Sort [[<<prodPair [Maybe Term]> Term> [λ _ : Sort <nothing Term> s]] [sortTerm s]]] λ b : Binder λ n : String [<<<recursionProduct [Maybe Term]> Term> Π _ : [[Product [Maybe Term]] Term] [[Product [Maybe Term]] Term]> λ T1 : [Maybe Term] λ T2 : Term [<<<recursionProduct [Maybe Term]> Term> [[Product [Maybe Term]] Term]> λ t1 : [Maybe Term] λ t2 : Term [[<<prodPair [Maybe Term]> Term> [[[[[[λ b : Binder λ n : String λ T : Term λ t : Term λ _ : [Maybe Term] λ _ : [Maybe Term] [[[[λ b : Binder λ _ : String λ T : Term λ t : Term [[[[<b [Maybe Term]> <nothing Term>] <nothing Term>] [<just Term> t]] <nothing Term>] b] n] T] t] b] n] T2] t2] T1] t1]] [[[[binderTerm b] n] T2] t2]]]]] [<<<recursionProduct [Maybe Term]> Term> Π _ : [List [[Product Bool] [[Product [Maybe Term]] Term]]] [[Product [Maybe Term]] Term]> λ t1 : [Maybe Term] λ t2 : Term λ l : [List [[Product Bool] [[Product [Maybe Term]] Term]]] [[<<<recursionProduct [List [[Product Bool] [Maybe Term]]]> [List [[Product Bool] Term]]> [[Product [Maybe Term]] Term]> λ l1 : [List [[Product Bool] [Maybe Term]]] λ l2 : [List [[Product Bool] Term]] [[<<prodPair [Maybe Term]> Term> [[[[λ t : Term λ app : [List App] λ _ : [Maybe Term] λ _ : [List [[Product Bool] [Maybe Term]]] [[λ _ : Term λ _ : [List App] <nothing Term> t] app] t2] l2] t1] l1]] [[appLTerm t2] l2]]] [<<<distList Bool> [Maybe Term]> Term> l]]]] λ c : Char [[<<prodPair [Maybe Term]> Term> [λ _ : Char <nothing Term> c]] [charTerm c]]] [[<<prodPair [Maybe Term]> Term> <nothing Term>] unknownTerm]] [<<<recursionProduct [Maybe Term]> Term> [[Product [Maybe Term]] Term]> λ u1 : [Maybe Term] λ u2 : Term [[<<prodPair [Maybe Term]> Term> [[λ t : Term λ _ : [Maybe Term] [λ _ : Term <nothing Term> t] u2] u1]] [unquoteTerm u2]]]]] : Π _ : Term [Maybe Term].
let stripPis := λ n : Nat [[<n Π _ : Term [Maybe Term]> <just Term>] λ rec : Π _ : Term [Maybe Term] λ t : Term [[<<bindMaybe Term> Term> [stripPi t]] rec]] : Π n : Nat Π _ : Term [Maybe Term].
let matchVar := Λ X : * λ def : X λ f : Π _ : Var X λ t : Term [[[[[[[[<matchTerm X> f] λ _ : Sort def] λ _ : Binder λ _ : String λ _ : Term λ _ : Term def] λ _ : Term λ _ : [List App] def] λ _ : Char def] def] λ _ : Term def] t] : ∀ X : * Π def : X Π f : Π _ : Var X Π t : Term X.
let matchApp := Λ X : * λ def : X λ f : Π _ : Term Π _ : [List App] X λ t : Term [[[[[[[[<matchTerm X> λ _ : Var def] λ _ : Sort def] λ _ : Binder λ _ : String λ _ : Term λ _ : Term def] f] λ _ : Char def] def] λ _ : Term def] t] : ∀ X : * Π def : X Π f : Π _ : Term Π _ : [List App] X Π t : Term X.