let renameVar := λ boundNames : [List String] λ f : Π _ : String String λ v : Var [[<v Var> λ s : String [varString [[[<ifthenelse String> [[[<isMember String> stringEq] boundNames] s]] s] [f s]]]] varIndex] : Π boundNames : [List String] Π f : Π _ : String String Π v : Var Var.
let renameNamesInTermHelper := λ f : Π _ : String String λ t : Term [[[[[[[<t Π _ : [List String] Term> λ v : Var λ boundNames : [List String] [varTerm [[[renameVar boundNames] f] v]]] λ s : Sort λ _ : [List String] [sortTerm s]] λ b : Binder λ n : String λ T : Π _ : [List String] Term λ t : Π _ : [List String] Term λ boundNames : [List String] [[[[binderTerm b] n] [T boundNames]] [t [[<cons String> n] boundNames]]]] λ t : Π _ : [List String] Term λ l : [List [[Product Bool] Π _ : [List String] Term]] λ bn : [List String] [[appLTerm [t bn]] [[<<map [[Product Bool] Π _ : [List String] Term]> [[Product Bool] Term]> [<<<recursionProduct Bool> Π _ : [List String] Term> [[Product Bool] Term]> λ b : Bool λ tm : Π _ : [List String] Term [[<<prodPair Bool> Term> b] [tm bn]]]] l]]] λ c : Char λ _ : [List String] [charTerm c]] λ _ : [List String] unknownTerm] λ u : Π _ : [List String] Term λ bn : [List String] [unquoteTerm [u bn]]] : Π f : Π _ : String String Π t : Term Π _ : [List String] Term.
let renameNamesInTerm := λ f : Π _ : String String λ t : Term [[[renameNamesInTermHelper f] t] <nil String>] : Π f : Π _ : String String Π t : Term Term.
let quoteParam := λ p : Param [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κP] [[stringCons κa] [[stringCons κr] [[stringCons κa] [[stringCons κm] stringNil]]]]]]]]] [[<cons App> [[mkApp false] [quoteBool [paramErased p]]]] [[<cons App> [[mkApp false] [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κP] [[stringCons κr] [[stringCons κe] [[stringCons κP] [[stringCons κa] [[stringCons κr] [[stringCons κa] [[stringCons κm] stringNil]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteString [paramName p]]]] [[<cons App> [[mkApp false] [quoteTerm [paramType p]]]] <nil App>]]]]] <nil App>]]] : Π p : Param Term.
let quoteTelescope := λ t : Telescope [[quoteTermList [[appLTerm [sVarTerm [[stringCons κP] [[stringCons κa] [[stringCons κr] [[stringCons κa] [[stringCons κm] stringNil]]]]]]] <nil App>]] [[<<map Param> Term> quoteParam] t]] : Π t : Telescope Term.
let findModule := λ n : ModuleName [[<<mapEval ModuleState> [Maybe [[Product Bool] Module]]> λ s : ModuleState [[lookupModuleDict n] [ModuleStateDict s]]] getModuleState'] : Π n : ModuleName [Eval [Maybe [[Product Bool] Module]]].
let findLoadedModule := λ n : ModuleName [[<<bindEval [Maybe [[Product Bool] Module]]> [Maybe Module]> [findModule n]] λ x : [Maybe [[Product Bool] Module]] [<pureEval [Maybe Module]> [[[<<maybe [[Product Bool] Module]> [Maybe Module]> <nothing Module>] [<<<recursionProduct Bool> Module> [Maybe Module]> λ loaded : Bool λ m : Module [[[<ifthenelse [Maybe Module]> loaded] [<just Module> m]] <nothing Module>]]] x]]] : Π n : ModuleName [Eval [Maybe Module]].
let moduleIsLoaded := λ n : ModuleName [[<<bindEval [Maybe [[Product Bool] Module]]> Bool> [findModule n]] λ x : [Maybe [[Product Bool] Module]] [<pureEval Bool> [[[<<maybe [[Product Bool] Module]> Bool> false] <<pr1 Bool> Module>] x]]] : Π n : ModuleName [Eval Bool].
let getNewModuleVersion := λ n : ModuleName [[<<bindEval [Maybe [[Product Bool] Module]]> Nat> [findModule n]] λ x : [Maybe [[Product Bool] Module]] [<pureEval Nat> [[[<<maybe [[Product Bool] Module]> Nat> zero] λ p : [[Product Bool] Module] [suc [ModuleVersion [<<pr2 Bool> Module> p]]]] x]]] : Π n : ModuleName [Eval Nat].
let initModule := λ n : ModuleName λ t : Telescope [[<<bindEval Nat> Unit> [getNewModuleVersion n]] λ v : Nat [λ m : Module [[seqNewStmt [letInfoToNewStmt [[[mkLetInfo [mkTempModuleName m]] [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κI] [[stringCons κn] [[stringCons κi] [[stringCons κt] [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] stringNil]]]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteModuleName n]]] [[<cons App> [[mkApp false] [quoteNat v]]] [[<cons App> [[mkApp false] [quoteTelescope t]]] <nil App>]]]]] [<just Term> [[appLTerm [sVarTerm [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] stringNil]]]]]]]] <nil App>]]]]] [modifyEval [modifyModuleInState [<cons Module> m]]]] [[[mkInitModule n] v] t]]] : Π n : ModuleName Π t : Telescope [Eval Unit].
let consModule := λ n : String λ m : Module [[[[mkModule [ModuleModuleName m]] [ModuleVersion m]] [ModuleTelescope m]] [[<cons String> n] [ModuleContents m]]] : Π n : String Π m : Module Module.
let updateTempModule := λ n : String λ m : Module [[seqNewStmt [letInfoToNewStmt [[[mkLetInfo [mkTempModuleNameSuc m]] [[appLTerm [sVarTerm [[stringCons κc] [[stringCons κo] [[stringCons κn] [[stringCons κs] [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] stringNil]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteString n]]] [[<cons App> [[mkApp false] [sVarTerm [mkTempModuleName m]]]] <nil App>]]]] [<just Term> [[appLTerm [sVarTerm [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] stringNil]]]]]]]] <nil App>]]]]] [modifyEval [modifyModuleInState [<mapHead Module> λ _ : [Maybe Module] [<just Module> [[consModule n] m]]]]]] : Π n : String Π m : Module [Eval Unit].
let nameToModuleName := λ m : Module λ n : String [[stringApp [mkModuleContentPrefix [ModuleModuleInfo m]]] n] : Π m : Module Π n : String String.
let nameToMaybeModuleName := λ x : [Maybe Module] λ n : String [[[<<maybe Module> String> n] λ m : Module [[nameToModuleName m] n]] x] : Π x : [Maybe Module] Π n : String String.
let importExternalLetInfo := λ name : String λ m : Module [[[mkLetInfo [[nameToModuleName m] name]] [sVarTerm name]] <nothing Term>] : Π name : String Π m : Module LetInfo.
let modifyTerm := λ t : Term λ m : Module [[renameNamesInTerm [stringApp [mkModuleContentPrefix [ModuleModuleInfo m]]]] t] : Π t : Term Π m : Module Term.
let modifyTermMod := λ t : Term [[<<bindEval EvalState> Term> getEval] λ s : EvalState [<pureEval Term> [[[<<maybe Module> Term> t] [modifyTerm t]] [ModuleStateCurrentModule [getModuleState s]]]]] : Π t : Term [Eval Term].
let modifyLetInfo := λ i : LetInfo λ m : Module [[<<<<recursionTripleProduct String> Term> [Maybe Term]> LetInfo> λ n : String λ t : Term λ T : [Maybe Term] [[[mkLetInfo [[nameToModuleName m] n]] [[modifyTerm [[foldWithLambdas [ModuleTelescope m]] t]] m]] [[[<<maybe Term> [Maybe Term]> <nothing Term>] λ t : Term [<just Term> [[modifyTerm [[foldWithPi [ModuleTelescope m]] t]] m]]] T]]] i] : Π i : LetInfo Π m : Module LetInfo.
let letInModule := λ i : LetInfo λ m : Module [[<<<<recursionTripleProduct String> Term> [Maybe Term]> [Eval LetInfo]> λ n : String λ t : Term λ T : [Maybe Term] [[<<seqEval Unit> LetInfo> [[updateTempModule n] m]] [<pureEval LetInfo> [[modifyLetInfo [[[mkLetInfo n] t] T]] m]]]] i] : Π i : LetInfo Π m : Module [Eval LetInfo].
let letInMaybeModule := λ i : LetInfo λ x : [Maybe Module] [[[<<maybe Module> [Eval LetInfo]> [<pureEval LetInfo> i]] [letInModule i]] x] : Π i : LetInfo Π x : [Maybe Module] [Eval LetInfo].
let moduleElab := λ i : LetInfo [[<<bindEval EvalState> LetInfo> getEval] λ s : EvalState [[letInMaybeModule i] [ModuleStateCurrentModule [getModuleState s]]]] : ElabLet.
let importExternalStmt := λ name : String [[<<bindEval EvalState> Unit> getEval] λ s : EvalState [[[<<maybe Module> [Eval Unit]> [<throwEval Unit> [[stringCons κE] [[stringCons κx] [[stringCons κt] [[stringCons κe] [[stringCons κr] [[stringCons κn] [[stringCons κa] [[stringCons κl] [[stringCons κ ] [[stringCons κi] [[stringCons κm] [[stringCons κp] [[stringCons κo] [[stringCons κr] [[stringCons κt] [[stringCons κs] [[stringCons κ ] [[stringCons κa] [[stringCons κr] [[stringCons κe] [[stringCons κ ] [[stringCons κo] [[stringCons κn] [[stringCons κl] [[stringCons κy] [[stringCons κ ] [[stringCons κp] [[stringCons κo] [[stringCons κs] [[stringCons κs] [[stringCons κi] [[stringCons κb] [[stringCons κl] [[stringCons κe] [[stringCons κ ] [[stringCons κi] [[stringCons κn] [[stringCons κ ] [[stringCons κm] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κs] [[stringCons κ!] stringNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] λ m : Module [stmtToNewStmt [convertLetInfo [[importExternalLetInfo name] m]]]] [ModuleStateCurrentModule [getModuleState s]]]] : Π name : String [Eval Unit].
let updateModuleDict := λ m : Module λ d : ModuleDict [letInfoToNewStmt [[[mkLetInfo [mkModuleDictNameSuc d]] [[appLTerm [sVarTerm [[stringCons κi] [[stringCons κn] [[stringCons κs] [[stringCons κe] [[stringCons κr] [[stringCons κt] [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κD] [[stringCons κi] [[stringCons κc] [[stringCons κt] stringNil]]]]]]]]]]]]]]]]]] [[<cons App> [[mkApp false] [sVarTerm [mkModuleName m]]]] [[<cons App> [[mkApp false] [sVarTerm [mkModuleDictName d]]]] <nil App>]]]] [<just Term> [[appLTerm [sVarTerm [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κD] [[stringCons κi] [[stringCons κc] [[stringCons κt] stringNil]]]]]]]]]]]] <nil App>]]]] : Π m : Module Π d : ModuleDict [Eval Unit].
let unloadModuleDictStmt := λ n : ModuleName λ d : ModuleDict [[<<bindEval Bool> Unit> [moduleIsLoaded n]] λ loaded : Bool [[[<ifthenelse [Eval Unit]> loaded] [[seqNewStmt [letInfoToNewStmt [[[mkLetInfo [mkModuleDictNameSuc d]] [[appLTerm [sVarTerm [[stringCons κu] [[stringCons κn] [[stringCons κl] [[stringCons κo] [[stringCons κa] [[stringCons κd] [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κF] [[stringCons κr] [[stringCons κo] [[stringCons κm] [[stringCons κD] [[stringCons κi] [[stringCons κc] [[stringCons κt] stringNil]]]]]]]]]]]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteModuleName n]]] [[<cons App> [[mkApp false] [sVarTerm [mkModuleDictName d]]]] <nil App>]]]] [<just Term> [[appLTerm [sVarTerm [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κD] [[stringCons κi] [[stringCons κc] [[stringCons κt] stringNil]]]]]]]]]]]] <nil App>]]]]] [modifyEval [modifyModuleDictInState λ _ : ModuleDict [[unloadModuleFromDict n] d]]]]] [<throwEval Unit> [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κ ] [[stringCons κi] [[stringCons κs] [[stringCons κn] [[stringCons κ'] [[stringCons κt] [[stringCons κ ] [[stringCons κl] [[stringCons κo] [[stringCons κa] [[stringCons κd] [[stringCons κe] [[stringCons κd] [[stringCons κ!] stringNil]]]]]]]]]]]]]]]]]]]]]]] : Π n : ModuleName Π d : ModuleDict [Eval Unit].
let finishModuleDef := λ m : Module λ d : ModuleDict [seqNewStmts [[<cons [Eval Unit]> [letInfoToNewStmt [[[mkLetInfo [mkModuleName m]] [sVarTerm [mkTempModuleName m]]] [<just Term> [[appLTerm [sVarTerm [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] stringNil]]]]]]]] <nil App>]]]]] [[<cons [Eval Unit]> [[updateModuleDict m] d]] [[<cons [Eval Unit]> [modifyModuleState λ s : ModuleState [[mkModuleState [<tail Module> [ModuleStateModuleStack s]]] [[insertModuleDict m] d]]]] <nil [Eval Unit]>]]]] : Π m : Module Π d : ModuleDict [Eval Unit].
let endModule := [[<<bindEval ModuleState> Unit> getModuleState'] λ s : ModuleState [[[<<maybe Module> [Eval Unit]> [<throwEval Unit> [[stringCons κC] [[stringCons κu] [[stringCons κr] [[stringCons κr] [[stringCons κe] [[stringCons κn] [[stringCons κt] [[stringCons κl] [[stringCons κy] [[stringCons κ ] [[stringCons κn] [[stringCons κo] [[stringCons κt] [[stringCons κ ] [[stringCons κi] [[stringCons κn] [[stringCons κ ] [[stringCons κa] [[stringCons κ ] [[stringCons κm] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κ!] stringNil]]]]]]]]]]]]]]]]]]]]]]]]]]]] λ m : Module [[finishModuleDef m] [ModuleStateDict s]]] [ModuleStateCurrentModule s]]] : [Eval Unit].
let importModule := λ m : Module λ l : [List App] [[<<bindEval ModuleState> Unit> getModuleState'] λ s : ModuleState [seqNewStmts [[<<map String> [Eval Unit]> λ n : String [letInfoToNewStmt [[[mkLetInfo [[nameToMaybeModuleName [ModuleStateCurrentModule s]] n]] [[appLTerm [sVarTerm [[nameToModuleName m] n]]] l]] <nothing Term>]]] [ModuleContents m]]]] : Π m : Module Π l : [List App] [Eval Unit].
let moduleNameToPath := λ n : ModuleName [stringConcat [[<intersperse String> [[stringCons κ/] stringNil]] n]] : Π n : ModuleName String.
let loadModule := λ n : ModuleName λ prefix : String [[<<seqEval Unit> Unit> [[[debugPrint LogTypeDebug] zero] [[stringCons κL] [[stringCons κo] [[stringCons κa] [[stringCons κd] [[stringCons κi] [[stringCons κn] [[stringCons κg] [[stringCons κ ] [[stringCons κm] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κ:] [[stringCons κ ] [[stringApp [ModuleNameToName n]] stringNil]]]]]]]]]]]]]]]]]]] [import [[stringApp prefix] [moduleNameToPath n]]]] : Π n : ModuleName Π prefix : String [Eval Unit].
let importModuleWithLoad := λ n : ModuleName λ l : [List App] [[<<bindEval Bool> Unit> [moduleIsLoaded n]] λ loaded : Bool [[seqNewStmt [[[<ifthenelse [Eval Unit]> loaded] emptyStmt] [[loadModule n] stringNil]]] [[<<bindEval [Maybe Module]> Unit> [findLoadedModule n]] [[<<maybe Module> [Eval Unit]> [<throwEval Unit> [[stringCons κi] [[stringCons κm] [[stringCons κp] [[stringCons κo] [[stringCons κr] [[stringCons κt] [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κW] [[stringCons κi] [[stringCons κt] [[stringCons κh] [[stringCons κL] [[stringCons κo] [[stringCons κa] [[stringCons κd] [[stringCons κ:] [[stringCons κ ] [[stringCons κe] [[stringCons κr] [[stringCons κr] [[stringCons κo] [[stringCons κr] stringNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]] λ m : Module [[importModule m] l]]]]] : Π n : ModuleName Π l : [List App] [Eval Unit].
let init$moduleName'$=colon=_string__moduleName'_ := λ s : String λ n : ModuleName [[<cons String> s] n] : Π s : String Π n : ModuleName [List String].
let init$moduleName'$ := <nil String> : [List String].
let init$moduleName$_string__moduleName'_ := λ s : String λ n : ModuleName [[<cons String> s] n] : Π s : String Π n : ModuleName [List String].
let init$givenArgs$=dot= := <nil String> : [List String].
let init$givenArgs$^space^_string__givenArgs_ := λ s : String λ l : [List String] [[<cons String> s] l] : Π s : String Π l : [List String] [List String].
let init$newStmt'$module^space^_moduleName__telescope'_=dot= := λ m : ModuleName λ t : Telescope [[initModule m] t] : Π m : ModuleName Π t : Telescope [Eval Unit].
let init$newStmt'$endModule=dot= := endModule : [Eval Unit].
let init$newStmt'$importModule^space^_moduleName__maybeApplist_=dot= := λ n : ModuleName λ l : [List App] [[importModuleWithLoad n] l] : Π n : ModuleName Π l : [List App] [Eval Unit].
let init$newStmt'$Given_givenArgs_ := λ args : [List String] [seqNewStmts [[<<map String> [Eval Unit]> importExternalStmt] args]] : Π args : [List String] [Eval Unit].
let init$newStmt'$Unload^space^_moduleName_=dot= := λ n : ModuleName [[<<bindEval ModuleState> Unit> getModuleState'] λ s : ModuleState [[unloadModuleDictStmt n] [ModuleStateDict s]]] : Π n : ModuleName [Eval Unit].