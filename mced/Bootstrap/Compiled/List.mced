let List := λ A : * ∀ X : * Π _ : X Π _ : Π _ : A Π _ : X X X : Π A : * *.
let nil := Λ A : * Λ X : * λ n : X λ c : Π _ : A Π _ : X X n : ∀ A : * [List A].
let cons := Λ A : * λ a : A λ as : [List A] Λ X : * λ n : X λ c : Π _ : A Π _ : X X [[c a] [[<as X> n] c]] : ∀ A : * Π a : A Π as : [List A] [List A].
let recursionList := Λ A : * Λ X : * λ rn : X λ rc : Π _ : A Π _ : [List A] Π _ : X X λ l : [List A] [<<pr2 [List A]> X> [[<l [[Product [List A]] X]> [[<<prodPair [List A]> X> <nil A>] rn]] λ a : A [<<<recursionProduct [List A]> X> [[Product [List A]] X]> λ p1 : [List A] λ p2 : X [[<<prodPair [List A]> X> [[<cons A> a] p1]] [[[rc a] p1] p2]]]]] : ∀ A : * ∀ X : * Π rn : X Π rc : Π _ : A Π _ : [List A] Π _ : X X Π l : [List A] X.
let recursionList' := Λ A : * Λ X : * λ rn : X λ rc : Π _ : A Π _ : X X λ l : [List A] [[<l X> rn] rc] : ∀ A : * ∀ X : * Π rn : X Π rc : Π _ : A Π _ : X X Π l : [List A] X.
let length := Λ X : * λ l : [List X] [[<l Nat> zero] λ x : X λ n : Nat [suc n]] : ∀ X : * Π l : [List X] Nat.
let isNil := Λ X : * λ l : [List X] [[<l Bool> true] λ _ : X λ _ : Bool false] : ∀ X : * Π l : [List X] Bool.
let listEq := Λ X : * λ eqX : Π _ : X Π _ : X Bool [[<<recursionList' X> Π l : [List X] Bool> <isNil X>] λ x : X λ rec : Π _ : [List X] Bool [[<<recursionList X> Bool> false] λ y : X λ ys : [List X] λ _ : Bool [[and [[eqX x] y]] [rec ys]]]] : ∀ X : * Π eqX : Π _ : X Π _ : X Bool Π _ : [List X] Π _ : [List X] Bool.
let pureList := Λ X : * λ x : X [[<cons X> x] <nil X>] : ∀ X : * Π x : X [List X].
let app := Λ X : * λ l1 : [List X] λ l2 : [List X] [[<l1 [List X]> l2] λ x : X λ rec : [List X] [[<cons X> x] rec]] : ∀ X : * Π l1 : [List X] Π l2 : [List X] [List X].
let snoc := Λ X : * λ x : X λ xs : [List X] [[<app X> xs] [<pureList X> x]] : ∀ X : * Π x : X Π xs : [List X] [List X].
let reverse := Λ X : * λ l : [List X] [[<l [List X]> <nil X>] λ x : X λ rec : [List X] [[<snoc X> x] rec]] : ∀ X : * Π l : [List X] [List X].
let filter := Λ X : * λ f : Π _ : X Bool λ l : [List X] [[<l [List X]> <nil X>] λ x : X λ rec : [List X] [[[<ifthenelse [List X]> [f x]] [[<cons X> x] rec]] rec]] : ∀ X : * Π f : Π _ : X Bool Π l : [List X] [List X].
let foldl := Λ A : * Λ B : * λ f : Π _ : B Π _ : A B λ l : [List A] [[<l Π _ : B B> λ b : B b] λ a : A λ rec : Π _ : B B λ b : B [[f [rec b]] a]] : ∀ A : * ∀ B : * Π f : Π _ : B Π _ : A B Π l : [List A] Π _ : B B.
let foldr := Λ A : * Λ B : * λ f : Π _ : B Π _ : A B λ l : [List A] [[<<foldl A> B> f] [<reverse A> l]] : ∀ A : * ∀ B : * Π f : Π _ : B Π _ : A B Π l : [List A] Π _ : B B.
let scanl := Λ A : * Λ B : * λ f : Π _ : B Π _ : A B λ b : B [[<<recursionList A> [List B]> [<pureList B> b]] λ a : A λ as : [List A] λ rec : [List B] [[<cons B> [[[<<foldl A> B> f] [[<cons A> a] as]] b]] rec]] : ∀ A : * ∀ B : * Π f : Π _ : B Π _ : A B Π b : B Π _ : [List A] [List B].
let map := Λ X : * Λ Y : * λ f : Π _ : X Y λ l : [List X] [[<l [List Y]> <nil Y>] λ x : X λ rec : [List Y] [[<cons Y> [f x]] rec]] : ∀ X : * ∀ Y : * Π f : Π _ : X Y Π l : [List X] [List Y].
let intersperse := Λ X : * λ x : X λ l : [List X] [[[<<recursionList X> [List X]> <nil X>] λ x' : X λ l' : [List X] λ rec : [List X] [[[<ifthenelse [List X]> [<isNil X> l']] [<pureList X> x']] [[<cons X> x'] [[<cons X> x] rec]]]] l] : ∀ X : * Π x : X Π l : [List X] [List X].