let replicate := Λ A : * λ a : A λ n : Nat [[<n [List A]> <nil A>] [<cons A> a]] : ∀ A : * Π a : A Π n : Nat [List A].
let showList := Λ X : * λ showX : Π _ : X String λ l : [List X] [[stringCons κ[] [[stringApp [stringConcat [[<intersperse String> [[stringCons κ,] [[stringCons κ ] stringNil]]] [[<<map X> String> showX] l]]]] [[stringCons κ]] stringNil]]] : ∀ X : * Π showX : Π _ : X String Π l : [List X] String.
let lookupDefault := Λ A : * λ n : Nat λ d : A λ l : [List A] [[[<l Π _ : Nat A> λ _ : Nat d] λ a : A λ rec : Π _ : Nat A [[<recursionNat A> a] λ k : Nat λ _ : A [rec k]]] n] : ∀ A : * Π n : Nat Π d : A Π l : [List A] A.
let head := Λ A : * λ l : [List A] [[<l [Maybe A]> <nothing A>] λ a : A λ _ : [Maybe A] [<just A> a]] : ∀ A : * Π l : [List A] [Maybe A].
let tail := Λ A : * λ l : [List A] [[[<<recursionList A> [List A]> <nil A>] λ a : A λ l' : [List A] λ _ : [List A] l'] l] : ∀ A : * Π l : [List A] [List A].
let findMaybe := Λ A : * λ P : Π _ : A Bool λ l : [List A] [<head A> [[<filter A> P] l]] : ∀ A : * Π P : Π _ : A Bool Π l : [List A] [Maybe A].
let exists := Λ A : * λ P : Π _ : A Bool λ l : [List A] [not [<isNil A> [[<filter A> P] l]]] : ∀ A : * Π P : Π _ : A Bool Π l : [List A] Bool.
let isMember := Λ A : * λ Aeq : Π _ : A Π _ : A Bool λ l : [List A] λ a : A [[<exists A> [Aeq a]] l] : ∀ A : * Π Aeq : Π _ : A Π _ : A Bool Π l : [List A] Π a : A Bool.
let maybeToList := Λ A : * [[<<maybe A> [List A]> <nil A>] λ a : A [[<cons A> a] <nil A>]] : ∀ A : * Π _ : [Maybe A] [List A].
let mapHead := Λ A : * λ f : Π _ : [Maybe A] [Maybe A] [[<<recursionList A> [List A]> [<maybeToList A> [f <nothing A>]]] λ a : A λ as : [List A] λ _ : [List A] [[<app A> [<maybeToList A> [f [<just A> a]]]] as]] : ∀ A : * Π f : Π _ : [Maybe A] [Maybe A] Π _ : [List A] [List A].
let initsNonEmpty := Λ A : * [[<<recursionList A> [List [[Product A] [List A]]]> <nil [[Product A] [List A]]>] λ a : A λ as : [List A] λ rec : [List [[Product A] [List A]]] [[<cons [[Product A] [List A]]> [[<<prodPair A> [List A]> a] as]] rec]] : ∀ A : * Π _ : [List A] [List [[Product A] [List A]]].
let tailsNonEmpty := Λ A : * λ l : [List A] [<reverse [[Product A] [List A]]> [<initsNonEmpty A> [<reverse A> l]]] : ∀ A : * Π l : [List A] [List [[Product A] [List A]]].
let countToZero := λ n : Nat [<<pr2 Nat> [List Nat]> [[<n [[Product Nat] [List Nat]]> [[<<prodPair Nat> [List Nat]> zero] [[<cons Nat> zero] <nil Nat>]]] [<<<recursionProduct Nat> [List Nat]> [[Product Nat] [List Nat]]> λ k : Nat λ x : [List Nat] [[<<prodPair Nat> [List Nat]> [suc k]] [[λ m : Nat λ rec : [List Nat] [[<cons Nat> [suc m]] rec] k] x]]]]] : Π _ : Nat [List Nat].
let countToZeroExc := λ n : Nat [<<pr2 Nat> [List Nat]> [[<n [[Product Nat] [List Nat]]> [[<<prodPair Nat> [List Nat]> zero] <nil Nat>]] [<<<recursionProduct Nat> [List Nat]> [[Product Nat] [List Nat]]> λ k : Nat λ x : [List Nat] [[<<prodPair Nat> [List Nat]> [suc k]] [[λ m : Nat λ rec : [List Nat] [[<cons Nat> m] rec] k] x]]]]] : Π _ : Nat [List Nat].
let zipWith := Λ A : * Λ B : * Λ C : * λ f : Π _ : A Π _ : B C λ l : [List A] λ l' : [List B] [[[<l Π _ : [List B] [List C]> λ _ : [List B] <nil C>] λ a : A λ rec : Π _ : [List B] [List C] [[<<recursionList B> [List C]> <nil C>] λ b : B λ bs : [List B] λ _ : [List C] [[<cons C> [[f a] b]] [rec bs]]]] l'] : ∀ A : * ∀ B : * ∀ C : * Π f : Π _ : A Π _ : B C Π l : [List A] Π l' : [List B] [List C].
let zip := Λ A : * Λ B : * [<<<zipWith A> B> [[Product A] B]> <<prodPair A> B>] : ∀ A : * ∀ B : * Π _ : [List A] Π _ : [List B] [List [[Product A] B]].
let zipWith3 := Λ A : * Λ B : * Λ C : * Λ D : * λ f : Π _ : A Π _ : B Π _ : C D λ l : [List A] λ l' : [List B] λ l'' : [List C] [[[<<<zipWith A> [[Product B] C]> D> λ a : A λ bc : [[Product B] C] [[[f a] [<<pr1 B> C> bc]] [<<pr2 B> C> bc]]] l] [[<<zip B> C> l'] l'']] : ∀ A : * ∀ B : * ∀ C : * ∀ D : * Π f : Π _ : A Π _ : B Π _ : C D Π l : [List A] Π l' : [List B] Π l'' : [List C] [List D].
let zip3 := Λ A : * Λ B : * Λ C : * [<<<<zipWith3 A> B> C> [[[TripleProduct A] B] C]> <<<mkTripleProduct A> B> C>] : ∀ A : * ∀ B : * ∀ C : * Π _ : [List A] Π _ : [List B] Π _ : [List C] [List [[Product A] [[Product B] C]]].
let zipWith4 := Λ A : * Λ B : * Λ C : * Λ D : * Λ E : * λ f : Π _ : A Π _ : B Π _ : C Π _ : D E λ l : [List A] λ l' : [List B] λ l'' : [List C] λ l''' : [List D] [[[<<<zipWith A> [[Product B] [[Product C] D]]> E> λ a : A λ bcd : [[Product B] [[Product C] D]] [[[[f a] [<<<pr31 B> C> D> bcd]] [<<<pr32 B> C> D> bcd]] [<<<pr33 B> C> D> bcd]]] l] [[[<<<zip3 B> C> D> l'] l''] l''']] : ∀ A : * ∀ B : * ∀ C : * ∀ D : * ∀ E : * Π f : Π _ : A Π _ : B Π _ : C Π _ : D E Π l : [List A] Π l' : [List B] Π l'' : [List C] Π l''' : [List D] [List E].
let concat := Λ A : * λ l : [List [List A]] [[<l [List A]> <nil A>] λ l' : [List A] λ rec : [List A] [[<app A> l'] rec]] : ∀ A : * Π l : [List [List A]] [List A].
let drop := Λ A : * λ n : Nat λ l : [List A] [[<n [List A]> l] <tail A>] : ∀ A : * Π n : Nat Π l : [List A] [List A].
let take := Λ A : * λ n : Nat λ l : [List A] [[[<<<zipWith A> Nat> A> λ a : A λ _ : Nat a] l] [countToZeroExc n]] : ∀ A : * Π n : Nat Π l : [List A] [List A].
let dropWhile := Λ A : * λ P : Π _ : A Bool λ l : [List A] [[[<<recursionList A> [List A]> <nil A>] λ a : A λ as : [List A] λ rec : [List A] [[[<ifthenelse [List A]> [P a]] rec] [[<cons A> a] as]]] l] : ∀ A : * Π P : Π _ : A Bool Π l : [List A] [List A].