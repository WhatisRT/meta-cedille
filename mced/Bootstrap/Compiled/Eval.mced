let EvalOpts := ∀ X : * Π _ : Π a : Bool Π _ : [λ _ : Bool [[Product Bool] String] a] X X : *.
let mkEvalOpts := λ a : Bool λ b : Bool λ c : String [[<<prodPair Bool> [[Product Bool] String]> a] [[<<prodPair Bool> String> b] c]] : Π _ : Bool Π _ : Bool Π _ : String EvalOpts.
let defaultFlags := Λ X : * λ p : Π a : Bool Π _ : [λ _ : Bool [[Product Bool] String] a] X [[p false] [[<<prodPair Bool> String> false] stringNil]] : EvalOpts.
let quoteEvalOpts := λ x : [[[TripleProduct Bool] Bool] String] [[<<<recursionProduct Bool> [[Product Bool] String]> Term> λ a : Bool λ bc : [[Product Bool] String] [[<<<recursionProduct Bool> String> Term> λ b : Bool λ c : String [[[λ annReq : Bool λ printInfo : Bool λ workingDir : String [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κE] [[stringCons κv] [[stringCons κa] [[stringCons κl] [[stringCons κO] [[stringCons κp] [[stringCons κt] [[stringCons κs] stringNil]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteBool annReq]]] [[<cons App> [[mkApp false] [quoteBool printInfo]]] [[<cons App> [[mkApp false] [quoteString workingDir]]] <nil App>]]]] a] b] c]] bc]] x] : Π _ : EvalOpts Term.
let getAnnReq := λ x : [[[TripleProduct Bool] Bool] String] [<<pr1 Bool> [[Product Bool] String]> x] : Π _ : EvalOpts Bool.
let setAnnReq := λ b : Bool [<<<productMap1 Bool> [[Product Bool] String]> Bool> λ _ : Bool b] : Π b : Bool Π _ : EvalOpts EvalOpts.
let getPrintInfo := λ x : [[[TripleProduct Bool] Bool] String] [<<pr1 Bool> String> [<<pr2 Bool> [[Product Bool] String]> x]] : Π _ : EvalOpts Bool.
let setPrintInfo := λ b : Bool [<<<productMap2 Bool> [[Product Bool] String]> [[Product Bool] String]> [<<<productMap1 Bool> String> Bool> λ _ : Bool b]] : Π b : Bool Π _ : EvalOpts EvalOpts.
let getWorkingDir := λ x : [[[TripleProduct Bool] Bool] String] [<<pr2 Bool> String> [<<pr2 Bool> [[Product Bool] String]> x]] : Π _ : EvalOpts String.
let setWorkingDir := λ dir : String [<<<productMap2 Bool> [[Product Bool] String]> [[Product Bool] String]> [<<<productMap2 Bool> String> String> λ _ : String dir]] : Π dir : String Π _ : EvalOpts EvalOpts.
let ModuleState := ∀ X : * Π _ : Π a : [List Module] Π _ : [λ _ : [List Module] ModuleDict a] X X : *.
let mkModuleState := λ m : [List Module] λ d : ModuleDict [[<<prodPair [List Module]> ModuleDict> m] d] : Π m : [List Module] Π d : ModuleDict ModuleState.
let ModuleStateModuleStack := λ s : ModuleState [<<pr1 [List Module]> ModuleDict> s] : Π s : ModuleState [List Module].
let ModuleStateDict := λ s : ModuleState [<<pr2 [List Module]> ModuleDict> s] : Π s : ModuleState ModuleDict.
let ModuleStateCurrentModule := λ s : ModuleState [<head Module> [ModuleStateModuleStack s]] : Π s : ModuleState [Maybe Module].
let emptyModState := Λ X : * λ p : Π a : [List Module] Π _ : [λ _ : [List Module] ModuleDict a] X [[p <nil Module>] emptyModuleDict] : ModuleState.
let quoteDict := λ d : ModuleDict [sVarTerm [mkModuleDictName d]] : Π d : ModuleDict Term.
let quoteModuleState := λ s : ModuleState [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] [[stringCons κS] [[stringCons κt] [[stringCons κa] [[stringCons κt] [[stringCons κe] stringNil]]]]]]]]]]]]]]] [[<cons App> [[mkApp false] [[[<quoteList Module> [[appLTerm [sVarTerm [[stringCons κM] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κl] [[stringCons κe] stringNil]]]]]]]] <nil App>]] λ m : Module [sVarTerm [mkTempModuleName m]]] [ModuleStateModuleStack s]]]] [[<cons App> [[mkApp false] [quoteDict [ModuleStateDict s]]]] <nil App>]]] : Π s : ModuleState Term.
let SourceLocation := ∀ X : * Π _ : Π a : String Π _ : [λ _ : String [[Product Nat] Nat] a] X X : *.
let mkSourceLocation := λ a : String λ b : Nat λ c : Nat [[<<prodPair String> [[Product Nat] Nat]> a] [[<<prodPair Nat> Nat> b] c]] : Π a : String Π b : Nat Π c : Nat [[[TripleProduct String] Nat] Nat].
let getFileName := λ x : [[[TripleProduct String] Nat] Nat] [<<pr1 String> [[Product Nat] Nat]> x] : Π x : [[[TripleProduct String] Nat] Nat] String.
let getLine := λ x : [[[TripleProduct String] Nat] Nat] [<<pr1 Nat> Nat> [<<pr2 String> [[Product Nat] Nat]> x]] : Π x : [[[TripleProduct String] Nat] Nat] Nat.
let getColumn := λ x : [[[TripleProduct String] Nat] Nat] [<<pr2 Nat> Nat> [<<pr2 String> [[Product Nat] Nat]> x]] : Π x : [[[TripleProduct String] Nat] Nat] Nat.
let quoteSourceLocation := λ l : SourceLocation [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κS] [[stringCons κo] [[stringCons κu] [[stringCons κr] [[stringCons κc] [[stringCons κe] [[stringCons κL] [[stringCons κo] [[stringCons κc] [[stringCons κa] [[stringCons κt] [[stringCons κi] [[stringCons κo] [[stringCons κn] stringNil]]]]]]]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteString [getFileName l]]]] [[<cons App> [[mkApp false] [quoteNat [getLine l]]]] [[<cons App> [[mkApp false] [quoteNat [getColumn l]]]] <nil App>]]]] : Π l : SourceLocation Term.
let TermInfo := ∀ X : * Π _ : Π a : SourceLocation Π _ : [λ _ : SourceLocation Term a] X X : *.
let mkTermInfo := λ a : SourceLocation λ b : Term [[<<pair SourceLocation> λ _ : SourceLocation Term> a] b] : Π a : SourceLocation Π b : Term [[Product SourceLocation] Term].
let getLocation := λ x : [[DSum SourceLocation] λ _ : SourceLocation Term] [<x SourceLocation> λ a : SourceLocation λ _ : Term a] : Π _ : TermInfo SourceLocation.
let getDefinition := λ x : [[DSum SourceLocation] λ _ : SourceLocation Term] [<x Term> λ _ : SourceLocation λ b : Term b] : Π _ : TermInfo Term.
let quoteTermInfo := λ i : TermInfo [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κT] [[stringCons κe] [[stringCons κr] [[stringCons κm] [[stringCons κI] [[stringCons κn] [[stringCons κf] [[stringCons κo] stringNil]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteSourceLocation [getLocation i]]]] [[<cons App> [[mkApp false] [quoteTerm [getDefinition i]]]] <nil App>]]] : Π i : TermInfo Term.
let TermInfoState := ∀ X : * Π _ : X Π _ : Π _ : [[Product String] TermInfo] Π _ : X X X : *.
let addTermInfo := λ n : String λ i : TermInfo [<cons [[Product String] TermInfo]> [[<<prodPair String> TermInfo> n] i]] : Π n : String Π i : TermInfo Π _ : TermInfoState TermInfoState.
let lookupTermInfo := λ st : TermInfoState λ n : String [[<<mapMaybe [[Product String] TermInfo]> TermInfo> <<pr2 String> TermInfo>] [[<findMaybe [[Product String] TermInfo]> λ p : [[Product String] TermInfo] [[stringEq [<<pr1 String> TermInfo> p]] n]] st]] : Π st : TermInfoState Π n : String [Maybe TermInfo].
let quoteTermInfoState := λ st : TermInfoState [[[<quoteList [[Product String] TermInfo]> [[appLTerm [sVarTerm [[stringCons κP] [[stringCons κr] [[stringCons κo] [[stringCons κd] [[stringCons κu] [[stringCons κc] [[stringCons κt] stringNil]]]]]]]]] [[<cons App> [[mkApp false] [[appLTerm [sVarTerm [[stringCons κS] [[stringCons κt] [[stringCons κr] [[stringCons κi] [[stringCons κn] [[stringCons κg] stringNil]]]]]]]] <nil App>]]] [[<cons App> [[mkApp false] [[appLTerm [sVarTerm [[stringCons κT] [[stringCons κe] [[stringCons κr] [[stringCons κm] [[stringCons κI] [[stringCons κn] [[stringCons κf] [[stringCons κo] stringNil]]]]]]]]]] <nil App>]]] <nil App>]]]] [[[[<<quoteProduct String> TermInfo> [[appLTerm [sVarTerm [[stringCons κS] [[stringCons κt] [[stringCons κr] [[stringCons κi] [[stringCons κn] [[stringCons κg] stringNil]]]]]]]] <nil App>]] [[appLTerm [sVarTerm [[stringCons κT] [[stringCons κe] [[stringCons κr] [[stringCons κm] [[stringCons κI] [[stringCons κn] [[stringCons κf] [[stringCons κo] stringNil]]]]]]]]]] <nil App>]] quoteString] quoteTermInfo]] st] : Π st : TermInfoState Term.
let emptyTermInfoState := Λ X : * λ n : X λ c : Π _ : [[Product String] TermInfo] Π _ : X X n : TermInfoState.
let OtherState := ∀ X : * Π _ : X Π _ : Π _ : X X X : *.
let quoteOtherState := λ s : OtherState [quoteNat s] : Π s : OtherState Term.
let emptyOtherState := Λ X : * λ z : X λ s : Π _ : X X z : Nat.
let EvalState := ∀ X : * Π _ : Π a : EvalOpts Π _ : [λ _ : EvalOpts [[Product ModuleState] [[Product TermInfoState] OtherState]] a] X X : *.
let mkEvalState := λ f : EvalOpts λ s : ModuleState λ i : TermInfoState λ o : OtherState [[[<<<mkTripleProduct EvalOpts> ModuleState> [[Product TermInfoState] OtherState]> f] s] [[<<prodPair TermInfoState> OtherState> i] o]] : Π f : EvalOpts Π s : ModuleState Π i : TermInfoState Π o : OtherState EvalState.
let getEvalOpts := λ x : [[[TripleProduct EvalOpts] ModuleState] [[Product TermInfoState] OtherState]] [<<pr1 EvalOpts> [[Product ModuleState] [[Product TermInfoState] OtherState]]> x] : Π x : [[[TripleProduct EvalOpts] ModuleState] [[Product TermInfoState] OtherState]] EvalOpts.
let getModuleState := λ x : [[[TripleProduct EvalOpts] ModuleState] [[Product TermInfoState] OtherState]] [<<pr1 ModuleState> [[Product TermInfoState] OtherState]> [<<pr2 EvalOpts> [[Product ModuleState] [[Product TermInfoState] OtherState]]> x]] : Π x : [[[TripleProduct EvalOpts] ModuleState] [[Product TermInfoState] OtherState]] ModuleState.
let getTermInfoState := λ s : EvalState [<<pr1 TermInfoState> OtherState> [<<<pr33 EvalOpts> ModuleState> [[Product TermInfoState] OtherState]> s]] : Π s : EvalState TermInfoState.
let getOtherState := λ s : EvalState [<<pr2 TermInfoState> OtherState> [<<<pr33 EvalOpts> ModuleState> [[Product TermInfoState] OtherState]> s]] : Π s : EvalState OtherState.
let quoteEvalState := λ s : EvalState [[appLTerm [sVarTerm [[stringCons κm] [[stringCons κk] [[stringCons κE] [[stringCons κv] [[stringCons κa] [[stringCons κl] [[stringCons κS] [[stringCons κt] [[stringCons κa] [[stringCons κt] [[stringCons κe] stringNil]]]]]]]]]]]]] [[<cons App> [[mkApp false] [quoteEvalOpts [getEvalOpts s]]]] [[<cons App> [[mkApp false] [quoteModuleState [getModuleState s]]]] [[<cons App> [[mkApp false] [quoteTermInfoState [getTermInfoState s]]]] [[<cons App> [[mkApp false] [quoteOtherState [getOtherState s]]]] <nil App>]]]]] : Π s : EvalState Term.
let emptyEvalState := Λ X : * λ p : Π a : EvalOpts Π _ : [λ _ : EvalOpts [[Product ModuleState] [[Product TermInfoState] OtherState]] a] X [[p defaultFlags] [[<<prodPair ModuleState> [[Product TermInfoState] OtherState]> emptyModState] [[<<prodPair TermInfoState> OtherState> emptyTermInfoState] emptyOtherState]]] : EvalState.
let modifyModuleInState := λ f : Π _ : [List Module] [List Module] λ s : EvalState [[[[mkEvalState [getEvalOpts s]] [[mkModuleState [f [ModuleStateModuleStack [getModuleState s]]]] [ModuleStateDict [getModuleState s]]]] [getTermInfoState s]] [getOtherState s]] : Π f : Π _ : [List Module] [List Module] Π s : EvalState EvalState.
let modifyModuleDictInState := λ f : Π _ : ModuleDict ModuleDict λ s : EvalState [[[[mkEvalState [getEvalOpts s]] [[mkModuleState [ModuleStateModuleStack [getModuleState s]]] [f [ModuleStateDict [getModuleState s]]]]] [getTermInfoState s]] [getOtherState s]] : Π f : Π _ : ModuleDict ModuleDict Π s : EvalState EvalState.
let incrementStateCounter := λ s : EvalState [[[[mkEvalState [getEvalOpts s]] [getModuleState s]] [getTermInfoState s]] [suc [getOtherState s]]] : Π s : EvalState EvalState.
let Context := ∀ X : * Π _ : X Π _ : Π _ : [[Product String] Term] Π _ : X X X : *.
let EvalEnv := ∀ X : * Π _ : X Π _ : Π _ : [[Product String] Term] Π _ : X X X : *.
let getContext := λ e : EvalEnv e : Π e : EvalEnv [List [[Product String] Term]].
let appendContext := λ ctx : Context λ e : EvalEnv [[<app [[Product String] Term]> e] ctx] : Π ctx : Context Π e : EvalEnv EvalEnv.
let initEvalEnv := λ s : EvalState <nil [[Product String] Term]> : Π s : EvalState EvalEnv.
let Eval := λ T : * Π _ : EvalEnv Π _ : EvalState [M [[Product T] EvalState]] : Π _ : * *.
let pureEval := Λ T : * λ t : T λ e : EvalEnv λ s : EvalState [<returnMeta [[Product T] EvalState]> [[<<prodPair T> EvalState> t] s]] : ∀ T : * Π t : T [Eval T].
let bindEval := Λ T : * Λ T' : * λ x : [Eval T] λ f : Π _ : T [Eval T'] λ e : EvalEnv λ s : EvalState [[<<bindMeta [[Product T] EvalState]> [[Product T'] EvalState]> [[x e] s]] [<<<recursionProduct T> EvalState> [M [[Product T'] EvalState]]> λ res1 : T λ res2 : EvalState [[[f res1] e] res2]]] : ∀ T : * ∀ T' : * Π x : [Eval T] Π f : Π _ : T [Eval T'] [Eval T'].
let joinEval := Λ T : * λ t : [Eval [Eval T]] [[<<bindEval [Eval T]> T> t] λ t' : [Eval T] t'] : ∀ T : * Π t : [Eval [Eval T]] [Eval T].
let mapEval := Λ T : * Λ T' : * λ f : Π _ : T T' λ t : [Eval T] [[<<bindEval T> T'> t] λ x : T [<pureEval T'> [f x]]] : ∀ T : * ∀ T' : * Π f : Π _ : T T' Π t : [Eval T] [Eval T'].
let seqEval := Λ T : * Λ T' : * λ t : [Eval T] λ t' : [Eval T'] [[<<bindEval T> T'> t] λ _ : T t'] : ∀ T : * ∀ T' : * Π t : [Eval T] Π t' : [Eval T'] [Eval T'].
let sequenceEval := Λ T : * λ l : [List [Eval T]] [[<l [Eval [List T]]> [<pureEval [List T]> <nil T>]] λ x : [Eval T] λ rec : [Eval [List T]] [[<<bindEval T> [List T]> x] λ x' : T [[<<mapEval [List T]> [List T]> [<cons T> x']] rec]]] : ∀ T : * Π l : [List [Eval T]] [Eval [List T]].
let traverseEval := Λ A : * Λ B : * λ f : Π _ : A [Eval B] λ l : [List A] [<sequenceEval B> [[<<map A> [Eval B]> f] l]] : ∀ A : * ∀ B : * Π f : Π _ : A [Eval B] Π l : [List A] [Eval [List B]].
let voidEval := Λ T : * λ x : [Eval T] [[<<seqEval T> Unit> x] [<pureEval Unit> tt]] : ∀ T : * Π x : [Eval T] [Eval Unit].
let liftMtoEval := Λ T : * λ t : [M T] λ _ : EvalEnv λ s : EvalState [[<<bindMeta T> [[Product T] EvalState]> t] λ x : T [<returnMeta [[Product T] EvalState]> [[<<prodPair T> EvalState> x] s]]] : ∀ T : * Π t : [M T] [Eval T].
let getEval := λ _ : EvalEnv λ s : EvalState [<returnMeta [[Product EvalState] EvalState]> [[<<prodPair EvalState> EvalState> s] s]] : [Eval EvalState].
let setEval := λ s : EvalState λ _ : EvalEnv λ _ : EvalState [<returnMeta [[Product Unit] EvalState]> [[<<prodPair Unit> EvalState> tt] s]] : Π s : EvalState [Eval Unit].
let modifyEval := λ f : Π _ : EvalState EvalState [[<<bindEval EvalState> Unit> getEval] λ s : EvalState [setEval [f s]]] : Π f : Π _ : EvalState EvalState [Eval Unit].
let getModuleState' := λ e : EvalEnv λ s : EvalState [[<<bindMeta [[Product EvalState] EvalState]> [[Product ModuleState] EvalState]> [[getEval e] s]] [<<<recursionProduct EvalState> EvalState> [M [[Product ModuleState] EvalState]]> λ res1 : EvalState λ res2 : EvalState [[[λ x : EvalState [<pureEval ModuleState> [getModuleState x]] res1] e] res2]]] : [Eval ModuleState].
let modifyModuleState := λ f : Π _ : ModuleState ModuleState [modifyEval λ s : EvalState [[[[mkEvalState [getEvalOpts s]] [f [getModuleState s]]] [getTermInfoState s]] [getOtherState s]]] : Π f : Π _ : ModuleState ModuleState [Eval Unit].
let setModuleState := λ s : ModuleState [[<<bindEval EvalState> Unit> getEval] λ s' : EvalState [setEval [[[[mkEvalState [getEvalOpts s']] s] [getTermInfoState s']] [getOtherState s']]]] : Π s : ModuleState [Eval Unit].
let getEvalOpts' := λ e : EvalEnv λ s : EvalState [[<<bindMeta [[Product EvalState] EvalState]> [[Product EvalOpts] EvalState]> [[getEval e] s]] [<<<recursionProduct EvalState> EvalState> [M [[Product EvalOpts] EvalState]]> λ res1 : EvalState λ res2 : EvalState [[[λ x : EvalState [<pureEval EvalOpts> [getEvalOpts x]] res1] e] res2]]] : [Eval EvalOpts].
let modifyEvalOpts := λ f : Π _ : EvalOpts EvalOpts [modifyEval λ s : EvalState [[[[mkEvalState [f [getEvalOpts s]]] [getModuleState s]] [getTermInfoState s]] [getOtherState s]]] : Π f : Π _ : EvalOpts EvalOpts [Eval Unit].
let modifyOtherState := λ f : Π _ : OtherState OtherState [modifyEval λ s : EvalState [[[[mkEvalState [getEvalOpts s]] [getModuleState s]] [getTermInfoState s]] [f [getOtherState s]]]] : Π f : Π _ : OtherState OtherState [Eval Unit].
let askEval := λ e : EvalEnv λ s : EvalState [<returnMeta [[Product EvalEnv] EvalState]> [[<<prodPair EvalEnv> EvalState> e] s]] : [Eval EvalEnv].
let readerEval := Λ T : * λ p : Π _ : EvalEnv T [[<<mapEval EvalEnv> T> p] askEval] : ∀ T : * Π p : Π _ : EvalEnv T [Eval T].
let localEval := Λ T : * λ f : Π _ : EvalEnv EvalEnv λ x : [Eval T] λ e : EvalEnv [x [f e]] : ∀ T : * Π f : Π _ : EvalEnv EvalEnv Π x : [Eval T] [Eval T].
let askContext := λ e : EvalEnv λ s : EvalState [[<<bindMeta [[Product EvalEnv] EvalState]> [[Product Context] EvalState]> [[askEval e] s]] [<<<recursionProduct EvalEnv> EvalState> [M [[Product Context] EvalState]]> λ res1 : EvalEnv λ res2 : EvalState [[[λ x : EvalEnv [<pureEval Context> [getContext x]] res1] e] res2]]] : [Eval Context].
let inContext := Λ T : * λ ctx : Context [<localEval T> [appendContext ctx]] : ∀ T : * Π ctx : Context Π _ : [Eval T] [Eval T].
let let := λ n : String λ t : Term [<liftMtoEval Unit> [[primLet n] [TermToInitTerm t]]] : Π n : String Π t : Term [Eval Unit].
let annLet := λ n : String λ t : Term λ T : Term [<liftMtoEval Unit> [[[primAnnLet n] [TermToInitTerm t]] [TermToInitTerm T]]] : Π n : String Π t : Term Π T : Term [Eval Unit].
let setMEnv := λ eval : Term λ NT : String λ ns : String [<liftMtoEval Unit> [[[primSetEval [TermToInitTerm eval]] NT] ns]] : Π eval : Term Π NT : String Π ns : String [Eval Unit].
let shellCmd := λ cmd : String λ args : [List String] [<liftMtoEval String> [[primShellCmd cmd] args]] : Π cmd : String Π args : [List String] [Eval String].
let checkTerm := λ T : * λ t : Term [<liftMtoEval T> [[primCheckTerm T] [TermToInitTerm t]]] : Π T : * Π t : Term [Eval T].
let parse := λ nt : String λ T : * λ text : String [<liftMtoEval [[Product T] String]> [[[primParse nt] T] text]] : Π nt : String Π T : * Π text : String [Eval [[Product T] String]].
let normalize := λ t : Term [<liftMtoEval Term> [[<<mapMeta iTerm> Term> initTermToTerm] [primNormalize [TermToInitTerm t]]]] : Π t : Term [Eval Term].
let headNormalize := λ t : Term [<liftMtoEval Term> [[<<mapMeta iTerm> Term> initTermToTerm] [primHeadNormalize [TermToInitTerm t]]]] : Π t : Term [Eval Term].
let inferTypeBasic := λ t : Term [<liftMtoEval Term> [[<<mapMeta iTerm> Term> initTermToTerm] [primInferType [TermToInitTerm t]]]] : Π t : Term [Eval Term].
let getEval' := λ _ : EvalEnv λ s : EvalState [[<<bindMeta Term> [[Product Term] EvalState]> [[<<mapMeta iTerm> Term> initTermToTerm] primGetEval]] λ x : Term [<returnMeta [[Product Term] EvalState]> [[<<prodPair Term> EvalState> x] s]]] : [Eval Term].
let printEval := λ s : String [<liftMtoEval Unit> [primPrint s]] : Π s : String [Eval Unit].
let writeFile := λ fName : String λ s : String [<liftMtoEval Unit> [[primWriteFile fName] s]] : Π fName : String Π s : String [Eval Unit].
let commandLine := λ _ : EvalEnv λ s : EvalState [[<<bindMeta [List String]> [[Product [List String]] EvalState]> primCommandLine] λ x : [List String] [<returnMeta [[Product [List String]] EvalState]> [[<<prodPair [List String]> EvalState> x] s]]] : [Eval [List String]].
let toggleProf := λ _ : EvalEnv λ s : EvalState [[<<bindMeta Unit> [[Product Unit] EvalState]> primToggleProf] λ x : Unit [<returnMeta [[Product Unit] EvalState]> [[<<prodPair Unit> EvalState> x] s]]] : [Eval Unit].
let printLineEval := λ s : String [printEval [[stringApp s] newline]] : Π s : String [Eval Unit].
let printConcatEval := λ s : [List String] [printEval [stringConcat s]] : Π s : [List String] [Eval Unit].
let getDef := λ n : String [headNormalize [sVarTerm n]] : Π n : String [Eval Term].
let emptyStmt := λ e : EvalEnv λ s : EvalState [<returnMeta [[Product Unit] EvalState]> [[<<prodPair Unit> EvalState> tt] s]] : [Eval Unit].
let seqNewStmt := λ s : [Eval Unit] λ s' : [Eval Unit] [[<<seqEval Unit> Unit> s] s'] : Π s : [Eval Unit] Π s' : [Eval Unit] [Eval Unit].
let seqNewStmts := λ l : [List [Eval Unit]] [[[<<foldl [Eval Unit]> [Eval Unit]> seqNewStmt] [<reverse [Eval Unit]> l]] emptyStmt] : Π l : [List [Eval Unit]] [Eval Unit].
let stmtToNewStmt := λ stmt : [M Unit] [<liftMtoEval Unit> stmt] : Π stmt : [M Unit] [Eval Unit].
let updateMEnv := λ e : EvalEnv λ s : EvalState [[<<bindMeta [[Product EvalState] EvalState]> [[Product Unit] EvalState]> [[getEval e] s]] [<<<recursionProduct EvalState> EvalState> [M [[Product Unit] EvalState]]> λ res1 : EvalState λ res2 : EvalState [[[λ s : EvalState [[[setMEnv [[appSingle [[appLTerm [sVarTerm [[stringCons κe] [[stringCons κv] [[stringCons κa] [[stringCons κl] [[stringCons κN] [[stringCons κe] [[stringCons κw] [[stringCons κS] [[stringCons κt] [[stringCons κm] [[stringCons κt] stringNil]]]]]]]]]]]]] <nil App>]] [quoteEvalState s]]] [[stringCons κi] [[stringCons κn] [[stringCons κi] [[stringCons κt] stringNil]]]]] [[stringCons κn] [[stringCons κe] [[stringCons κw] [[stringCons κS] [[stringCons κt] [[stringCons κm] [[stringCons κt] stringNil]]]]]]]] res1] e] res2]]] : [Eval Unit].
let readFile := λ filename : String [[shellCmd [[stringCons κc] [[stringCons κa] [[stringCons κt] stringNil]]]] [[<cons String> filename] <nil String>]] : Π filename : String [Eval String].
let getPWD := λ _ : EvalEnv λ s : EvalState [[<<bindMeta String> [[Product String] EvalState]> [[primShellCmd [[stringCons κp] [[stringCons κw] [[stringCons κd] stringNil]]]] <nil String>]] λ x : String [<returnMeta [[Product String] EvalState]> [[<<prodPair String> EvalState> x] s]]] : [Eval String].
let catchEval := Λ T : * λ x : [Eval T] λ f : Π _ : String [Eval T] λ e : EvalEnv λ s : EvalState [[<catchErr [[Product T] EvalState]> [[x e] s]] λ res : String [[[f res] e] s]] : ∀ T : * Π x : [Eval T] Π f : Π _ : String [Eval T] [Eval T].
let throwEval := Λ T : * λ s : String [[<<seqEval Unit> T> [printEval s]] [[checkTerm T] [[appLTerm quoteSq] <nil App>]]] : ∀ T : * Π s : String [Eval T].
let showTermE := λ t : Term [[<<mapEval Context> String> λ ctx : Context [[showTermWithContext t] [<reverse String> [[<<map [[Product String] Term]> String> <<pr1 String> Term>] ctx]]]] askContext] : Π t : Term [Eval String].
let letInfoToNewStmt := λ i : LetInfo [[<<bindEval EvalOpts> Unit> getEvalOpts'] λ f : EvalOpts [[[<ifthenelse [Eval Unit]> [[or [not [getAnnReq f]]] [letInfoHasAnn i]]] [stmtToNewStmt [convertLetInfo i]]] [<throwEval Unit> [[stringCons κT] [[stringCons κh] [[stringCons κe] [[stringCons κ ] [[stringCons κp] [[stringCons κr] [[stringCons κo] [[stringCons κv] [[stringCons κi] [[stringCons κd] [[stringCons κe] [[stringCons κd] [[stringCons κ ] [[stringCons κc] [[stringCons κo] [[stringCons κm] [[stringCons κm] [[stringCons κa] [[stringCons κn] [[stringCons κd] [[stringCons κ ] [[stringCons κh] [[stringCons κa] [[stringCons κs] [[stringCons κ ] [[stringCons κn] [[stringCons κo] [[stringCons κ ] [[stringCons κt] [[stringCons κy] [[stringCons κp] [[stringCons κe] [[stringCons κ ] [[stringCons κa] [[stringCons κn] [[stringCons κn] [[stringCons κo] [[stringCons κt] [[stringCons κa] [[stringCons κt] [[stringCons κi] [[stringCons κo] [[stringCons κn] [[stringCons κ!] stringNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] : Π i : LetInfo [Eval Unit].
let ElabLet := Π _ : LetInfo [Eval LetInfo] : *.
let runEvalLets' := λ l : [List ElabLet] [<<pr2 [List ElabLet]> Π i : LetInfo [Eval LetInfo]> [[<l [[Product [List ElabLet]] Π i : LetInfo [Eval LetInfo]]> [[<<prodPair [List ElabLet]> Π i : LetInfo [Eval LetInfo]> <nil ElabLet>] <pureEval LetInfo>]] λ a : ElabLet [<<<recursionProduct [List ElabLet]> Π i : LetInfo [Eval LetInfo]> [[Product [List ElabLet]] Π i : LetInfo [Eval LetInfo]]> λ as : [List ElabLet] λ x : Π i : LetInfo [Eval LetInfo] [[<<prodPair [List ElabLet]> Π i : LetInfo [Eval LetInfo]> [[<cons ElabLet> a] as]] [[[λ el : ElabLet λ _ : [List ElabLet] λ rec : ElabLet λ i : LetInfo [[<<bindEval LetInfo> LetInfo> [el i]] rec] a] as] x]]]]] : Π _ : [List ElabLet] ElabLet.
let runEvalLets := λ els : [List ElabLet] λ i : LetInfo [[<<bindEval LetInfo> Unit> [[runEvalLets' els] i]] letInfoToNewStmt] : Π els : [List ElabLet] Π i : LetInfo [Eval Unit].
let liftElabLet := λ x : Π _ : LetInfo [Eval Unit] λ i : LetInfo [[<<seqEval Unit> LetInfo> [x i]] [<pureEval LetInfo> i]] : Π x : Π _ : LetInfo [Eval Unit] ElabLet.
let checkTypeAnn := λ i : LetInfo [[<<seqEval Unit> LetInfo> [λ i : LetInfo [[<<bindEval EvalState> Unit> getEval] λ s : EvalState [[[<ifthenelse [Eval Unit]> [[or [not [getAnnReq [getEvalOpts s]]]] [letInfoHasAnn i]]] [<pureEval Unit> tt]] [<throwEval Unit> [[stringCons κT] [[stringCons κh] [[stringCons κe] [[stringCons κ ] [[stringCons κp] [[stringCons κr] [[stringCons κo] [[stringCons κv] [[stringCons κi] [[stringCons κd] [[stringCons κe] [[stringCons κd] [[stringCons κ ] [[stringCons κc] [[stringCons κo] [[stringCons κm] [[stringCons κm] [[stringCons κa] [[stringCons κn] [[stringCons κd] [[stringCons κ ] [[stringCons κh] [[stringCons κa] [[stringCons κs] [[stringCons κ ] [[stringCons κn] [[stringCons κo] [[stringCons κ ] [[stringCons κt] [[stringCons κy] [[stringCons κp] [[stringCons κe] [[stringCons κ ] [[stringCons κa] [[stringCons κn] [[stringCons κn] [[stringCons κo] [[stringCons κt] [[stringCons κa] [[stringCons κt] [[stringCons κi] [[stringCons κo] [[stringCons κn] [[stringCons κ!] stringNil]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]] i]] [<pureEval LetInfo> i]] : ElabLet.
let Evaluator := Π _ : [Eval Unit] [M [[Product Unit] EvalState]] : *.
let import := λ filename : String [[<<bindEval String> Unit> [[<<mapEval EvalOpts> String> getWorkingDir] getEvalOpts']] λ workingDir : String [[seqNewStmt [<liftMtoEval Unit> [primImport [stringConcat [[<cons String> workingDir] [[<cons String> filename] <nil String>]]]]]] [[<<bindEval Evaluator> Unit> [[<<bindEval Term> Evaluator> getEval'] [checkTerm Evaluator]]] λ ev : Evaluator [[<<bindEval EvalState> Unit> [<liftMtoEval EvalState> [[<<mapMeta [[Product Unit] EvalState]> EvalState> <<pr2 Unit> EvalState>] [ev emptyStmt]]]] setEval]]]] : Π filename : String [Eval Unit].
let inferType := λ t : Term [[<<bindEval Context> Term> askContext] λ ctx : Context [[<<bindEval Term> Term> [inferTypeBasic [[[applyMultiBinder lambdaBinder] ctx] t]]] λ T : Term [[[<<maybe Term> [Eval Term]> [<throwEval Term> [[stringCons κi] [[stringCons κn] [[stringCons κf] [[stringCons κe] [[stringCons κr] [[stringCons κT] [[stringCons κy] [[stringCons κp] [[stringCons κe] [[stringCons κ'] [[stringCons κ:] [[stringCons κ ] [[stringCons κB] [[stringCons κU] [[stringCons κG] [[stringCons κ!] stringNil]]]]]]]]]]]]]]]]]] <pureEval Term>] [[stripPis [<length [[Product String] Term]> ctx]] T]]]] : Π t : Term [Eval Term].
let runEval := Λ T : * λ eval : [Eval T] λ s : EvalState [[[[<<bindEval T> T> eval] λ t : T [[<<seqEval Unit> T> updateMEnv] [<pureEval T> t]]] [initEvalEnv s]] s] : ∀ T : * Π eval : [Eval T] Π s : EvalState [M [[Product T] EvalState]].
let evalNewStmt := λ s : EvalState λ stmt : [Eval Unit] [[<runEval Unit> stmt] s] : Π s : EvalState Π stmt : [Eval Unit] [M [[Product Unit] EvalState]].