--------------------------------------------------------------------------------
-- Term recursion
--
-- Term recursion is defined after having b-let for more convenient syntax
--------------------------------------------------------------------------------

b-let mapAppList [X, Y : *] (f : X -> Y) (l : List (Product Bool X)) : List (Product Bool Y) :=
  map ?(Product Bool X) ?(Product Bool Y)
    (λ bx : Product Bool X. prodPair ?Bool ?Y (pr1 ?Bool ?X bx) (f (pr2 ?Bool ?X bx))) l.

b-let recursionTerm [X : *]
  (fvar  : Var -> X)
  (fsort : Sort -> X)
  (fbind : Binder -> String -> Term -> Term -> X -> X -> X)
  (fapp  : Term -> List App -> X -> List (Product Bool X) -> X)
  (fchar : Char -> X)
  (funk  : X)
  (funq  : Term -> X -> X)
  (term  : Term) : X :=
  pr1 ?X ?Term (term ?(Product X Term)
    (λ v : Var. prodPair ?X ?Term (fvar v) (varTerm v))
    (λ s : Sort. prodPair ?X ?Term (fsort s) (sortTerm s))
    (λ b : Binder. λ n : String. λ T : Product X Term. λ t : Product X Term.
      prodPair ?X ?Term
        (fbind b n (pr2 ?X ?Term T) (pr2 ?X ?Term t) (pr1 ?X ?Term T) (pr1 ?X ?Term t))
        (binderTerm b n (pr2 ?X ?Term T) (pr2 ?X ?Term t)))
    (λ t : Product X Term. λ l : List (Product Bool (Product X Term)).
      prodPair ?X ?Term
        (fapp (pr2 ?X ?Term t) (mapAppList ?(Product X Term) ?Term (pr2 ?X ?Term) l)
              (pr1 ?X ?Term t) (mapAppList ?(Product X Term) ?X (pr1 ?X ?Term) l))
        (appLTerm (pr2 ?X ?Term t) (mapAppList ?(Product X Term) ?Term (pr2 ?X ?Term) l)))
    (λ c : Char. prodPair ?X ?Term (fchar c) (charTerm c))
    (prodPair ?X ?Term funk unknownTerm)
    (λ u : Product X Term.
      prodPair ?X ?Term (funq (pr2 ?X ?Term u) (pr1 ?X ?Term u)) (unquoteTerm (pr2 ?X ?Term u)))).

b-let matchTerm [X : *]
  (fvar  : Var -> X)
  (fsort : Sort -> X)
  (fbind : Binder -> String -> Term -> Term -> X)
  (fapp  : Term -> List App -> X)
  (fchar : Char -> X)
  (funk  : X)
  (funq  : Term -> X) : Term -> X :=
  recursionTerm ?X
    fvar fsort
    (λ b : Binder. λ n : String. λ T, t : Term. λ _, _ : X. fbind b n T t)
    (λ t : Term. λ app : List App. λ _ : X. λ _ : List (Product Bool X). fapp t app)
    fchar funk
    (λ t : Term. λ _ : X. funq t).

b-let stripLambda : Term -> Maybe Term :=
  matchTerm ?(Maybe Term)
    (λ _ : Var. nothing ?Term)
    (λ _ : Sort. nothing ?Term)
    (λ b : Binder. λ _ : String. λ T, t : Term.
      b ?(Maybe Term) (just ?Term t) (just ?Term t) (nothing ?Term) (nothing ?Term))
    (λ _ : Term. λ _ : List App. nothing ?Term)
    (λ _ : Char. nothing ?Term)
    (nothing ?Term)
    (λ _ : Term. nothing ?Term).

b-let stripLambdas : Nat -> Term -> Maybe Term :=
  recursionNat ?(Term -> Maybe Term)
    (just ?Term)
    (λ _ : Nat. λ rec : Term -> Maybe Term. λ t : Term. bindMaybe ?Term ?Term (stripLambda t) rec).

b-let stripPi : Term -> Maybe Term :=
  matchTerm ?(Maybe Term)
    (λ _ : Var. nothing ?Term)
    (λ _ : Sort. nothing ?Term)
    (λ b : Binder. λ _ : String. λ T, t : Term.
      b ?(Maybe Term) (nothing ?Term) (nothing ?Term) (just ?Term t) (nothing ?Term))
    (λ _ : Term. λ _ : List App. nothing ?Term)
    (λ _ : Char. nothing ?Term)
    (nothing ?Term)
    (λ _ : Term. nothing ?Term).

b-let stripPis : Nat -> Term -> Maybe Term :=
  recursionNat ?(Term -> Maybe Term)
    (just ?Term)
    (λ _ : Nat. λ rec : Term -> Maybe Term. λ t : Term. bindMaybe ?Term ?Term (stripPi t) rec).

b-let matchVar [X : *] (def : X) (f : Var -> X) (t : Term) : X :=
  matchTerm ?X
    f
    (λ _ : Sort. def)
    (λ _ : Binder. λ _ : String. λ _, _ : Term. def)
    (λ _ : Term. λ _ : List App. def)
    (λ _ : Char. def)
    def
    (λ _ : Term. def)
    t.

b-let matchApp [X : *] (def : X) (f : Term -> List App -> X) (t : Term) : X :=
  matchTerm ?X
    (λ _ : Var. def)
    (λ _ : Sort. def)
    (λ _ : Binder. λ _ : String. λ _, _ : Term. def)
    f
    (λ _ : Char. def)
    def
    (λ _ : Term. def)
    t.
