--------------------------------------------------------------------------------
-- Term recursion
--
-- Term recursion is defined after having b-let for more convenient syntax
--------------------------------------------------------------------------------

b-let mapAppList [X, Y : *] (f : X -> Y) (l : List (Product Bool X)) : List (Product Bool Y) :=
  map ?(Product Bool X) ?(Product Bool Y)
    (recursionProduct ?Bool ?X ?(Product Bool Y) λ b : Bool. λ x : X. prodPair ?Bool ?Y b (f x)) l.

b-let distList [X, Y, Z : *]
  : List (TripleProduct X Y Z) -> Product (List (Product X Y)) (List (Product X Z)) :=
  recursionList' ?(TripleProduct X Y Z) ?(Product (List (Product X Y)) (List (Product X Z)))
    (prodPair ?(List (Product X Y)) ?(List (Product X Z)) (nil ?(Product X Y)) (nil ?(Product X Z)))
    (recursionTripleProduct ?X ?Y ?Z
      ?(Product (List (Product X Y)) (List (Product X Z))
        -> Product (List (Product X Y)) (List (Product X Z)))
      λ x : X. λ y : Y. λ z : Z.
        recursionProduct ?(List (Product X Y)) ?(List (Product X Z))
                         ?(Product (List (Product X Y)) (List (Product X Z)))
          λ l : List (Product X Y). λ r : List (Product X Z).
            prodPair ?(List (Product X Y)) ?(List (Product X Z))
                     (cons ?(Product X Y) (prodPair ?X ?Y x y) l)
                     (cons ?(Product X Z) (prodPair ?X ?Z x z) r)).

b-let stripLambda : Term -> Maybe Term :=
  matchTerm ?(Maybe Term)
    (λ _ : Var. nothing ?Term)
    (λ _ : Sort. nothing ?Term)
    (λ b : Binder. λ _ : String. λ T, t : Term.
      matchBinder ?(Maybe Term) (just ?Term t) (just ?Term t) (nothing ?Term) (nothing ?Term) b)
    (λ _ : Term. λ _ : List App. nothing ?Term)
    (λ _ : Char. nothing ?Term)
    (nothing ?Term)
    (λ _ : Term. nothing ?Term).

b-let stripLambdas (n : Nat) : Term -> Maybe Term :=
  n ?(Term -> Maybe Term)
    (just ?Term)
    (λ rec : Term -> Maybe Term. λ t : Term. bindMaybe ?Term ?Term (stripLambda t) rec).

b-let stripPi : Term -> Maybe Term :=
  matchTerm ?(Maybe Term)
    (λ _ : Var. nothing ?Term)
    (λ _ : Sort. nothing ?Term)
    (λ b : Binder. λ _ : String. λ T, t : Term.
      matchBinder ?(Maybe Term) (nothing ?Term) (nothing ?Term) (just ?Term t) (nothing ?Term) b)
    (λ _ : Term. λ _ : List App. nothing ?Term)
    (λ _ : Char. nothing ?Term)
    (nothing ?Term)
    (λ _ : Term. nothing ?Term).

b-let stripPis (n : Nat) : Term -> Maybe Term :=
  n ?(Term -> Maybe Term)
    (just ?Term)
    (λ rec : Term -> Maybe Term. λ t : Term. bindMaybe ?Term ?Term (stripPi t) rec).

b-let matchVar [X : *] (def : X) (f : Var -> X) (t : Term) : X :=
  matchTerm ?X
    f
    (λ _ : Sort. def)
    (λ _ : Binder. λ _ : String. λ _, _ : Term. def)
    (λ _ : Term. λ _ : List App. def)
    (λ _ : Char. def)
    def
    (λ _ : Term. def)
    t.

b-let matchApp [X : *] (def : X) (f : Term -> List App -> X) (t : Term) : X :=
  matchTerm ?X
    (λ _ : Var. def)
    (λ _ : Sort. def)
    (λ _ : Binder. λ _ : String. λ _, _ : Term. def)
    f
    (λ _ : Char. def)
    def
    (λ _ : Term. def)
    t.
