b-let genEscapeCode (s : String) : String := Ï†"[${s}m".
b-let resetCode : String := genEscapeCode "0".

--------------------------------------------------------------------------------
-- Functional
--------------------------------------------------------------------------------

b-let backspaceCode := "".

b-let undoPrint (s : String) : String :=
  stringConcat (replicate ?String backspaceCode (stringLength s)).

b-let evalWithProgress [T : *] (progress, done : String) (x : Eval T) :=
  seqEval ?Unit ?T (printEval progress)
    (bindEval ?T ?T x (Î» x' : T.
      seqEval ?Unit ?T
              (seqEval ?Unit ?Unit (printEval (undoPrint progress)) (printEval done))
              (pureEval ?T x'))).

--------------------------------------------------------------------------------
-- Functions for printing to the terminal
--------------------------------------------------------------------------------

b-let ANSI8Color : * := âˆ€ X : *. X -> X -> X -> X -> X -> X -> X -> X -> X.

b-let ANSI8Black   := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. black.
b-let ANSI8Red     := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. red.
b-let ANSI8Green   := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. green.
b-let ANSI8Yellow  := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. yellow.
b-let ANSI8Blue    := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. blue.
b-let ANSI8Magenta := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. magenta.
b-let ANSI8Cyan    := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. cyan.
b-let ANSI8White   := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. white.

b-let toColorCode8 (c : ANSI8Color) : String :=
  genEscapeCode (c ?String "30" "31" "32" "33" "34" "35" "36" "37").

b-let toBrightColorCode8 (c : ANSI8Color) : String :=
  genEscapeCode Ï†"${c ?String "30" "31" "32" "33" "34" "35" "36" "37"};1".

b-let toBGColorCode8 (c : ANSI8Color) : String :=
  genEscapeCode (c ?String "40" "41" "42" "43" "44" "45" "46" "47").

b-let withColor8 (c : ANSI8Color) (s : String) : String :=
  stringConcat [String|toBrightColorCode8 c, s, resetCode].

b-let withColors8 (fg, bg : ANSI8Color) (s : String) : String :=
  stringConcat [String|toColorCode8 fg, toBGColorCode8 bg, s, resetCode].

b-let toColorCode256 (c : Byte) : String := genEscapeCode Ï†"38;5;${showByte c}".

b-let toBGColorCode256 (c : Byte) : String := genEscapeCode Ï†"48;5;${showByte c}".

b-let withColor256 (c : Byte) (s : String) : String :=
  stringConcat [String|toColorCode256 c, s, resetCode].

b-let withColors256 (fg, bg : Byte) (s : String) : String :=
  stringConcat [String|toColorCode256 fg, toBGColorCode256 bg, s, resetCode].

--------------------------------------------------------------------------------
-- Verbosity
--------------------------------------------------------------------------------

b-let LogType : * := âˆ€ X : *. X -> X -> X -> X -> X.

b-let LogTypeDebug := Î› X : *. Î» debug, info, warn, error : X. debug.
b-let LogTypeInfo  := Î› X : *. Î» debug, info, warn, error : X. info.
b-let LogTypeWarn  := Î› X : *. Î» debug, info, warn, error : X. warn.
b-let LogTypeError := Î› X : *. Î» debug, info, warn, error : X. error.

b-let currentLogType : Eval LogType := pureEval ?LogType LogTypeDebug.

b-let doPrintLogType (t : LogType) : Eval Bool :=
  t ?(Eval Bool) (pureEval ?Bool true)
                 (mapEval ?EvalState ?Bool (Î» s : EvalState. getPrintInfo (getEvalOpts s)) getEval)
                 (pureEval ?Bool true)
                 (pureEval ?Bool true).

b-let debugPrint (t : LogType) (level : Nat) (m : String) : Eval Unit :=
  bindEval ?Bool ?Unit (doPrintLogType t)
    (Î» b : Bool. ifthenelse ?(Eval Unit) b
      (printLineEval m)
      (pureEval ?Unit tt)).

b-let showLetInfo (i : LetInfo) : String :=
  Ï†"${letInfoName i} := ${showTerm (letInfoTerm i)}${
      maybe ?Term ?String "" (Î» T : Term. Ï†" : ${showTerm T}") (letInfoType i)}\n".

b-let debugPrintLetInfo : ElabLet := Î» i : LetInfo.
  seqEval ?Unit ?LetInfo (debugPrint LogTypeInfo zero Ï†"Defined: ${showLetInfo i}")
                         (pureEval ?LetInfo i).
