let Name := String.

elet var (n : Name) : Term := sVarTerm n.

let castIota [A : *] [P : A -> *] : Cast (Iota A P) A :=
  intrCast ?(Iota A P) ?A ?(iPr1 ?A ?P) ?(beta ?(Iota A P)).

elet mkNames (n : Name) (k : Nat) : List Name :=
  map ?_ ?_ (λ i : Nat. φ"${n}${showNatDecimal i}") (upTo k).

elet appNames (erased : Bool) (ns : List Name) : List App :=
  map ?_ ?_ (λ n : Name. erased, var n) ns.

elet appNsU (t : Term) (ns : List Name) :=
  appLTerm t $ map ?_ ?_ (λ n : Name. mkAppU $ sVarTerm n) ns.

elet defineMulti (l : List LetInfo) : Eval Unit :=
  voidEval ?_ $ traverseEval ?_ ?_ letInfoToNewStmt l.

elet mkLetInfoWithTel (n : String) (tel : Telescope) (t : Term) (mty : Maybe Term) :=
  appendTelToLetInfo tel $ mkLetInfo n t mty.

elet applyTelescope (t : Term) (tel : Telescope) : Term :=
  appLTerm t (telescopeToApp tel).

elet telNames : Telescope -> List Name := map ?_ ?_ paramName.
elet telTypes : Telescope -> List Term := map ?_ ?_ paramType.

elet typesTel (erased : Bool) (ns : List Name) : Telescope :=
  map ?_ ?_ (λ n : Name. (erased, n, θ{*})) ns.

elet naryFun (l : List Term) (t : Term) : Term :=
  recursionList' ?_ ?_ t (λ t' : Term. λ acc : Term. θ{γ{t'} -> γ{acc}}) l.

elet mkIPair (A, P, a, p : Term) : Term :=
  θ{iPair ?γ{A} ?γ{P} γ{a} γ{p} (beta ?γ{A} γ{a})}.

infix "⊎" := Sum.

elet recursionTripleSum [A, B, C, D : *] (a : A -> D) (b : B -> D) (c : C -> D) (x : A ⊎ B ⊎ C) : D :=
  recursionSum ?_ ?_ ?_ a (recursionSum ?_ ?_ ?_ b c) x.
