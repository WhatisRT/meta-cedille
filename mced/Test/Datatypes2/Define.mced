--------------------------------------------------------------------------------
-- F

elet FName (d : Desc) : Name := φ"${DescName d}F".
elet FTerm (d : Desc) : Term := var (FName d).

elet FTel' (qn, rn : Name) : List CDesc -> Telescope :=
  map ?_ ?_ (λ c : CDesc. false, φ"${CDescName c}X", CDescToTy qn rn c).

elet FTel (qn, rn : Name) (d : Desc) : Telescope :=
  (true, qn, θ{*}) ∷ FTel' qn rn (DescCs d).

elet DescToF (qn, rn : Name) (d : Desc) : Term :=
  lambdaTerm rn θ{*} $ foldWithPi (FTel qn rn d) (var qn).

elet DescToFLI (qn, rn : Name) (d : Desc) : LetInfo :=
  mkLetInfo (FName d) (DescToF qn rn d) (just ?_ θ{* -> *}).

--------------------------------------------------------------------------------
-- F Constructors

elet DescToFCtor (qn, rn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel rn c : Telescope.
  mkLetInfoWithTel φ"${CDescName c}F" ((true, rn, θ{*}) ∷ cArgTel)
    (foldWithLambdas (FTel qn rn d) $ applyTelescope (var φ"${CDescName c}X") cArgTel)
    (just ?_ $ θ{γ{FTerm d} γ{var rn}}).

elet DescToFCtors (qn, rn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToFCtor qn rn d) (DescCs d).

--------------------------------------------------------------------------------
-- WkIndF

elet WkIndFName (d : Desc) : Name := φ"WkInd${DescName d}F".
elet WkIndFTerm (d : Desc) : Term := var (WkIndFName d).

elet WkIndTel (rn, pn : Name) (d : Desc) : Telescope :=
  (true, pn, θ{γ{FTerm d} γ{var rn} -> *}) ∷ map ?_ ?_
    (λ c : CDesc. false, φ"${CDescName c}P", CDescToTyP rn pn c)
    (DescCs d).

elet DescToWkIndF (rn, rn', pn : Name) (d : Desc) : Term :=
  foldWithPi (WkIndTel rn pn d) θ{γ{var pn} γ{var rn'}}.

elet WkIndFLI (rn, rn', pn : Name) (d : Desc) : LetInfo :=
  mkLetInfoWithTel (WkIndFName d)
    [Param|(false, rn, θ{*}); (false, rn', θ{γ{FTerm d} γ{var rn}})]
    (DescToWkIndF rn rn' pn d) (just ?_ θ{*}).

--------------------------------------------------------------------------------
-- WkIndF Constructors

elet DescToWkIndCtor (rn, pn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel rn c : Telescope.
  mkLetInfoWithTel φ"${CDescName c}WkIndF" ((true, rn, θ{*}) ∷ cArgTel)
    (foldWithLambdas (WkIndTel rn pn d) $ applyTelescope (var φ"${CDescName c}P") cArgTel)
    (just ?_ $ θ{γ{WkIndFTerm d} γ{var rn} γ{appCtor rn c}}).

elet DescToWkIndCtors (rn, pn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToWkIndCtor rn pn d) (DescCs d).

--------------------------------------------------------------------------------
-- Mono F

elet MonoFName (d : Desc) : Name := φ"mono${DescName d}F".
elet MonoFTerm (d : Desc) : Term := var (MonoFName d).

elet genCast (X, Y : Term) (cn : Name) (ct : Term) : Term :=
  θ{intrCast ?γ{X} ?γ{Y} ?γ{lambdaTerm cn X ct} ?(beta ?γ{X})}.

elet withMonoLams (an, bn, cn : Name) (t : Term) : Term :=
  LambdaTerm an θ{*} $ LambdaTerm bn θ{*} $ lambdaTerm cn θ{Cast γ{var an} γ{var bn}} t.

elet DescToMonoPf (qn, an, bn, cn, xn : Name) (d : Desc) : Term :=
  ψ ftel = FTel qn bn d : Telescope.
  withMonoLams an bn cn $ genCast θ{γ{FTerm d} γ{var an}} θ{γ{FTerm d} γ{var bn}} xn $
    foldWithLambdas ftel $ appLTerm (var xn) $
      mkAppE (var qn) ∷ castApp an bn cn (telNames (tail ?_ ftel)) d.

elet MonoFLI (qn, an, bn, cn, xn : Name) (d : Desc) : LetInfo :=
  mkLetInfo (MonoFName d)
    (DescToMonoPf qn an bn cn xn d)
    (just ?_ θ{Mono γ{FTerm d}}).

--------------------------------------------------------------------------------
-- Mono WkIndF

elet MonoWkIndFName (d : Desc) : Name := φ"mono${WkIndFName d}".
elet MonoWkIndFTerm (d : Desc) : Term := var (MonoWkIndFName d).

elet DescToMonoWkIndPf (pn, an, bn, cn, xn, yn, zn : Name) (d : Desc) : Term :=
  ψ ftel = WkIndTel bn pn d : Telescope.
  ψ elimMono
    = genElimMono (var an) (var bn) (var cn)
        (λ t : Term. θ{γ{FTerm d} γ{t}}) (MonoFTerm d) : Term -> Term.
  withMonoLams an bn cn $ lambdaTerm yn θ{γ{FTerm d} γ{var an}} $
    genCast θ{γ{WkIndFTerm d} γ{var an} γ{var yn}}
            θ{γ{WkIndFTerm d} γ{var bn}
                  γ{elimMono $ var yn}} xn $
    foldWithLambdas ftel $ appLTerm (var xn) $
      mkAppE (lambdaTerm zn θ{γ{FTerm d} γ{var an}} $ θ{γ{var pn} γ{elimMono $ var zn}}) ∷
      castApp an bn cn (telNames (tail ?_ ftel)) d.

elet MonoWkIndFLI (pn, an, bn, cn, xn, yn, zn : Name) (d : Desc) : LetInfo :=
  mkLetInfo (MonoWkIndFName d)
    (DescToMonoWkIndPf pn an bn cn xn yn zn d)
    (just ?_ θ{MonoD γ{FTerm d} γ{WkIndFTerm d} γ{MonoFTerm d}}).

--------------------------------------------------------------------------------
-- FI & mono FI

elet FIName (d : Desc) : Name := φ"${DescName d}FI".
elet FITerm (d : Desc) : Term := var (FIName d).

elet FILI (rn : Name) (d : Desc) : LetInfo :=
  mkLetInfoWithTel (FIName d) [Param|(false, rn, θ{*})]
    θ{Iota (γ{FTerm d} γ{var rn}) (γ{WkIndFTerm d} γ{var rn})}
    (just ?_ θ{*}).

elet MonoFILI (d : Desc) : LetInfo :=
  mkLetInfo φ"mono${DescName d}FI"
    θ{iotaMono γ{FTerm d} γ{WkIndFTerm d} γ{MonoFTerm d} γ{MonoWkIndFTerm d}}
    (just ?_ θ{Mono γ{FITerm d}}).

--------------------------------------------------------------------------------
-- Main type

elet TyName (d : Desc) : Name := DescName d.
elet TyTerm (d : Desc) : Term := var (TyName d).

elet RollName (d : Desc) : Name := φ"roll${TyName d}".
elet RollTerm (d : Desc) : Term := var (RollName d).

elet TyLI (d : Desc) : LetInfo :=
  mkLetInfo (TyName d) θ{Rec γ{FITerm d}} (just ?_ θ{*}).

elet RollLI (d : Desc) : LetInfo :=
  mkLetInfo (RollName d)
    θ{roll γ{FITerm d} ?γ{var φ"mono${DescName d}FI"}}
    (just ?_ θ{γ{FITerm d} γ{TyTerm d} -> γ{TyTerm d}}).

elet UnrollLI (d : Desc) : LetInfo :=
  mkLetInfo φ"unroll${TyName d}"
    θ{unroll γ{FITerm d} ?γ{var φ"mono${DescName d}FI"}}
    (just ?_ θ{γ{TyTerm d} -> γ{FITerm d} γ{TyTerm d}}).

elet DescToCtor/appCtor (d : Desc) (c : CDesc) (t : Term) : Term := appLTerm t $
  mkAppE (TyTerm d) ∷ map ?_ ?_ (λ n : Name. mkAppU $ var n) $ telNames (cArgTel (TyName d) c).

elet DescToCtor (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel (TyName d) c : Telescope.
  ψ appCtor = DescToCtor/appCtor d c : Term -> Term.
  ψ fCtor = appCtor (var φ"${CDescName c}F") : Term.
  mkLetInfoWithTel φ"${CDescName c}" cArgTel
    θ{γ{RollTerm d} $ iPair ?(γ{FTerm d} γ{TyTerm d}) ?(γ{WkIndFTerm d} γ{TyTerm d})
        γ{fCtor} γ{appCtor $ var φ"${CDescName c}WkIndF"} (beta ?(γ{FTerm d} γ{TyTerm d}) γ{fCtor})}
    (just ?_ $ TyTerm d).

elet DescToCtors (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtor d) (DescCs d).

--------------------------------------------------------------------------------
-- LR

elet RecName (d : Desc) : Name := φ"${DescName d}Rec".
elet RecTerm (d : Desc) : Term := var (RecName d).

elet RecLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel = map ?_ ?_ (λ n : Name. (false, "", var n)) ns : Telescope.
  mkLetInfoWithTel (RecName d)
    ((false, pn, θ{γ{TyTerm d} -> *}) ∷ (false, xn, TyTerm d) ∷
      map ?_ ?_ (λ n : Name. (false, n, θ{*})) ns)
    (foldWithPi tel $ foldWithPi tel $ θ{γ{var pn} γ{var xn}})
    (just ?_ θ{*}).

elet CtorFName (c : CDesc) : Name := φ"${CDescName c}RecF".
elet CtorFTerm (c : CDesc) : Term := var (CtorFName c).

elet DescToCtorF (pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel1 = map ?_ ?_ (λ n : Name. (true, n, θ{*})) ns : Telescope.
  ψ tel2 = map ?_ ?_ (λ n : Name. (false, "", var n)) ns : Telescope.
  ψ P = lambdaTerm xn (TyTerm d) $ appNsU (RecTerm d) (pn ∷ xn ∷ ns) : Term.
  ψ S = θ{Iota γ{TyTerm d} γ{P}} : Term.
  mkLetInfoWithTel (CtorFName c) [Param|(false, pn, θ{γ{TyTerm d} -> *})]
    (foldWithPi tel1 $ castCtorPi S (TyTerm d) θ{castIota ?γ{TyTerm d} ?γ{P}}
      (λ a : List App. foldWithPi tel2 $ θ{γ{var pn} γ{appLTerm (var φ"${CDescName c}") a}}) c)
    (just ?_ θ{*}).

elet DescToCtorFs (pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtorF pn xn d) (DescCs d).

elet ctorFTerms (pn : Name) (d : Desc) : List Term :=
  map ?_ ?_ (λ c : CDesc. var φ"${CDescName c}RecF") (DescCs d).

elet LRPName (d : Desc) : Name := φ"${DescName d}LRP".
elet LRPTerm (d : Desc) : Term := var (LRPName d).

elet LRPLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ ctorFApp = map ?_ ?_ (λ t : Term. mkAppU θ{γ{t} γ{var pn}}) (ctorFTerms pn d) : List App.
  mkLetInfoWithTel (LRPName d) [Param|(false, xn, TyTerm d)]
    (forallTerm pn θ{γ{TyTerm d} -> *} $ appLTerm (RecTerm d) $
      mkAppU (var pn) ∷ mkAppU (var xn) ∷ ctorFApp)
    (just ?_ θ{*}).

elet LRName (d : Desc) : Name := φ"${DescName d}LR".
elet LRTerm (d : Desc) : Term := var (LRName d).

elet LRLI (d : Desc) : LetInfo :=
  mkLetInfo (LRName d)
    θ{Iota γ{TyTerm d} γ{var φ"${DescName d}LRP"}}
    (just ?_ θ{*}).

--------------------------------------------------------------------------------
-- Cast to LR

elet ctorFsTel (pn : Name) (d : Desc) : Telescope :=
  map ?_ ?_ (λ c : CDesc. (false, φ"${CDescName c}X", θ{γ{CtorFTerm c} γ{var pn}})) (DescCs d).

elet ctorFsTel' (d : Desc) : Telescope :=
  map ?_ ?_ (λ c : CDesc. (false, φ"${CDescName c}X", var φ"${CDescName c}LR")) (DescCs d).

elet LR'Term2 (pn, xn : Name) (d : Desc) : Term :=
  lambdaTerm xn (TyTerm d) $ appLTerm (RecTerm d) $
      map ?_ ?_ mkAppU $ var pn ∷ var xn ∷ telTypes (ctorFsTel pn d).

elet LR'Term (pn, xn : Name) (d : Desc) : Term :=
  θ{Iota γ{TyTerm d} γ{LR'Term2 pn xn d}}.

elet CastLRtoLR'LI (pn, xn : Name) (d : Desc) : LetInfo :=
  mkLetInfoWithTel φ"${DescName d}CastLRtoLR'" [Param|(true, pn, θ{γ{TyTerm d} -> *})]
    θ{intrCast ?γ{LRTerm d} ?γ{LR'Term pn xn d}
      ?γ{lambdaTerm xn (LRTerm d) $ mkIPair (TyTerm d) (LR'Term2 pn xn d)
        θ{iPr1 ?γ{TyTerm d} ?γ{LRPTerm d} γ{var xn}} θ{iPr2 ?γ{TyTerm d} ?γ{LRPTerm d} γ{var xn} ?γ{var pn}}}
      ?(beta ?γ{LRTerm d})}
    (just ?_ θ{Cast γ{LRTerm d} γ{LR'Term pn xn d}}).

elet castLRtoLR'Term (d : Desc) : Term := var φ"${DescName d}CastLRtoLR'".

elet DescToLRCtor (pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ cTerm = castCtorApp (LRTerm d) (TyTerm d) θ{castIota ?γ{TyTerm d} ?γ{LRPTerm d}}
                        (var φ"${CDescName c}") c : Term.
  ψ ctorFsTel = ctorFsTel pn d : Telescope.
  ψ cRecTerm = LambdaTerm pn θ{γ{TyTerm d} -> *} $ foldWithLambdas ctorFsTel $
      appLTerm (var φ"${CDescName c}X") $ app ?App (map ?_ ?_ mkAppE $ telTypes ctorFsTel) $
        CDescToCastApp (LRTerm d) (LR'Term pn xn d) θ{γ{castLRtoLR'Term d} ?γ{var pn}} c : Term.
  mkLetInfoWithTel φ"${CDescName c}LR" (cArgTelTerm (LRTerm d) (CDescAs c))
    (mkIPair (TyTerm d) (LRPTerm d) cTerm cRecTerm)
    (just ?_ $ LRTerm d).

elet DescToLRCtors (pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToLRCtor pn xn d) (DescCs d).

elet convCtorTel (T : Term) (t : List App -> Term) (c : CDesc) : Term :=
  ψ tel = cArgTelTerm T (CDescAs c) : Telescope.
  foldWithLambdas tel $ t $ map ?_ ?_ (λ n : Name. mkAppU $ var n) $ telNames tel.

elet RollLRLI (xn : Name) (d : Desc) : LetInfo :=
  ψ genPr = λ n : Name. λ a : List App.
      lambdaTerm xn θ{γ{FITerm d} γ{LRTerm d}} $ appLTerm (var n) $
        app ?_ [App| mkAppE θ{γ{FTerm d} γ{LRTerm d}}
                   ; mkAppE θ{γ{WkIndFTerm d} γ{LRTerm d}}
                   ; mkAppU (var xn)] a
        : Name -> List App -> Term.
  ψ a = mkAppE (LRTerm d) ∷ map ?_ ?_ mkAppU $ telTypes (ctorFsTel' d) : List App.
  mkLetInfo φ"roll${DescName d}LR"
    θ{intrCast ?(γ{FITerm d} γ{LRTerm d}) ?γ{LRTerm d}
      ?γ{genPr "iPr1" a}
      ?γ{genPr "iPr2" (mkAppE (lambdaTerm xn θ{γ{FTerm d} γ{LRTerm d}}
          θ{UEq ?γ{LRTerm d} ?(γ{FTerm d} γ{LRTerm d}) γ{appLTerm (var xn) a} γ{var xn}}) ∷
          map ?_ ?_ (λ c : CDesc. mkAppU $ convCtorTel (LRTerm d)
            (λ ap : List App. θ{beta ?(γ{FTerm d} γ{LRTerm d}) γ{appLTerm (var φ"${CDescName c}F") (mkAppE (LRTerm d) ∷ ap)}}) c) (DescCs d))}}
    (just ?_ θ{Cast (γ{FITerm d} γ{LRTerm d}) γ{LRTerm d}}).

elet ToLRLI (d : Desc) : LetInfo :=
  mkLetInfo φ"to${DescName d}LR"
    θ{recLB γ{FITerm d} ?γ{LRTerm d} ?γ{var φ"roll${DescName d}LR"}}
    (just ?_ θ{Cast γ{TyTerm d} γ{LRTerm d}}).

--------------------------------------------------------------------------------
-- Induction proofs

elet PListPTel (d : Desc) : Telescope := [Param|(true, "PList", θ{List γ{TyTerm d} -> *})].

elet PListHTel (P : Term) (d : Desc) : Telescope :=
  ψ P' = var "PList" : Term.
  [Param|(false, "p'n", θ{γ{P'} (nil ?γ{TyTerm d})})
        ;(false, "p'c", piTerm "pc1"         (TyTerm d)  θ{γ{P}  γ{var "pc1"}
                   -> γ{piTerm "pc2" θ{List γ{TyTerm d}} θ{γ{P'} γ{var "pc2"}
                   -> γ{P'} (cons ?γ{TyTerm d} γ{var "pc1"} γ{var "pc2"})}}})].

elet ADescAddP (d : Desc) : ADesc -> Telescope :=
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ _ : Term. [Param|])
    (λ _ : Unit. [Param|])
    (λ _ : Term × Term. PListPTel d).

elet mkPTel' (d : Desc) (c : CDesc) : Telescope :=
  concat ?_ $ map ?_ ?_ (ADescAddP d) (CDescAs c).

elet mkPTel (pn : Name) (d : Desc) (c : CDesc) : Telescope :=
  ψ additional = mkPTel' d c : Telescope.
  (true, pn, θ{γ{TyTerm d} -> *}) ∷ additional.

elet ADescAddH (d : Desc) (P : Term) : ADesc -> Telescope :=
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ _ : Term. [Param|])
    (λ _ : Unit. [Param|])
    (λ _ : Term × Term. PListHTel P d).

elet mkHTel (pn : Name) (d : Desc) (c : CDesc) : Telescope :=
  ψ additional = concat ?_ $ map ?_ ?_ (ADescAddH d (var pn)) (CDescAs c) : Telescope.
  ψ t = foldl ?_ ?_
          (λ acc : Term. λ a : Nat × ADesc.
            ADescP (pr2 ?_ ?_ a) φ"a${showNatDecimal $ pr1 ?_ ?_ a}" (TyTerm d) (var pn) (var "PList") acc)
          (zipWithIndex ?_ ?_ (λ k : Nat. λ a : ADesc. (k, a)) (CDescAs c))
          θ{γ{var pn} γ{appLTerm (var (CDescName c)) $
                          map ?_ ?_ (λ k : Nat. mkAppU $ var φ"a${showNatDecimal k}")
                                    (upTo $ length ?_ (CDescAs c))}}
      : Term.
  (false, φ"h${CDescName c}", t) ∷ additional.

elet DescToIndPf/genIotaArgs (d : Desc) (P : Term) (recApp : List App) : Term × Term :=
  (TyTerm d, lambdaTerm "x" (TyTerm d) $ appLTerm (RecTerm d) (mkAppU P ∷ mkAppU (var "x") ∷ recApp)).

elet DescToIndPf/genLam (d : Desc) (P : Term) (recApp : List App) : ADesc -> Term :=
  ψ genIotaArgs = DescToIndPf/genIotaArgs d P recApp : Term × Term.
  ψ recTy = θ{Iota γ{pr1 ?_ ?_ genIotaArgs} γ{pr2 ?_ ?_ genIotaArgs}} : Term.
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ t  : Term. t)
    (λ _  : Unit. recTy)
    (λ ts : Term × Term. θ{γ{pr1 ?Term ?Term ts} γ{recTy}}).

elet DescToIndPf/genApp (d : Desc) (P : Term) (recApp, recApp', extraHs : List App) (n : Name)
  : ADesc -> List App :=
  ψ genIotaArgs = DescToIndPf/genIotaArgs d P recApp : Term × Term.
  ψ genIotaArgs1 = pr1 ?_ ?_ genIotaArgs : Term.
  ψ genIotaArgs2 = pr2 ?_ ?_ genIotaArgs : Term.
  ψ genPr = λ t : Term. λ a : List App. appLTerm t $ mkAppE genIotaArgs1 ∷ mkAppE genIotaArgs2 ∷ a
    : Term -> List App -> Term.
  ψ convRec = λ n' : Name. genPr θ{iPr2} (mkAppU (var n') ∷ app ?_ recApp' recApp') : Name -> Term.
  ψ iota = θ{Iota γ{genIotaArgs1} γ{genIotaArgs2}} : Term.
  ψ cIota = θ{castIota ?γ{genIotaArgs1} ?γ{genIotaArgs2}} : Term.
  ψ convApp = θ{indHelperList/conv ?γ{iota} ?γ{TyTerm d} ?γ{cIota} γ{var n}} : Term.
  ψ convPf = θ{γ{appLTerm θ{indHelperList ?γ{iota} ?γ{TyTerm d} ?γ{cIota} ?γ{P}
                              γ{lambdaTerm "xi" iota $ convRec "xi"} ?PList} extraHs}
    γ{var n}} : Term.
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ t : Term. [App|mkAppU $ var n])
    (λ _ : Unit. [App| mkAppU $ genPr θ{iPr1} [App|mkAppU $ var n]
                     ; mkAppU $ convRec n])
    (λ _ : Term × Term. [App|mkAppU convApp; mkAppU convPf]).

elet DescToIndPf (hn, pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ pTel = [Param|] : Telescope.
  ψ cNums = upTo $ length ?_ (DescCs d) : List Nat.
  ψ recTel = map ?_ ?_ (λ k : Nat. (true, φ"A${showNatDecimal k}", θ{*})) cNums : Telescope.
  ψ recApp = map ?_ ?_ (λ k : Nat. mkAppU $ var φ"A${showNatDecimal k}") cNums : List App.
  ψ recTel' = map ?_ ?_ (λ k : Nat. (false, φ"a${showNatDecimal k}", var φ"A${showNatDecimal k}")) cNums : Telescope.
  mkLetInfoWithTel φ"${CDescName c}RecFPf"
    (app ?Param (mkPTel pn d c) (mkHTel pn d c))
    (foldWithLambdas recTel $
     foldWithLambdas (zipWithIndex ?_ ?_ (λ k : Nat. λ a : ADesc.
       (false, φ"x${showNatDecimal k}", DescToIndPf/genLam d (var pn) recApp a)) (CDescAs c)) $
     foldWithLambdas recTel' $
     appLTerm (var φ"h${CDescName c}") (concat ?App $ zipWithIndex ?_ ?_
       (λ k : Nat. DescToIndPf/genApp d (var pn) recApp (telescopeToApp recTel')
         (telescopeToApp (PListHTel (var pn) d)) φ"x${showNatDecimal k}") (CDescAs c)))
    (just ?_ θ{γ{var φ"${CDescName c}RecF"} γ{var pn}}).

elet DescToIndPfs (hn, pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToIndPf hn pn xn d) (DescCs d).

elet DefineIndPfs (hn, pn, xn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ DescToIndPfs hn pn xn d.

--------------------------------------------------------------------------------
-- Induction schemes

elet RecLRName (d : Desc) : Name := φ"rec${DescName d}LR".
elet RecLRTerm (d : Desc) : Term := var (RecLRName d).

elet RecLRLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ tel = zipWithIndex ?_ ?_ (λ i : Nat. λ t : Term. (false, φ"a${showNatDecimal i}", θ{γ{t} γ{var pn}}))
    (ctorFTerms pn d) : Telescope.
  ψ a = [App|mkAppE $ TyTerm d; mkAppE $ var φ"${DescName d}LRP"; mkAppU $ var xn] : List App.
  mkLetInfoWithTel φ"rec${DescName d}LR"
    ((true, pn, θ{γ{TyTerm d} -> *}) ∷ (false, xn, LRTerm d) ∷ tel)
    (appLTerm θ{iPr2} $ app ?App a $ mkAppE (var pn) ∷
      map ?_ ?_ (λ n : Name. mkAppU $ var n) (telNames tel))
    (just ?_ $ foldWithPi tel θ{γ{var pn} γ{appLTerm θ{iPr1} a}}).

elet genIndScheme (d : Desc) (P, x : Term) (a : List App) : Term :=
  appLTerm (RecLRTerm d) (mkAppE P ∷ mkAppU x ∷ app ?_ a a).

elet DefineIndScheme/genPfApp (pn : Name) (d : Desc) (c : CDesc) : Term :=
  ψ pApp = telescopeToApp $ (true, pn, θ{γ{TyTerm d} -> *}) ∷ mkPTel' d c : List App.
  ψ genExtraApp = λ a : ADesc. telescopeToApp (ADescAddH d (var pn) a) : ADesc -> List App.
  ψ extra = concat ?_ $ map ?_ ?_ genExtraApp (CDescAs c) : List App.
  appLTerm (var φ"${CDescName c}RecFPf") $
    concat ?_ [List App|pApp; [App| mkAppU $ var φ"h${CDescName c}"]; extra].

elet DefineIndScheme (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ pTel = (true, pn, θ{γ{TyTerm d} -> *}) ∷ concat ?_ (map ?_ ?_ (mkPTel' d) (DescCs d)) : Telescope.
  ψ hTel = concat ?_ $ map ?_ ?_ (mkHTel pn d) (DescCs d) : Telescope.
  ψ pfApp = map ?_ ?_ (λ c : CDesc. mkAppU $ DefineIndScheme/genPfApp pn d c) (DescCs d) : List App.
  mkLetInfoWithTel φ"ind${DescName d}"
    (app ?Param (app ?Param pTel hTel) [Param|(false, xn, TyTerm d)])
    (appLTerm (var φ"rec${DescName d}LR") $
      (mkAppE (var pn)) ∷ (mkAppU θ{elimCast ?γ{TyTerm d} ?γ{LRTerm d} ?γ{var φ"to${DescName d}LR"} γ{var xn}}) ∷
      app ?App pfApp pfApp)
    (just ?_ $ θ{γ{var pn} γ{var xn}}).

--------------------------------------------------------------------------------
-- Define All

elet DefineTy (an, bn, cn, pn, qn, rn, rn', xn, yn, zn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ concat ?_ [List LetInfo
    | [LetInfo| DescToFLI qn rn d ]
    ; DescToFCtors qn rn d
    ; [LetInfo| WkIndFLI rn rn' pn d ]
    ; DescToWkIndCtors rn pn d
    ; [LetInfo| MonoFLI qn an bn cn xn d ; MonoWkIndFLI pn an bn cn xn yn zn d
              ; FILI rn d ; MonoFILI d ; TyLI d ; RollLI d ; UnrollLI d ]
    ; DescToCtors d
    ; [LetInfo| RecLI pn xn d ]
    ; DescToCtorFs pn xn d
    ; [LetInfo| LRPLI pn xn d ; LRLI d ; CastLRtoLR'LI pn xn d ]
    ; DescToLRCtors pn xn d
    ; [LetInfo| RollLRLI xn d ; ToLRLI d ; RecLRLI pn xn d ]
    ].

elet DefineInd (hn, pn, xn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ concat ?_ [List LetInfo
  | DescToIndPfs hn pn xn d
  ; [LetInfo| DefineIndScheme pn xn d ]
  ].
