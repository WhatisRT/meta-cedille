--------------------------------------------------------------------------------
-- General purpose

elet mkTyLI (d : Desc) (n : Name) (tel : Telescope) (T, t : Term) : LetInfo :=
  mkLetInfoWithTel n (app ?_ (DescTel d) tel) t (just ?_ T).

elet appDescTel (d : Desc) (t : Term) : Term :=
  appLTerm t $ telescopeToApp (DescTel d).

elet genTerm (d : Desc) (n : Desc -> Name) : Term := appDescTel d (var $ n d).

-- mkTYLICast?

--------------------------------------------------------------------------------
-- F

elet FName (d : Desc) : Name := φ"${DescName d}F".
elet FTerm (d : Desc) : Term := genTerm d FName.

elet FTel' (qn, rn : Name) : List CDesc -> Telescope :=
  map ?_ ?_ (λ c : CDesc. false, φ"${CDescName c}X", CDescToTy qn rn c).

elet FTel (qn, rn : Name) (d : Desc) : Telescope :=
  (true, qn, θ{*}) ∷ FTel' qn rn (DescCs d).

elet DescToF (qn, rn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (FName d) [Param|(false, rn, θ{*})] θ{*} (foldWithPi (FTel qn rn d) (var qn)).

--------------------------------------------------------------------------------
-- F Constructors

elet FCtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}F".
elet FCtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (FCtorName c).

elet DescToFCtor (qn, rn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel rn c : Telescope.
  mkTyLI d (FCtorName c d) ((true, rn, θ{*}) ∷ cArgTel) θ{γ{FTerm d} γ{var rn}}
    (foldWithLambdas (FTel qn rn d) $ applyTelescope (var φ"${CDescName c}X") cArgTel).

elet DescToFCtors (qn, rn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToFCtor qn rn d) (DescCs d).

--------------------------------------------------------------------------------
-- WkIndF

elet appCtor (rn : Name) (d : Desc) (c : CDesc) : Term :=
  applyTelescope (FCtorTerm c d) ((true, rn, θ{*}) ∷ cArgTel rn c).

elet CDescToTyP (rn, pn : Name) (d : Desc) (c : CDesc) : Term :=
  foldWithPi (cArgTel rn c) θ{γ{var pn} γ{appCtor rn d c}}.

elet WkIndFName (d : Desc) : Name := φ"WkInd${DescName d}F".
elet WkIndFTerm (d : Desc) : Term := genTerm d WkIndFName.

elet WkIndTel (rn, pn : Name) (d : Desc) : Telescope :=
  (true, pn, θ{γ{FTerm d} γ{var rn} -> *}) ∷ map ?_ ?_
    (λ c : CDesc. false, φ"${CDescName c}P", CDescToTyP rn pn d c)
    (DescCs d).

elet WkIndF (rn, rn', pn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (WkIndFName d) [Param|(false, rn, θ{*}); (false, rn', θ{γ{FTerm d} γ{var rn}})] θ{*}
    (foldWithPi (WkIndTel rn pn d) θ{γ{var pn} γ{var rn'}}).

--------------------------------------------------------------------------------
-- WkIndF Constructors

elet WkIndFCtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}WkIndF".
elet WkIndFCtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (WkIndFCtorName c).

elet DescToWkIndCtor (rn, pn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  mkTyLI d (WkIndFCtorName c d) ((true, rn, θ{*}) ∷ cArgTel rn c)
    θ{γ{WkIndFTerm d} γ{var rn} γ{appCtor rn d c}}
    (foldWithLambdas (WkIndTel rn pn d) $ applyTelescope (var φ"${CDescName c}P") (cArgTel rn c)).

elet DescToWkIndCtors (rn, pn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToWkIndCtor rn pn d) (DescCs d).

--------------------------------------------------------------------------------
-- Mono F

elet MonoFName (d : Desc) : Name := φ"mono${DescName d}F".
elet MonoFTerm (d : Desc) : Term := genTerm d MonoFName.

elet genCast (X, Y : Term) (cn : Name) (ct : Term) : Term :=
  θ{intrCast ?γ{X} ?γ{Y} ?γ{lambdaTerm cn X ct} ?(beta ?γ{X})}.

elet withMonoLams (an, bn, cn : Name) (t : Term) : Term :=
  LambdaTerm an θ{*} $ LambdaTerm bn θ{*} $ lambdaTerm cn θ{Cast γ{var an} γ{var bn}} t.

elet MonoF (qn, an, bn, cn, xn : Name) (d : Desc) : LetInfo :=
  ψ ftel = FTel qn bn d : Telescope.
  mkTyLI d (MonoFName d) [Param|] θ{Mono γ{FTerm d}} $
    withMonoLams an bn cn $ genCast θ{γ{FTerm d} γ{var an}} θ{γ{FTerm d} γ{var bn}} xn $
      foldWithLambdas ftel $ appLTerm (var xn) $
        mkAppE (var qn) ∷ castApp an bn cn (telNames (tail ?_ ftel)) d.

--------------------------------------------------------------------------------
-- Mono WkIndF

elet MonoWkIndFName (d : Desc) : Name := φ"mono${WkIndFName d}".
elet MonoWkIndFTerm (d : Desc) : Term := genTerm d MonoWkIndFName.

elet DescToMonoWkIndPf (pn, an, bn, cn, xn, yn, zn : Name) (d : Desc) : Term :=
  ψ ftel = WkIndTel bn pn d : Telescope.
  ψ elimMono = genElimMono (var an) (var bn) (var cn) (λ t : Term. θ{γ{FTerm d} γ{t}}) (MonoFTerm d)
    : Term -> Term.
  withMonoLams an bn cn $ lambdaTerm yn θ{γ{FTerm d} γ{var an}} $
    genCast θ{γ{WkIndFTerm d} γ{var an} γ{var yn}}
            θ{γ{WkIndFTerm d} γ{var bn} γ{elimMono $ var yn}} xn $
    foldWithLambdas ftel $ appLTerm (var xn) $
      mkAppE (lambdaTerm zn θ{γ{FTerm d} γ{var an}} $ θ{γ{var pn} γ{elimMono $ var zn}}) ∷
      castApp an bn cn (telNames (tail ?_ ftel)) d.

elet MonoWkIndF (pn, an, bn, cn, xn, yn, zn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (MonoWkIndFName d) [Param|] θ{MonoD γ{FTerm d} γ{WkIndFTerm d} γ{MonoFTerm d}}
    (DescToMonoWkIndPf pn an bn cn xn yn zn d).

--------------------------------------------------------------------------------
-- FI & mono FI

elet FIName (d : Desc) : Name := φ"${DescName d}FI".
elet FITerm (d : Desc) : Term := genTerm d FIName.

elet FILI (rn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (FIName d) [Param|(false, rn, θ{*})] θ{*}
    θ{Iota (γ{FTerm d} γ{var rn}) (γ{WkIndFTerm d} γ{var rn})}.

elet MonoFIName (d : Desc) : Name := φ"mono${DescName d}FI".
elet MonoFITerm (d : Desc) : Term := genTerm d MonoFIName.

elet MonoFILI (d : Desc) : LetInfo :=
  mkTyLI d (MonoFIName d) [Param|] θ{Mono γ{FITerm d}}
    θ{iotaMono γ{FTerm d} γ{WkIndFTerm d} γ{MonoFTerm d} γ{MonoWkIndFTerm d}}.

--------------------------------------------------------------------------------
-- Main type

elet TyName (d : Desc) : Name := DescName d.
elet TyTerm (d : Desc) : Term := genTerm d TyName.
elet TyTermP (d : Desc) : Term := θ{γ{TyTerm d} -> *}.

elet RollName (d : Desc) : Name := φ"roll${TyName d}".
elet RollTerm (d : Desc) : Term := genTerm d RollName.

elet UnrollName (d : Desc) : Name := φ"unroll${TyName d}".
elet UnrollTerm (d : Desc) : Term := genTerm d UnrollName.

elet TyLI (d : Desc) : LetInfo :=
  mkTyLI d (TyName d) [Param|] θ{*} θ{Rec γ{FITerm d}}.

elet RollLI (d : Desc) : LetInfo :=
  mkTyLI d (RollName d) [Param|] θ{γ{FITerm d} γ{TyTerm d} -> γ{TyTerm d}}
    θ{roll γ{FITerm d} ?γ{MonoFITerm d}}.

elet UnrollLI (d : Desc) : LetInfo :=
  mkTyLI d (UnrollName d) [Param|] θ{γ{TyTerm d} -> γ{FITerm d} γ{TyTerm d}}
    θ{unroll γ{FITerm d} ?γ{MonoFITerm d}}.

elet CtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}".
elet CtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (CtorName c).

elet DescToCtor/appCtor (d : Desc) (c : CDesc) (t : Term) : Term := appLTerm t $
  mkAppE (TyTerm d) ∷ map ?_ ?_ (λ n : Name. mkAppU $ var n) $ telNames (cArgTel (TyName d) c).

elet DescToCtor (d : Desc) (c : CDesc) : LetInfo :=
  ψ appCtor = DescToCtor/appCtor d c : Term -> Term.
  ψ fCtor = appCtor (FCtorTerm c d) : Term.
  mkTyLI d (CtorName c d) (cArgTelTerm (TyTerm d) (CDescAs c)) (TyTerm d)
    θ{γ{RollTerm d} $ iPair ?(γ{FTerm d} γ{TyTerm d}) ?(γ{WkIndFTerm d} γ{TyTerm d})
        γ{fCtor} γ{appCtor (WkIndFCtorTerm c d)} (beta ?(γ{FTerm d} γ{TyTerm d}) γ{fCtor})}.

elet DescToCtors (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtor d) (DescCs d).

--------------------------------------------------------------------------------
-- LR

elet RecName (d : Desc) : Name := φ"${DescName d}Rec".
elet RecTerm (d : Desc) : Term := genTerm d RecName.

elet RecLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel = map ?_ ?_ (λ n : Name. (false, "", var n)) ns : Telescope.
  mkTyLI d (RecName d) ((false, pn, TyTermP d) ∷ (false, xn, TyTerm d) ∷ typesTel false ns) θ{*} $
    foldWithPi (app ?_ tel tel) $ θ{γ{var pn} γ{var xn}}.

elet CtorFName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}RecF".
elet CtorFTerm (c : CDesc) (d : Desc) : Term := genTerm d (CtorFName c).

elet DescToCtorF (pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel = map ?_ ?_ (λ n : Name. (false, "", var n)) ns : Telescope.
  ψ P   = lambdaTerm xn (TyTerm d) $ appNsU (RecTerm d) (pn ∷ xn ∷ ns) : Term.
  mkTyLI d (CtorFName c d) [Param|(false, pn, TyTermP d)] θ{*} $
    foldWithPi (typesTel true ns) $ castCtorPi θ{Iota γ{TyTerm d} γ{P}} (TyTerm d)
      θ{castIota ?γ{TyTerm d} ?γ{P}}
      (λ a : List App. foldWithPi tel $ θ{γ{var pn} γ{appLTerm (CtorTerm c d) a}}) c.

elet DescToCtorFs (pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtorF pn xn d) (DescCs d).

elet ctorFTerms (pn : Name) (d : Desc) : List Term :=
  map ?_ ?_ (λ c : CDesc. CtorFTerm c d) (DescCs d).

elet LRPName (d : Desc) : Name := φ"${DescName d}LRP".
elet LRPTerm (d : Desc) : Term := genTerm d LRPName.

elet LRPLI (pn, xn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (LRPName d) [Param|(false, xn, TyTerm d)] θ{*} $
    forallTerm pn (TyTermP d) $ appLTerm (RecTerm d) $ mkAppU (var pn) ∷ mkAppU (var xn) ∷
      map ?_ ?_ (λ t : Term. mkAppU θ{γ{t} γ{var pn}}) (ctorFTerms pn d).

elet LRName (d : Desc) : Name := φ"${DescName d}LR".
elet LRTerm (d : Desc) : Term := genTerm d LRName.

elet LRLI (d : Desc) : LetInfo :=
  mkTyLI d (LRName d) [Param|] θ{*} θ{Iota γ{TyTerm d} γ{LRPTerm d}}.

--------------------------------------------------------------------------------
-- Cast to LR

elet LRCtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}LR".
elet LRCtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (LRCtorName c).

elet ctorFsTel (pn : Name) (d : Desc) : Telescope :=
  map ?_ ?_ (λ c : CDesc. (false, φ"${CDescName c}X", θ{γ{CtorFTerm c d} γ{var pn}})) (DescCs d).

elet ctorFsTel' (d : Desc) : Telescope :=
  map ?_ ?_ (λ c : CDesc. (false, φ"${CDescName c}X", LRCtorTerm c d)) (DescCs d).

elet LR'Term2 (pn, xn : Name) (d : Desc) : Term :=
  lambdaTerm xn (TyTerm d) $ appLTerm (RecTerm d) $
      map ?_ ?_ mkAppU $ var pn ∷ var xn ∷ telTypes (ctorFsTel pn d).

elet LR'Term (pn, xn : Name) (d : Desc) : Term :=
  θ{Iota γ{TyTerm d} γ{LR'Term2 pn xn d}}.

elet castLRtoLR'Name (d : Desc) : Name := φ"${DescName d}CastLRtoLR'".
elet castLRtoLR'Term (d : Desc) : Term := genTerm d castLRtoLR'Name.

elet CastLRtoLR'LI (pn, xn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (castLRtoLR'Name d) [Param|(true, pn, TyTermP d)]
    θ{Cast γ{LRTerm d} γ{LR'Term pn xn d}}
    θ{intrCast ?γ{LRTerm d} ?γ{LR'Term pn xn d}
      ?γ{lambdaTerm xn (LRTerm d) $ mkIPair (TyTerm d) (LR'Term2 pn xn d)
        θ{iPr1 ?γ{TyTerm d} ?γ{LRPTerm d} γ{var xn}} θ{iPr2 ?γ{TyTerm d} ?γ{LRPTerm d} γ{var xn} ?γ{var pn}}}
      ?(beta ?γ{LRTerm d})}.

elet DescToLRCtor (pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  mkTyLI d (LRCtorName c d) (cArgTelTerm (LRTerm d) (CDescAs c)) (LRTerm d) $
    mkIPair (TyTerm d) (LRPTerm d)
      (castCtorApp (LRTerm d) (TyTerm d) θ{castIota ?γ{TyTerm d} ?γ{LRPTerm d}} (CtorTerm c d) c)
      (LambdaTerm pn (TyTermP d) $ foldWithLambdas (ctorFsTel pn d) $
        appLTerm (var φ"${CDescName c}X") $ app ?App (map ?_ ?_ mkAppE $ telTypes (ctorFsTel pn d)) $
          CDescToCastApp (LRTerm d) (LR'Term pn xn d) θ{γ{castLRtoLR'Term d} ?γ{var pn}} c).

elet DescToLRCtors (pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToLRCtor pn xn d) (DescCs d).

elet convCtorTel (T : Term) (t : List App -> Term) (c : CDesc) : Term :=
  ψ tel = cArgTelTerm T (CDescAs c) : Telescope.
  foldWithLambdas tel $ t $ map ?_ ?_ (λ n : Name. mkAppU $ var n) $ telNames tel.

elet RollLRName (d : Desc) : Name := φ"roll${DescName d}LR".
elet RollLRTerm (d : Desc) : Term := genTerm d RollLRName.

elet RollLR (xn : Name) (d : Desc) : LetInfo :=
  ψ FLRTerm  = θ{γ{FTerm d}  γ{LRTerm d}} : Term.
  ψ FILRTerm = θ{γ{FITerm d} γ{LRTerm d}} : Term.
  ψ genPr = λ n : Name. λ a : List App. lambdaTerm xn FILRTerm $ appLTerm (var n) $ app ?_
      [App|mkAppE FLRTerm; mkAppE θ{γ{WkIndFTerm d} γ{LRTerm d}}; mkAppU (var xn)] a
      : Name -> List App -> Term.
  ψ a = mkAppE (LRTerm d) ∷ map ?_ ?_ mkAppU $ telTypes (ctorFsTel' d) : List App.
  mkTyLI d (RollLRName d) [Param|] θ{Cast γ{FILRTerm} γ{LRTerm d}}
    θ{intrCast ?γ{FILRTerm} ?γ{LRTerm d}
      ?γ{genPr "iPr1" a}
      ?γ{genPr "iPr2" (mkAppE (lambdaTerm xn FLRTerm
          θ{UEq ?γ{LRTerm d} ?γ{FLRTerm} γ{appLTerm (var xn) a} γ{var xn}}) ∷
          map ?_ ?_ (λ c : CDesc. mkAppU $ convCtorTel (LRTerm d) (λ ap : List App.
              θ{beta ?γ{FLRTerm} γ{appLTerm (FCtorTerm c d) (mkAppE (LRTerm d) ∷ ap)}}) c)
            (DescCs d))}}.

elet ToLRName (d : Desc) : Name := φ"to${DescName d}LR".
elet ToLRTerm (d : Desc) : Term := genTerm d ToLRName.

elet ToLRLI (d : Desc) : LetInfo :=
  mkTyLI d (ToLRName d) [Param|]
    θ{Cast γ{TyTerm d} γ{LRTerm d}}
    θ{recLB γ{FITerm d} ?γ{LRTerm d} ?γ{RollLRTerm d}}.

--------------------------------------------------------------------------------
-- Induction proofs

elet RecFPfName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}RecFPf".
elet RecFPfTerm (c : CDesc) (d : Desc) : Term := genTerm d (RecFPfName c).

elet PListPTel (d : Desc) : Telescope := [Param|(true, "PList", θ{List γ{TyTerm d} -> *})].

elet PListHTel (P : Term) (d : Desc) : Telescope :=
  ψ P' = var "PList" : Term.
  [Param|(false, "p'n", θ{γ{P'} (nil ?γ{TyTerm d})})
        ;(false, "p'c", piTerm "pc1"         (TyTerm d)  θ{γ{P}  γ{var "pc1"}
                   -> γ{piTerm "pc2" θ{List γ{TyTerm d}} θ{γ{P'} γ{var "pc2"}
                   -> γ{P'} (cons ?γ{TyTerm d} γ{var "pc1"} γ{var "pc2"})}}})].

elet ADescAddP (d : Desc) (ad : ADesc) : Telescope :=
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ _ : Term. [Param|])
    (λ _ : Unit. [Param|])
    (λ _ : Term × Term. PListPTel d)
    (adTDesc ad).

elet mkPTel' (d : Desc) (c : CDesc) : Telescope :=
  concat ?_ $ map ?_ ?_ (ADescAddP d) (CDescAs c).

elet mkPTel (pn : Name) (d : Desc) (c : CDesc) : Telescope :=
  ψ additional = mkPTel' d c : Telescope.
  (true, pn, TyTermP d) ∷ additional.

elet ADescAddH (d : Desc) (P : Term) (ad : ADesc) : Telescope :=
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ _ : Term. [Param|])
    (λ _ : Unit. [Param|])
    (λ _ : Term × Term. PListHTel P d)
    (adTDesc ad).

elet mkHTel (pn : Name) (d : Desc) (c : CDesc) : Telescope :=
  ψ additional = concat ?_ $ map ?_ ?_ (ADescAddH d (var pn)) (CDescAs c) : Telescope.
  ψ t = foldl ?_ ?_
          (λ acc : Term. λ a : ADesc.
            TDescP (adTDesc a) (adName a) (TyTerm d) (var pn) (var "PList") acc)
          (CDescAs c)
          θ{γ{var pn} γ{appLTerm (CtorTerm c d) (cArgApp c)}}
      : Term.
  (false, φ"h${CDescName c}", t) ∷ additional.

elet DescToIndPf/genIotaArgs (d : Desc) (P : Term) (recApp : List App) : Term × Term :=
  (TyTerm d, lambdaTerm "x" (TyTerm d) $ appLTerm (RecTerm d) (mkAppU P ∷ mkAppU (var "x") ∷ recApp)).

elet DescToIndPf/genLam (d : Desc) (P : Term) (recApp : List App) (ad : ADesc) : Term :=
  ψ genIotaArgs = DescToIndPf/genIotaArgs d P recApp : Term × Term.
  ψ recTy = θ{Iota γ{pr1 ?_ ?_ genIotaArgs} γ{pr2 ?_ ?_ genIotaArgs}} : Term.
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ t  : Term. t)
    (λ _  : Unit. recTy)
    (λ ts : Term × Term. θ{γ{pr1 ?Term ?Term ts} γ{recTy}})
    (adTDesc ad).

elet DescToIndPf/genApp (d : Desc) (P : Term) (recApp, recApp', extraHs : List App) (n : Name)
  (ad : ADesc) : List App :=
  ψ genIotaArgs = DescToIndPf/genIotaArgs d P recApp : Term × Term.
  ψ genIotaArgs1 = pr1 ?_ ?_ genIotaArgs : Term.
  ψ genIotaArgs2 = pr2 ?_ ?_ genIotaArgs : Term.
  ψ genPr = λ t : Term. λ a : List App. appLTerm t $ mkAppE genIotaArgs1 ∷ mkAppE genIotaArgs2 ∷ a
    : Term -> List App -> Term.
  ψ convRec = λ n' : Name. genPr θ{iPr2} (mkAppU (var n') ∷ app ?_ recApp' recApp') : Name -> Term.
  ψ iota = θ{Iota γ{genIotaArgs1} γ{genIotaArgs2}} : Term.
  ψ cIota = θ{castIota ?γ{genIotaArgs1} ?γ{genIotaArgs2}} : Term.
  ψ convApp = θ{indHelperList/conv ?γ{iota} ?γ{TyTerm d} ?γ{cIota} γ{var n}} : Term.
  ψ convPf = θ{γ{appLTerm θ{indHelperList ?γ{iota} ?γ{TyTerm d} ?γ{cIota} ?γ{P}
                              γ{lambdaTerm "xi" iota $ convRec "xi"} ?PList} extraHs}
    γ{var n}} : Term.
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ t : Term. [App|mkAppU $ var n])
    (λ _ : Unit. [App| mkAppU $ genPr θ{iPr1} [App|mkAppU $ var n]
                     ; mkAppU $ convRec n])
    (λ _ : Term × Term. [App|mkAppU convApp; mkAppU convPf])
    (adTDesc ad).

elet DescToIndPf (hn, pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ len = length ?_ (DescCs d) : Nat.
  ψ recApp = appNames false (mkNames "A" len) : List App.
  ψ recTel = zipWith ?_ ?_ ?_ (λ n, n' : Name. (false, n, var n'))
                              (mkNames "a" len) (mkNames "A" len) : Telescope.
  mkTyLI d (RecFPfName c d)
    (app ?Param (mkPTel pn d c) (mkHTel pn d c))
    θ{γ{CtorFTerm c d} γ{var pn}}
    (foldWithLambdas (typesTel true (mkNames "A" len)) $
     foldWithLambdas (map ?_ ?_ (λ a : ADesc.
       (false, adName a, DescToIndPf/genLam d (var pn) recApp a)) (CDescAs c)) $
     foldWithLambdas recTel $
     appLTerm (var φ"h${CDescName c}") (concat ?App $ map ?_ ?_
       (λ a : ADesc. DescToIndPf/genApp d (var pn) recApp (telescopeToApp recTel)
         (telescopeToApp (PListHTel (var pn) d)) (adName a) a) (CDescAs c))).

elet DescToIndPfs (hn, pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToIndPf hn pn xn d) (DescCs d).

elet DefineIndPfs (hn, pn, xn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ DescToIndPfs hn pn xn d.

--------------------------------------------------------------------------------
-- Induction schemes

elet RecLRName (d : Desc) : Name := φ"rec${DescName d}LR".
elet RecLRTerm (d : Desc) : Term := genTerm d RecLRName.

elet RecLRLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ tel = zipWithIndex ?_ ?_ (λ i : Nat. λ t : Term. (false, φ"a${showNatDecimal i}", θ{γ{t} γ{var pn}}))
    (ctorFTerms pn d) : Telescope.
  ψ a = [App|mkAppE $ TyTerm d; mkAppE (LRPTerm d); mkAppU $ var xn] : List App.
  mkTyLI d (RecLRName d)
    ((true, pn, TyTermP d) ∷ (false, xn, LRTerm d) ∷ tel)
    (foldWithPi tel θ{γ{var pn} γ{appLTerm θ{iPr1} a}})
    (appLTerm θ{iPr2} $ app ?App a $ mkAppE (var pn) ∷
      map ?_ ?_ (λ n : Name. mkAppU $ var n) (telNames tel)).

elet genIndScheme (d : Desc) (P, x : Term) (a : List App) : Term :=
  appLTerm (RecLRTerm d) (mkAppE P ∷ mkAppU x ∷ app ?_ a a).

elet DefineIndScheme/genPfApp (pn : Name) (d : Desc) (c : CDesc) : Term :=
  ψ pApp = telescopeToApp $ (true, pn, TyTermP d) ∷ mkPTel' d c : List App.
  ψ genExtraApp = λ a : ADesc. telescopeToApp (ADescAddH d (var pn) a) : ADesc -> List App.
  ψ extra = concat ?_ $ map ?_ ?_ genExtraApp (CDescAs c) : List App.
  appLTerm (RecFPfTerm c d) $
    concat ?_ [List App|pApp; [App| mkAppU $ var φ"h${CDescName c}"]; extra].

elet DefineIndScheme (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ pTel = (true, pn, TyTermP d) ∷ concat ?_ (map ?_ ?_ (mkPTel' d) (DescCs d)) : Telescope.
  ψ hTel = concat ?_ $ map ?_ ?_ (mkHTel pn d) (DescCs d) : Telescope.
  ψ pfApp = map ?_ ?_ (λ c : CDesc. mkAppU $ DefineIndScheme/genPfApp pn d c) (DescCs d) : List App.
  mkTyLI d φ"ind${DescName d}"
    (app ?Param (app ?Param pTel hTel) [Param|(false, xn, TyTerm d)])
    θ{γ{var pn} γ{var xn}}
    (appLTerm (RecLRTerm d) $
      (mkAppE (var pn)) ∷ (mkAppU θ{elimCast ?γ{TyTerm d} ?γ{LRTerm d} ?γ{ToLRTerm d} γ{var xn}}) ∷
      app ?App pfApp pfApp).

--------------------------------------------------------------------------------
-- Define All

elet DefineTy' (an, bn, cn, pn, qn, rn, rn', xn, yn, zn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ concat ?_ [List LetInfo
    | [LetInfo| DescToF qn rn d ]
    ; DescToFCtors qn rn d
    ; [LetInfo| WkIndF rn rn' pn d ]
    ; DescToWkIndCtors rn pn d
    ; [LetInfo| MonoF qn an bn cn xn d ; MonoWkIndF pn an bn cn xn yn zn d
              ; FILI rn d ; MonoFILI d ; TyLI d ; RollLI d ; UnrollLI d ]
    ; DescToCtors d
    ; [LetInfo| RecLI pn xn d ]
    ; DescToCtorFs pn xn d
    ; [LetInfo| LRPLI pn xn d ; LRLI d ; CastLRtoLR'LI pn xn d ]
    ; DescToLRCtors pn xn d
    ; [LetInfo| RollLR xn d ; ToLRLI d ; RecLRLI pn xn d ]
    ].

elet DefineInd' (hn, pn, xn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ concat ?_ [List LetInfo
  | DescToIndPfs hn pn xn d
  ; [LetInfo| DefineIndScheme pn xn d ]
  ].

let DefineTy (d : Desc) : Eval Unit :=
  ψ ns = genFreshD/ns d : List Name.
  DefineTy' (genFreshPrefix ns "A") (genFreshPrefix ns "B") (genFreshPrefix ns "c")
            (genFreshPrefix ns "Q") (genFreshPrefix ns "P") (genFreshPrefix ns "R")
            (genFreshPrefix ns "r")
            (genFreshPrefix ns "x") (genFreshPrefix ns "y") (genFreshPrefix ns "z")
            (preprocessDesc d).

let DefineInd (d : Desc) : Eval Unit :=
  ψ ns = genFreshD/ns d : List Name.
  DefineInd' (genFreshPrefix ns "h") (genFreshPrefix ns "P") (genFreshPrefix ns "x")
             (preprocessDesc d).
