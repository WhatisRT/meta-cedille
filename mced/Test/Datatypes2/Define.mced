--------------------------------------------------------------------------------
-- General purpose

elet mkTyLI (d : Desc) (n : Name) (tel : Telescope) (T, t : Term) : LetInfo :=
  mkLetInfoWithTel n (app ?_ (DescTel d) tel) t (just ?_ T).

elet appDescTel (d : Desc) (t : Term) : Term :=
  appLTerm t $ telescopeToApp (DescTel d).

elet genTerm (d : Desc) (n : Desc -> Name) : Term := appDescTel d (var $ n d).

-- mkTYLICast?

--------------------------------------------------------------------------------
-- F

elet FName (d : Desc) : Name := φ"${DescName d}F".
elet FTerm (d : Desc) : Term := genTerm d FName.
elet FTerm' (d : Desc) (t : Term) (tel : Telescope) : Term :=
  applyTelescope (θ{γ{FTerm d} γ{t}}) tel.

elet FTel' (qn, rn : Name) : List CDesc -> Telescope :=
  map ?_ ?_ (λ c : CDesc. false, φ"${CDescName c}X", CDescToTy qn rn c).

elet FTel (qn, rn : Name) (d : Desc) : Telescope :=
  (true, qn, genDescTy d) ∷ FTel' qn rn (DescCs d).

elet DescToF (qn, rn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (FName d) (app ?_ [Param|(false, rn, genDescTy d)] (ixTel d)) θ{*}
    (foldWithPi (FTel qn rn d) (applyTelescope (var qn) (ixTel d))).

--------------------------------------------------------------------------------
-- F Constructors

elet FCtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}F".
elet FCtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (FCtorName c).

elet DescToFCtor (qn, rn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel rn c : Telescope.
  mkTyLI d (FCtorName c d) ((true, rn, genDescTy d) ∷ cArgTel)
    (CDescApp' θ{γ{FTerm d} γ{var rn}} c)
    (foldWithLambdas (FTel qn rn d) $ applyTelescope (var φ"${CDescName c}X") cArgTel).

elet DescToFCtors (qn, rn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToFCtor qn rn d) (DescCs d).

--------------------------------------------------------------------------------
-- WkIndF

elet appCtor (rn : Name) (d : Desc) (c : CDesc) : Term :=
  applyTelescope (FCtorTerm c d) ((true, rn, genDescTy d) ∷ cArgTel rn c).

elet CDescToTyP (rn, pn : Name) (d : Desc) (c : CDesc) : Term :=
  foldWithPi (cArgTel rn c) θ{γ{appLTerm (var pn) (map ?_ ?_ mkAppU (CDescApp c))} γ{appCtor rn d c}}.

elet WkIndFName (d : Desc) : Name := φ"WkInd${DescName d}F".
elet WkIndFTerm (d : Desc) : Term := genTerm d WkIndFName.
elet WkIndFTerm' (d : Desc) (t : Term) (tel : Telescope) : Term :=
  applyTelescope (θ{γ{WkIndFTerm d} γ{t}}) tel.

elet WkIndTel (rn, pn : Name) (d : Desc) : Telescope :=
  (true, pn, foldWithPi (snoc ?_ (ixTel d) (false, "", FTerm' d (var rn) (ixTel d))) θ{*}) ∷ map ?_ ?_
    (λ c : CDesc. false, φ"${CDescName c}P", CDescToTyP rn pn d c)
    (DescCs d).

elet WkIndF (rn, rn', pn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (WkIndFName d)
    (snoc ?_ ((false, rn, genDescTy d) ∷ (ixTel d)) (false, rn', FTerm' d (var rn) (ixTel d)))
    θ{*}
    (foldWithPi (WkIndTel rn pn d) θ{γ{applyTelescope (var pn) (ixTel d)} γ{var rn'}}).

--------------------------------------------------------------------------------
-- WkIndF Constructors

elet WkIndFCtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}WkIndF".
elet WkIndFCtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (WkIndFCtorName c).

elet DescToWkIndCtor (rn, pn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  mkTyLI d (WkIndFCtorName c d) ((true, rn, genDescTy d) ∷ cArgTel rn c)
    θ{γ{CDescApp' θ{γ{WkIndFTerm d} γ{var rn}} c} γ{appCtor rn d c}}
    (foldWithLambdas (WkIndTel rn pn d) $ applyTelescope (var φ"${CDescName c}P") (cArgTel rn c)).

elet DescToWkIndCtors (rn, pn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToWkIndCtor rn pn d) (DescCs d).

--------------------------------------------------------------------------------
-- Mono F

elet MonoFName (d : Desc) : Name := φ"mono${DescName d}F".
elet MonoFTerm (d : Desc) : Term := genTerm d MonoFName.

elet monoTel (an, bn, cn : Name) (tel : Telescope) : Telescope := [Param
  | (true, an, (foldWithPi tel θ{*}))
  ; (true, bn, (foldWithPi tel θ{*}))
  ; (false, cn, (foldWithPi tel θ{Cast γ{applyTelescope (var an) tel} γ{applyTelescope (var bn) tel}}))].

elet withMonoLams (an, bn, cn : Name) (tel : Telescope) (t : Term) : Term :=
  LambdaTerm an (foldWithPi tel θ{*}) $ LambdaTerm bn (foldWithPi tel θ{*}) $
  lambdaTerm cn (foldWithPi tel θ{Cast γ{applyTelescope (var an) tel} γ{applyTelescope (var bn) tel}}) t.

elet MonoF (qn, an, bn, cn, xn : Name) (d : Desc) : LetInfo :=
  ψ ftel = FTel qn bn d : Telescope.
  ψ conv = λ n : Name. applyTelescope (var n) (ixTel d) : Name -> Term.
  mkTyLI d (MonoFName d) [Param|]
    θ{γ{IMonoType d} γ{FTerm d}} $
    foldWithLambdas (app ?_ (monoTel an bn cn (ixTel d)) (ixTel d)) $
    genCast (FTerm' d (var an) (ixTel d)) (FTerm' d (var bn) (ixTel d)) xn $
      foldWithLambdas ftel $ appLTerm (var xn) $
        mkAppE (var qn) ∷ castApp (var an) (var bn) (var cn) (telNames (tail ?_ ftel)) d.

--------------------------------------------------------------------------------
-- Mono WkIndF

-- TODO: cleanup

elet MonoWkIndFName (d : Desc) : Name := φ"mono${WkIndFName d}".
elet MonoWkIndFTerm (d : Desc) : Term := genTerm d MonoWkIndFName.

elet MonoWkIndF (pn, an, bn, cn, xn, yn, zn : Name) (d : Desc) : LetInfo :=
  ψ ftel = WkIndTel bn pn d : Telescope.
  ψ elimMono = genElimMonoIx (var an) (var bn) (var cn) (ixTel d) (λ t : Term. FTerm' d t (ixTel d)) (MonoFTerm d)
    : Term -> Term.
  mkTyLI d (MonoWkIndFName d)
    (concat ?Param [Telescope| monoTel an bn cn (ixTel d)
                             ; ixTel d
                             ; [Param|(false, yn, FTerm' d (var an) (ixTel d))]])
    θ{Cast (γ{WkIndFTerm' d (var an) (ixTel d)} γ{var yn})
           (γ{WkIndFTerm' d (var bn) (ixTel d)} γ{elimMono $ var yn})}
    (genCast θ{γ{WkIndFTerm' d (var an) (ixTel d)} γ{var yn}}
             θ{γ{WkIndFTerm' d (var bn) (ixTel d)} γ{elimMono $ var yn}} xn $
     foldWithLambdas ftel $ appLTerm (var xn) $
       mkAppE (foldWithLambdas (snoc ?_ (ixTel d) (false, zn, (FTerm' d (var an) (ixTel d)))) $
                 θ{γ{applyTelescope (var pn) (ixTel d)} γ{elimMono $ var zn}}) ∷
       castApp (var an) (var bn) (var cn) (telNames (tail ?_ ftel)) d).

--------------------------------------------------------------------------------
-- FI & mono FI

elet FIName (d : Desc) : Name := φ"${DescName d}FI".
elet FITerm (d : Desc) : Term := genTerm d FIName.

elet FILI (rn : Name) (d : Desc) : LetInfo :=
  mkTyLI d (FIName d) ((false, rn, genDescTy d) ∷ ixTel d) θ{*}
    θ{Iota γ{FTerm' d (var rn) (ixTel d)} γ{WkIndFTerm' d (var rn) (ixTel d)}}.

elet MonoFIName (d : Desc) : Name := φ"mono${DescName d}FI".
elet MonoFITerm (d : Desc) : Term := genTerm d MonoFIName.

-- elet MonoFILI (d : Desc) : LetInfo :=
--   mkTyLI d (MonoFIName d) [Param|] θ{Mono γ{FITerm d}}
--     θ{iotaMono γ{FTerm d} γ{WkIndFTerm d} γ{MonoFTerm d} γ{MonoWkIndFTerm d}}.

elet MonoFILI (cn, xn, yn, zn : Name) (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  ψ genElimMono = λ S, T, cast : Term. λ f : Term -> Term. λ monoT, t : Term.
    θ{elimCast ?γ{f S} ?γ{f T} ?γ{appIxTel θ{γ{monoT} ?γ{S} ?γ{T} γ{cast}}} γ{t}}
    : Term -> Term -> Term -> (Term -> Term) -> Term -> Term -> Term.
  ψ pr1 = θ{iPr1 ?γ{FTerm' d (var xn) (ixTel d)} ?γ{WkIndFTerm' d (var xn) (ixTel d)} γ{var zn}} : Term.
  ψ pr2 = θ{iPr2 ?γ{FTerm' d (var xn) (ixTel d)} ?γ{WkIndFTerm' d (var xn) (ixTel d)} γ{var zn}} : Term.
  ψ convPr1 = genElimMono (var xn) (var yn) (var cn)
      (λ t : Term. FTerm' d t (ixTel d)) (MonoFTerm d) pr1 : Term.
  mkTyLI d (MonoFIName d) [Param|] θ{γ{IMonoType d} γ{FITerm d}} $
    foldWithLambdas ((true, xn, genDescTy d) ∷ (true, yn, genDescTy d) ∷
                     (false, cn, θ{γ{ICastType d} γ{var xn} γ{var yn}}) ∷ ixTel d) $
      genCast (appIxTel θ{γ{FITerm d} γ{var xn}}) (appIxTel θ{γ{FITerm d} γ{var yn}}) zn $
        θ{iPair ?γ{FTerm' d (var yn) (ixTel d)} ?γ{WkIndFTerm' d (var yn) (ixTel d)}
          γ{convPr1}
          (elimCast ?(γ{WkIndFTerm' d (var xn) (ixTel d)} γ{pr1})
                    ?(γ{WkIndFTerm' d (var yn) (ixTel d)} γ{convPr1})
                    ?(γ{appIxTel θ{γ{MonoWkIndFTerm d} ?γ{var xn} ?γ{var yn} γ{var cn}}} γ{pr1})
                    γ{pr2})
          (beta ?γ{appIxTel θ{γ{FITerm d} γ{var xn}}} γ{var zn})}.

--------------------------------------------------------------------------------
-- Main type

elet TyName (d : Desc) : Name := DescName d.
elet TyTerm (d : Desc) : Term := genTerm d TyName.
elet TyTermP (d : Desc) (tel : Telescope) : Term := θ{γ{applyTelescope (TyTerm d) tel} -> *}.
elet TyTermP' (d : Desc) : Term := foldWithPi (ixTel d) $ TyTermP d (ixTel d).


elet RollName (d : Desc) : Name := φ"roll${TyName d}".
elet RollTerm (d : Desc) : Term := genTerm d RollName.

elet UnrollName (d : Desc) : Name := φ"unroll${TyName d}".
elet UnrollTerm (d : Desc) : Term := genTerm d UnrollName.

elet TyLI (d : Desc) : LetInfo :=
  mkTyLI d (TyName d) [Param|] (genDescTy d) θ{γ{IRecType d} γ{FITerm d}}.

elet RollLI (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  mkTyLI d (RollName d) [Param|]
    (foldWithPi (ixTel d) θ{γ{appIxTel θ{γ{FITerm d} γ{TyTerm d}}} -> γ{appIxTel (TyTerm d)}})
    θ{γ{IRollType d} γ{FITerm d} ?γ{MonoFITerm d}}.

elet UnrollLI (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  mkTyLI d (UnrollName d) [Param|]
    (foldWithPi (ixTel d) θ{γ{appIxTel (TyTerm d)} -> γ{appIxTel θ{γ{FITerm d} γ{TyTerm d}}}})
    θ{γ{IUnrollType d} γ{FITerm d} ?γ{MonoFITerm d}}.

--------------------------------------------------------------------------------
-- Constructors

elet CtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}".
elet CtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (CtorName c).

elet DescToCtor/appCtor (d : Desc) (c : CDesc) (t : Term) : Term := appLTerm t $
  mkAppE (TyTerm d) ∷ map ?_ ?_ (λ n : Name. mkAppU $ var n) $ telNames (cArgTel (TyName d) c).

elet DescToCtor (d : Desc) (c : CDesc) : LetInfo :=
  ψ appCtor = DescToCtor/appCtor d c : Term -> Term.
  ψ fCtor = appCtor (FCtorTerm c d) : Term.
  mkTyLI d (CtorName c d) (cArgTelTerm (TyTerm d) (CDescAs c)) (CDescApp' (TyTerm d) c)
    θ{γ{CDescApp' (RollTerm d) c} $ iPair ?γ{CDescApp' θ{γ{FTerm d} γ{TyTerm d}} c}
                                          ?γ{CDescApp' θ{γ{WkIndFTerm d} γ{TyTerm d}} c}
        γ{fCtor} γ{appCtor (WkIndFCtorTerm c d)}
        (beta ?γ{CDescApp' θ{γ{FTerm d} γ{TyTerm d}} c} γ{fCtor})}.

elet DescToCtors (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtor d) (DescCs d).

--------------------------------------------------------------------------------
-- LR

elet RecName (d : Desc) : Name := φ"${DescName d}Rec".
elet RecTerm (d : Desc) : Term := genTerm d RecName.

elet RecLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel = map ?_ ?_ (λ n : Name. (false, "", var n)) ns : Telescope.
  mkTyLI d (RecName d)
    (app ?_ (ixTel d) ((false, pn, TyTermP d (ixTel d))
       ∷ (false, xn, applyTelescope (TyTerm d) (ixTel d)) ∷ typesTel false ns)) θ{*} $
    foldWithPi (app ?_ tel tel) $ θ{γ{var pn} γ{var xn}}.

elet CtorFName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}RecF".
elet CtorFTerm (c : CDesc) (d : Desc) : Term := genTerm d (CtorFName c).

elet DescToCtorF (pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel = map ?_ ?_ (λ n : Name. (false, "", var n)) ns : Telescope.
  ψ P   = lambdaTerm xn (appIxTel $ TyTerm d) $ appLTerm (appIxTel $ RecTerm d)
    (mkAppU (appIxTel $ var pn) ∷ map ?_ ?_ (λ n : Name. mkAppU (var n)) (xn ∷ ns)) : Term.
  mkTyLI d (CtorFName c d) [Param|(false, pn, TyTermP' d)] θ{*} $
    foldWithPi (typesTel true ns) $ castCtorPi
      (foldWithLambdas (ixTel d) θ{Iota γ{appIxTel $ TyTerm d} γ{P}})
      (TyTerm d)
      (foldWithLambdas (ixTel d) θ{castIota ?γ{appIxTel (TyTerm d)} ?γ{P}})
      (λ a : List App. foldWithPi tel θ{γ{CDescApp' (var pn) c} γ{appLTerm (CtorTerm c d) a}}) c.

elet DescToCtorFs (pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtorF pn xn d) (DescCs d).

elet ctorFTerms (pn : Name) (d : Desc) : List Term :=
  map ?_ ?_ (λ c : CDesc. CtorFTerm c d) (DescCs d).

elet LRPName (d : Desc) : Name := φ"${DescName d}LRP".
elet LRPTerm (d : Desc) : Term := genTerm d LRPName.

elet LRPLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  mkTyLI d (LRPName d) (snoc ?_ (ixTel d) (false, xn, appIxTel (TyTerm d))) θ{*} $
    forallTerm pn (TyTermP' d) $ appLTerm (RecTerm d) $ app ?_ (telescopeToApp $ ixTel d)
      (mkAppU (appIxTel (var pn)) ∷ mkAppU (var xn) ∷
        map ?_ ?_ (λ t : Term. mkAppU θ{γ{t} γ{var pn}}) (ctorFTerms pn d)).

elet LRName (d : Desc) : Name := φ"${DescName d}LR".
elet LRTerm (d : Desc) : Term := genTerm d LRName.

elet LRLI (d : Desc) : LetInfo :=
  mkTyLI d (LRName d) (ixTel d) θ{*} θ{Iota γ{applyTelescope (TyTerm d) (ixTel d)} γ{applyTelescope (LRPTerm d) (ixTel d)}}.

--------------------------------------------------------------------------------
-- Cast to LR

elet LRCtorName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}LR".
elet LRCtorTerm (c : CDesc) (d : Desc) : Term := genTerm d (LRCtorName c).

elet ctorFsTel (pn : Name) (d : Desc) : Telescope :=
  map ?_ ?_ (λ c : CDesc. (false, φ"${CDescName c}X", θ{γ{CtorFTerm c d} γ{var pn}})) (DescCs d).

elet ctorFsTel' (d : Desc) : Telescope :=
  map ?_ ?_ (λ c : CDesc. (false, φ"${CDescName c}X", LRCtorTerm c d)) (DescCs d).

elet LR'Term2 (pn, xn : Name) (d : Desc) : Term :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  lambdaTerm xn (appIxTel (TyTerm d)) $ appLTerm (appIxTel (RecTerm d)) $
      map ?_ ?_ mkAppU $ (appIxTel $ var pn) ∷ var xn ∷ telTypes (ctorFsTel pn d).

elet LR'Term (pn, xn : Name) (d : Desc) : Term :=
  θ{Iota γ{applyTelescope (TyTerm d) (ixTel d)} γ{LR'Term2 pn xn d}}.

elet castLRtoLR'Name (d : Desc) : Name := φ"${DescName d}CastLRtoLR'".
elet castLRtoLR'Term (d : Desc) : Term := genTerm d castLRtoLR'Name.

elet CastLRtoLR'LI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  mkTyLI d (castLRtoLR'Name d) [Param|(true, pn, TyTermP' d)]
    θ{γ{ICastType d} γ{LRTerm d} γ{foldWithLambdas (ixTel d) $ LR'Term pn xn d}} $
    foldWithLambdas (ixTel d) $
    θ{intrCast ?γ{appIxTel (LRTerm d)} ?γ{LR'Term pn xn d}
      ?γ{lambdaTerm xn (appIxTel $ LRTerm d) $ mkIPair (appIxTel (TyTerm d)) (LR'Term2 pn xn d)
        θ{iPr1 ?γ{appIxTel (TyTerm d)} ?γ{appIxTel (LRPTerm d)} γ{var xn}}
        θ{iPr2 ?γ{appIxTel (TyTerm d)} ?γ{appIxTel (LRPTerm d)} γ{var xn} ?γ{var pn}}}
      ?(beta ?γ{appIxTel (LRTerm d)})}.

elet DescToLRCtor (pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  mkTyLI d (LRCtorName c d) (cArgTelTerm (LRTerm d) (CDescAs c)) (CDescApp' (LRTerm d) c) $
    mkIPair (CDescApp' (TyTerm d) c) (CDescApp' (LRPTerm d) c)
      (castCtorApp (LRTerm d) (TyTerm d)
        (foldWithLambdas (ixTel d) θ{castIota ?γ{appIxTel (TyTerm d)}
                                              ?γ{appIxTel (LRPTerm d)}}) (CtorTerm c d) c)
      (LambdaTerm pn (foldWithPi (ixTel d) $ TyTermP d (ixTel d)) $ foldWithLambdas (ctorFsTel pn d) $
        appLTerm (var φ"${CDescName c}X") $ app ?App (map ?_ ?_ mkAppE $ telTypes (ctorFsTel pn d)) $
          CDescToCastApp (LRTerm d) (foldWithLambdas (ixTel d) $ LR'Term pn xn d) θ{γ{castLRtoLR'Term d} ?γ{var pn}} c).

elet DescToLRCtors (pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToLRCtor pn xn d) (DescCs d).

elet convCtorTel (T : Term) (t : List App -> Term) (c : CDesc) : Term :=
  ψ tel = cArgTelTerm T (CDescAs c) : Telescope.
  foldWithLambdas tel $ t $ map ?_ ?_ (λ n : Name. mkAppU $ var n) $ telNames tel.

elet RollLRName (d : Desc) : Name := φ"roll${DescName d}LR".
elet RollLRTerm (d : Desc) : Term := genTerm d RollLRName.

elet RollLR (xn : Name) (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  ψ FLRTerm  = appIxTel θ{γ{FTerm d}  γ{LRTerm d}} : Term.
  ψ FILRTerm = appIxTel θ{γ{FITerm d} γ{LRTerm d}} : Term.
  ψ genPr = λ n : Name. λ a : List App. lambdaTerm xn FILRTerm $ appLTerm (var n) $ app ?_
      [App|mkAppE FLRTerm; mkAppE (appIxTel θ{γ{WkIndFTerm d} γ{LRTerm d}}); mkAppU (var xn)] a
      : Name -> List App -> Term.
  ψ a = mkAppE (LRTerm d) ∷ map ?_ ?_ mkAppU $ telTypes (ctorFsTel' d) : List App.
  mkTyLI d (RollLRName d) [Param|] θ{γ{ICastType d} (γ{FITerm d} γ{LRTerm d}) γ{LRTerm d}} $
    foldWithLambdas (ixTel d) $
    θ{intrCast ?γ{FILRTerm} ?γ{applyTelescope (LRTerm d) (ixTel d)}
      ?γ{genPr "iPr1" a}
      ?γ{genPr "iPr2" (mkAppE (foldWithLambdas (ixTel d) $ lambdaTerm xn FLRTerm
          θ{UEq ?γ{appIxTel (LRTerm d)} ?γ{FLRTerm} γ{appLTerm (var xn) a} γ{var xn}}) ∷
          map ?_ ?_ (λ c : CDesc. mkAppU $ convCtorTel (LRTerm d) (λ ap : List App.
              θ{beta ?γ{CDescApp' θ{γ{FTerm d} γ{LRTerm d}} c} γ{appLTerm (FCtorTerm c d) (mkAppE (LRTerm d) ∷ ap)}}) c)
            (DescCs d))}}.

elet ToLRName (d : Desc) : Name := φ"to${DescName d}LR".
elet ToLRTerm (d : Desc) : Term := genTerm d ToLRName.

elet ToLRLI (d : Desc) : LetInfo :=
  mkTyLI d (ToLRName d) [Param|]
    θ{γ{ICastType d} γ{TyTerm d} γ{LRTerm d}}
    θ{γ{IRecLBType d} γ{FITerm d} ?γ{LRTerm d} ?γ{RollLRTerm d}}.

--------------------------------------------------------------------------------
-- Induction proofs

elet RecFPfName (c : CDesc) (d : Desc) : Name := φ"${CDescName c}RecFPf".
elet RecFPfTerm (c : CDesc) (d : Desc) : Term := genTerm d (RecFPfName c).

elet PListPTel (d : Desc) : Telescope := [Param|(true, "PList", θ{List γ{TyTerm d} -> *})].

elet PListHTel (P : Term) (d : Desc) : Telescope :=
  ψ P' = var "PList" : Term.
  [Param|(false, "p'n", θ{γ{P'} (nil ?γ{TyTerm d})})
        ;(false, "p'c", piTerm "pc1"         (TyTerm d)  θ{γ{P}  γ{var "pc1"}
                   -> γ{piTerm "pc2" θ{List γ{TyTerm d}} θ{γ{P'} γ{var "pc2"}
                   -> γ{P'} (cons ?γ{TyTerm d} γ{var "pc1"} γ{var "pc2"})}}})].

elet ADescAddP (d : Desc) (ad : ADesc) : Telescope :=
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ _ : Term. [Param|])
    (λ _ : List Term. [Param|])
    (λ _ : Term × Term. PListPTel d)
    (adTDesc ad).

elet mkPTel' (d : Desc) (c : CDesc) : Telescope :=
  concat ?_ $ map ?_ ?_ (ADescAddP d) (CDescAs c).

elet mkPTel (pn : Name) (d : Desc) (c : CDesc) : Telescope :=
  ψ additional = mkPTel' d c : Telescope.
  (true, pn, (foldWithPi (ixTel d) $ TyTermP d (ixTel d))) ∷ additional.

elet ADescAddH (d : Desc) (P : Term) (ad : ADesc) : Telescope :=
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ _ : Term. [Param|])
    (λ _ : List Term. [Param|])
    (λ _ : Term × Term. PListHTel P d)
    (adTDesc ad).

elet TDescP' (a : TDesc) (n : Name) (t, P, P', r : Term) : Term :=
  piTerm n (TDescF a t) $ recursionTripleSum ?_ ?_ ?_ ?_
    (λ _  : Term. r)
    (λ ts : List Term. θ{γ{appLTerm P (map ?_ ?_ mkAppU ts)} γ{var n} -> γ{r}})
    (λ ts : Term × Term. θ{γ{P'} γ{var n} -> γ{r}})
    a.

elet mkHTel (pn : Name) (d : Desc) (c : CDesc) : Telescope :=
  ψ additional = concat ?_ $ map ?_ ?_ (ADescAddH d (var pn)) (CDescAs c) : Telescope.
  ψ t = foldl ?_ ?_
          (λ acc : Term. λ a : ADesc.
            TDescP' (adTDesc a) (adName a) (TyTerm d) (var pn) (var "PList") acc)
          (CDescAs c)
          θ{γ{CDescApp' (var pn) c} γ{appLTerm (CtorTerm c d) (cArgApp c)}}
      : Term.
  (false, φ"h${CDescName c}", t) ∷ additional.

elet DescToIndPf/genIotaArgs (d : Desc) (P : Term) (recApp : List App) (td : TDesc) : Term × Term :=
  ψ appIxs = λ u : Term. recursionTripleSum ?_ ?_ ?_ ?_
    (λ t  : Term. t)
    (λ ts : List Term. appLTerm u (map ?_ ?_ mkAppU ts))
    (λ ts : Term × Term. u)
    td : Term -> Term.
  (appIxs (TyTerm d),
    lambdaTerm "x" (appIxs $ TyTerm d) $ appLTerm (appIxs $ RecTerm d) (mkAppU (appIxs P) ∷ mkAppU (var "x") ∷ recApp)).

elet DescToIndPf/genLam (d : Desc) (P : Term) (recApp : List App) (ad : ADesc) : Term :=
  ψ genIotaArgs = DescToIndPf/genIotaArgs d P recApp (adTDesc ad) : Term × Term.
  ψ recTy = θ{Iota γ{pr1 ?_ ?_ genIotaArgs} γ{pr2 ?_ ?_ genIotaArgs}} : Term.
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ t  : Term. t)
    (λ _  : List Term. recTy)
    (λ ts : Term × Term. θ{γ{pr1 ?Term ?Term ts} γ{recTy}})
    (adTDesc ad).

elet DescToIndPf/genApp (d : Desc) (P : Term) (recApp, recApp', extraHs : List App) (n : Name)
  (ad : ADesc) : List App :=
  ψ genIotaArgs = DescToIndPf/genIotaArgs d P recApp (adTDesc ad) : Term × Term.
  ψ genIotaArgs1 = pr1 ?_ ?_ genIotaArgs : Term.
  ψ genIotaArgs2 = pr2 ?_ ?_ genIotaArgs : Term.
  ψ genPr = λ t : Term. λ a : List App. appLTerm t $ mkAppE genIotaArgs1 ∷ mkAppE genIotaArgs2 ∷ a
    : Term -> List App -> Term.
  ψ convRec = λ n' : Name. genPr θ{iPr2} (mkAppU (var n') ∷ app ?_ recApp' recApp') : Name -> Term.
  ψ iota = θ{Iota γ{genIotaArgs1} γ{genIotaArgs2}} : Term.
  ψ cIota = θ{castIota ?γ{genIotaArgs1} ?γ{genIotaArgs2}} : Term.
  ψ convApp = θ{indHelperList/conv ?γ{iota} ?γ{TyTerm d} ?γ{cIota} γ{var n}} : Term.
  ψ convPf = θ{γ{appLTerm θ{indHelperList ?γ{iota} ?γ{TyTerm d} ?γ{cIota} ?γ{P}
                              γ{lambdaTerm "xi" iota $ convRec "xi"} ?PList} extraHs}
    γ{var n}} : Term.
  recursionTripleSum ?_ ?_ ?_ ?_
    (λ t : Term. [App|mkAppU $ var n])
    (λ _ : List Term. [App| mkAppU $ genPr θ{iPr1} [App|mkAppU $ var n]
                          ; mkAppU $ convRec n])
    (λ _ : Term × Term. [App|mkAppU convApp; mkAppU convPf])
    (adTDesc ad).

elet DescToIndPf (hn, pn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ len = length ?_ (DescCs d) : Nat.
  ψ recApp = appNames false (mkNames "A" len) : List App.
  ψ recTel = zipWith ?_ ?_ ?_ (λ n, n' : Name. (false, n, var n'))
                              (mkNames "a" len) (mkNames "A" len) : Telescope.
  mkTyLI d (RecFPfName c d)
    (app ?Param (mkPTel pn d c) (mkHTel pn d c))
    θ{γ{CtorFTerm c d} γ{var pn}}
    (foldWithLambdas (typesTel true (mkNames "A" len)) $
     foldWithLambdas (map ?_ ?_ (λ a : ADesc.
       (false, adName a, DescToIndPf/genLam d (var pn) recApp a)) (CDescAs c)) $
     foldWithLambdas recTel $
     appLTerm (var φ"h${CDescName c}") (concat ?App $ map ?_ ?_
       (λ a : ADesc. DescToIndPf/genApp d (var pn) recApp (telescopeToApp recTel)
         (telescopeToApp (PListHTel (var pn) d)) (adName a) a) (CDescAs c))).

elet DescToIndPfs (hn, pn, xn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToIndPf hn pn xn d) (DescCs d).

--------------------------------------------------------------------------------
-- Induction schemes

elet RecLRName (d : Desc) : Name := φ"rec${DescName d}LR".
elet RecLRTerm (d : Desc) : Term := genTerm d RecLRName.

elet IndName (d : Desc) : Name := φ"ind${DescName d}".
elet IndTerm (d : Desc) : Term := genTerm d IndName.

elet RecLRLI (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  ψ tel = zipWithIndex ?_ ?_ (λ i : Nat. λ t : Term. (false, φ"a${showNatDecimal i}", θ{γ{t} γ{var pn}}))
    (ctorFTerms pn d) : Telescope.
  ψ a = [App|mkAppE $ appIxTel $ TyTerm d; mkAppE $ appIxTel $ LRPTerm d; mkAppU $ var xn] : List App.
  mkTyLI d (RecLRName d)
    (app ?_ (ixTel d)
      ((true, pn, foldWithPi (ixTel d) $ TyTermP d (ixTel d)) ∷ (false, xn, appIxTel (LRTerm d)) ∷ tel))
    (foldWithPi tel θ{γ{appIxTel $ var pn} γ{appLTerm θ{iPr1} a}})
    (appLTerm θ{iPr2} $ app ?App a $ mkAppE (var pn) ∷
      map ?_ ?_ (λ n : Name. mkAppU $ var n) (telNames tel)).

elet DefineIndScheme/genPfApp (pn : Name) (d : Desc) (c : CDesc) : Term :=
  ψ pApp = telescopeToApp $ (true, pn, TyTermP d (ixTel d)) ∷ mkPTel' d c : List App.
  ψ genExtraApp = λ a : ADesc. telescopeToApp (ADescAddH d (var pn) a) : ADesc -> List App.
  ψ extra = concat ?_ $ map ?_ ?_ genExtraApp (CDescAs c) : List App.
  appLTerm (RecFPfTerm c d) $
    concat ?_ [List App|pApp; [App| mkAppU $ var φ"h${CDescName c}"]; extra].

elet DefineIndScheme (pn, xn : Name) (d : Desc) : LetInfo :=
  ψ appIxTel = λ t : Term. applyTelescope t (ixTel d) : Term -> Term.
  ψ pTel = (true, pn, foldWithPi (ixTel d) $ TyTermP d (ixTel d)) ∷ concat ?_ (map ?_ ?_ (mkPTel' d) (DescCs d)) : Telescope.
  ψ hTel = concat ?_ $ map ?_ ?_ (mkHTel pn d) (DescCs d) : Telescope.
  ψ pfApp = map ?_ ?_ (λ c : CDesc. mkAppU $ DefineIndScheme/genPfApp pn d c) (DescCs d) : List App.
  mkTyLI d (IndName d)
    (concat ?Param [Telescope| pTel; hTel; ixTel d; [Param|(false, xn, appIxTel $ TyTerm d)]])
    θ{γ{appIxTel $ var pn} γ{var xn}}
    (appLTerm (appIxTel (RecLRTerm d)) $
      (mkAppE (var pn)) ∷ (mkAppU θ{elimCast ?γ{appIxTel $ TyTerm d} ?γ{appIxTel $ LRTerm d} ?γ{appIxTel $ ToLRTerm d} γ{var xn}}) ∷
      app ?App pfApp pfApp).

--------------------------------------------------------------------------------
-- Define All

elet DefineTy' (an, bn, cn, pn, qn, rn, rn', xn, yn, zn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ concat ?_ [List LetInfo
    | [LetInfo| DescToF qn rn d ]
    ; DescToFCtors qn rn d
    ; [LetInfo| WkIndF rn rn' pn d ]
    ; DescToWkIndCtors rn pn d
    ; [LetInfo| MonoF qn an bn cn xn d ; MonoWkIndF pn an bn cn xn yn zn d
              ; FILI rn d ; MonoFILI cn xn yn zn d ; TyLI d ; RollLI d ; UnrollLI d ]
    ; DescToCtors d
    ; [LetInfo| RecLI pn xn d ]
    ; DescToCtorFs pn xn d
    ; [LetInfo| LRPLI pn xn d ; LRLI d ; CastLRtoLR'LI pn xn d ]
    ; DescToLRCtors pn xn d
    ; [LetInfo| RollLR xn d ; ToLRLI d ; RecLRLI pn xn d ]
    ].

elet DefineInd' (hn, pn, xn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ concat ?_ [List LetInfo
  | DescToIndPfs hn pn xn d
  ; [LetInfo| DefineIndScheme pn xn d ]
  ].

let DefineTy (d : Desc) : Eval Unit :=
  ψ ns = genFreshD/ns d : List Name.
  DefineTy' (genFreshPrefix ns "A") (genFreshPrefix ns "B") (genFreshPrefix ns "c")
            (genFreshPrefix ns "P") (genFreshPrefix ns "Q") (genFreshPrefix ns "R")
            (genFreshPrefix ns "r")
            (genFreshPrefix ns "x") (genFreshPrefix ns "y") (genFreshPrefix ns "z")
            (preprocessDesc d).

let DefineInd (d : Desc) : Eval Unit :=
  ψ ns = genFreshD/ns d : List Name.
  DefineInd' (genFreshPrefix ns "h") (genFreshPrefix ns "P") (genFreshPrefix ns "x")
             (preprocessDesc d).

--------------------------------------------------------------------------------
-- Define record projections

elet ProjLI (xn, yn : Name) (d : Desc) (c : CDesc) (a : ADesc) (prev : List ADesc) : LetInfo :=
  ψ appProj = λ n : Name. λ ad : ADesc. mkAppU θ{γ{appDescTel d (var φ"${adName ad}")} γ{var n}}
    : Name -> ADesc -> App.
  ψ goalTy = λ n : Name.
    appLTerm (foldWithLambdas (cArgTelTerm (TyTerm d) prev) $ TDescF (adTDesc a) (TyTerm d))
             (map ?_ ?_ (appProj n) prev)
    : Name -> Term.
  mkTyLI d φ"${adName a}"
    [Param|]
    (piTerm xn (TyTerm d) (goalTy xn))
    θ{γ{IndTerm d} ?γ{lambdaTerm yn (TyTerm d) (goalTy yn)}
        γ{foldWithLambdas (cArgTelTerm (TyTerm d) (CDescAs c)) (var φ"${adName a}")}}.

elet ProjLIs (xn, yn : Name) (d : Desc) (c : CDesc) : List LetInfo :=
  reverse ?_ $ recursionList ?_ ?_
    [LetInfo|]
    (λ a : ADesc. λ as : List ADesc. λ acc : List LetInfo. ProjLI xn yn d c a as ∷ acc)
    (reverse ?_ $ CDescAs c).

elet DefineProjLIs' (xn, yn : Name) (d : Desc) : Eval Unit :=
  matchList ?_ ?_ (throwEval ?Unit "BUG: DefineProj: not a record!")
    (λ c : CDesc. λ _ : List CDesc. defineMulti $ ProjLIs xn xn d c)
    (DescCs d).

elet DefineProjLIs (d : Desc) : Eval Unit :=
  ψ ns = genFreshD/ns d : List Name.
  ifthenelse ?_ (not $ natEq 1 (length ?_ $ DescCs d))
    (throwEval ?Unit "DefineProjLIs: not a record!")
    (DefineProjLIs' (genFreshPrefix ns "x") (genFreshPrefix ns "y") (preprocessDesc d)).
