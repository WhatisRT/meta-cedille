--------------------------------------------------------------------------------
-- Test syntax

elet init$newStmt'$data2Test^space^_multiTerm_=dot= (t : Term) : Eval Unit :=
  (modifyTermMod t >>= checkTerm Desc) >>= λ d : Desc.
  DefineHelpers d >> DefineTy d >> DefineInd d.

updateEval.

--------------------------------------------------------------------------------
-- List helpers

-- let monoList : Mono List := Λ X, Y : *. λ c : Cast X Y.
--   extCast ?(List X) ?(List Y) ?(indList ?X ?(λ l : List X. View (List Y) (beta' ?(List X) l))
--     (selfView ?(List Y) (nilC ?Y))
--     (λ x : X. λ xs : List X. λ pxs : View (List Y) (beta' ?(List X) xs).
--       selfView ?(List Y)
--         (consC ?Y (elimCast ?X ?Y ?c x) (elimView ?(List Y) (beta' ?(List X) xs) ?pxs)))).

-- elet indHelperList/conv [AP, A : *] [c : Cast AP A] : List AP -> List A :=
--   elimCast ?_ ?_ ?(monoList ?AP ?A c).

-- elet indHelperList [AP, A : *] [c : Cast AP A] [P : A -> *] (Pc : Π t : AP. P (elimCast ?AP ?A ?c t))
--   [P' : List A -> *] (pn : P' [A|]) (pc : Π t : A. P t -> Π ts : List A. P' ts -> P' (cons ?A t ts))
--   : Π l : List AP. P' (indHelperList/conv ?AP ?A ?c l) :=
--   ψ convN = usubst ?(List A) ?(indHelperList/conv ?AP ?A ?c [AP|]) ?[A|]
--       ?(beta ?(List A) [A|]) ?P' : P' [A|] -> P' (indHelperList/conv ?AP ?A ?c [AP|]).
--   indList ?AP ?(λ l : List AP. P' (indHelperList/conv ?AP ?A ?c l))
--     (convN pn)
--     (λ t : AP. λ ts : List AP. λ p' : P' (indHelperList/conv ?AP ?A ?c ts).
--      usubst ?(List A) ?(indHelperList/conv ?AP ?A ?c (cons ?AP t ts))
--        ?(cons ?A (elimCast ?AP ?A ?c t) (indHelperList/conv ?AP ?A ?c ts))
--        ?(beta ?(List A) (indHelperList/conv ?AP ?A ?c $ cons ?AP t ts)) ?P' $
--        pc (elimCast ?AP ?A ?c t) (Pc t) (indHelperList/conv ?AP ?A ?c ts) p').

--------------------------------------------------------------------------------
-- Tests

elet T5Desc : Desc := preprocessDesc ("TVec", [Param|false, "A", θ{*}], [Term|θ{Nat}],
  [CDesc| "tVecNil",  [ADesc|], [Term|θ{0}]
        ; "tVecCons", [ADesc|"k", tdNonRec θ{Nat}; adUnnamed (tdNonRec θ{A}); adUnnamed (tdRecNN [Term|θ{k}])], [Term|θ{suc k}]]).

elet TEvenDesc : Desc := preprocessDesc ("TEven", [Param|], [Term|θ{Nat}],
  [CDesc| "tEvenZ",  [ADesc|], [Term|θ{0}]
        ; "tEvenSS", [ADesc|"k", tdNonRec θ{Nat}; adUnnamed (tdRecNN [Term|θ{k}])], [Term|θ{suc (suc k)}]]).

elet TLeqDesc : Desc := preprocessDesc ("TLeq", [Param|], [Term|θ{Nat}; θ{Nat}],
  [CDesc| "zlek", [ADesc|"k", tdNonRec θ{Nat}], [Term|θ{0}; θ{k}]
        ; "sles", [ADesc|"k", tdNonRec θ{Nat}; "l", tdNonRec θ{Nat}; adUnnamed (tdRecNN [Term|θ{k}; θ{l}])], [Term|θ{suc k}; θ{suc l}]]).

data2Test T5Desc.
data2Test TEvenDesc.
data2Test TLeqDesc.

data2 TNat where
| tZero : TNat
| tSuc : TNat -> TNat.

data2 TNatList where
| tNatNil : TNatList
| tNatCons : Nat -> TNatList -> TNatList.

record2 TProd (A, B : *) where
| tPr1 : A
| tPr2 : B.

record2 TDSum' (A : *) (B : A -> *) where
| tDPr1 : A
| tDPr2 : B tDPr1.

data2 TList (A : *) where
| tNil : TList
| tCons : A -> TList -> TList.

data2 T1 where
| t11 : T1
| t12 : T1 -> T1 -> T1.

-- golden test
elet indT1Test : ∀ P : T1 -> *. P t11 -> (Π a0 : T1. P a0 -> Π a1 : T1. P a1 -> P (t12 a0 a1))
              -> Π x : T1. P x := indT1.

data2 T2 where
| t21 : Nat -> T2
| t22 : T2 -> T2 -> T2.

elet T3Desc : Desc := "T3", [Param|], [Term|],
  [CDesc| "t31", [ADesc|], [Term|]
        ; "t32", [ADesc|adUnnamed (tdRecN (θ{List}, θ{monoList}))], [Term|]].
data2Test T3Desc.

-- -- Non-strictly positive type

let T4Ty (X : *) : * := (X -> Bool) -> Bool.

elet monoT4Ty : Mono T4Ty :=
  Λ X, Y : *. λ c : Cast X Y. intrCast ?(T4Ty X) ?(T4Ty Y)
    ?(λ x : T4Ty X. λ y : Y -> Bool. x $ elimCast
      ?(Y -> Bool)
      ?(X -> Bool)
      ?(antiArr ?(λ Z : *. Z) ?(λ _ : *. Bool) monoId (antiConst ?Bool) ?X ?Y c)
      y)
    ?(beta ?(T4Ty X)).

elet T4Desc : Desc := "T4", [Param|], [Term|],
  [CDesc|"t4", [ADesc|adUnnamed (tdRecN (θ{T4Ty}, θ{monoT4Ty}))], [Term|]].
runMeta DefineHelpers T4Desc.
runMeta DefineTy T4Desc.
