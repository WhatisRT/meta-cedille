--------------------------------------------------------------------------------
-- Test syntax

elet init$newStmt'$data2Test^space^_multiTerm_=dot= (t : Term) : Eval Unit :=
  (modifyTermMod t >>= checkTerm Desc) >>= λ d : Desc.
  seqEval ?_ ?_ (DefineTy d) (DefineInd d).

updateEval.

--------------------------------------------------------------------------------
-- List helpers

let monoList : Mono List := Λ X, Y : *. λ c : Cast X Y.
  extCast ?(List X) ?(List Y) ?(indList ?X ?(λ l : List X. View (List Y) (beta' ?(List X) l))
    (selfView ?(List Y) (nilC ?Y))
    (λ x : X. λ xs : List X. λ pxs : View (List Y) (beta' ?(List X) xs).
      selfView ?(List Y)
        (consC ?Y (elimCast ?X ?Y ?c x) (elimView ?(List Y) (beta' ?(List X) xs) ?pxs)))).

elet indHelperList/conv [AP, A : *] [c : Cast AP A] : List AP -> List A :=
  elimCast ?_ ?_ ?(monoList ?AP ?A c).

elet indHelperList [AP, A : *] [c : Cast AP A] [P : A -> *] (Pc : Π t : AP. P (elimCast ?AP ?A ?c t))
  [P' : List A -> *] (pn : P' [A|]) (pc : Π t : A. P t -> Π ts : List A. P' ts -> P' (cons ?A t ts))
  : Π l : List AP. P' (indHelperList/conv ?AP ?A ?c l) :=
  ψ convN = usubst ?(List A) ?(indHelperList/conv ?AP ?A ?c [AP|]) ?[A|]
      ?(beta ?(List A) [A|]) ?P' : P' [A|] -> P' (indHelperList/conv ?AP ?A ?c [AP|]).
  indList ?AP ?(λ l : List AP. P' (indHelperList/conv ?AP ?A ?c l))
    (convN pn)
    (λ t : AP. λ ts : List AP. λ p' : P' (indHelperList/conv ?AP ?A ?c ts).
     usubst ?(List A) ?(indHelperList/conv ?AP ?A ?c (cons ?AP t ts))
       ?(cons ?A (elimCast ?AP ?A ?c t) (indHelperList/conv ?AP ?A ?c ts))
       ?(beta ?(List A) (indHelperList/conv ?AP ?A ?c $ cons ?AP t ts)) ?P' $
       pc (elimCast ?AP ?A ?c t) (Pc t) (indHelperList/conv ?AP ?A ?c ts) p').

--------------------------------------------------------------------------------
-- Tests

elet TNatDesc : Desc := "TNat", [Param|], [CDesc|"tZero", [ADesc|]; "tSuc", [ADesc|adRecNN]].
data2Test TNatDesc.

elet TNatListDesc : Desc := "TNatList", [Param|], [CDesc|"tNatNil", [ADesc|]; "tNatCons", [ADesc|adNonRec θ{Nat}; adRecNN]].
data2Test TNatListDesc.

elet TProdDesc : Desc := "TProd", [Param|(false, "F1", θ{*}); (false, "F2", θ{*})],
  [CDesc|"tPair", [ADesc|adNonRec θ{F1}; adNonRec θ{F2}]].
data2Test TProdDesc.

elet TListDesc : Desc := "TList", [Param|(false, "F", θ{*})], [CDesc|"tNil", [ADesc|]; "tCons" , [ADesc|adNonRec θ{F}; adRecNN]].
data2Test TListDesc.

elet T1Desc : Desc := "T1", [Param|], [CDesc|"t11", [ADesc|]; "t12", [ADesc|adRecNN; adRecNN]].
data2Test T1Desc.

-- golden test
elet indT1Test : ∀ P : T1 -> *. P t11 -> (Π a0 : T1. P a0 -> Π a1 : T1. P a1 -> P (t12 a0 a1))
              -> Π x : T1. P x := indT1.

elet T2Desc : Desc := "T2", [Param|], [CDesc|"t21", [ADesc|adNonRec θ{Nat}]; "t22", [ADesc|adRecNN; adRecNN]].
data2Test T2Desc.

elet T3Desc : Desc := "T3", [Param|], [CDesc|"t31", [ADesc|]; "t32", [ADesc|adRecN (θ{List}, θ{monoList})]].
data2Test T3Desc.

-- Non-strictly positive type

let T4Ty (X : *) : * := (X -> Bool) -> Bool.

elet monoT4Ty : Mono T4Ty :=
  Λ X, Y : *. λ c : Cast X Y. intrCast ?(T4Ty X) ?(T4Ty Y)
    ?(λ x : T4Ty X. λ y : Y -> Bool. x $ elimCast
      ?(Y -> Bool)
      ?(X -> Bool)
      ?(antiArr ?(λ Z : *. Z) ?(λ _ : *. Bool) monoId (antiConst ?Bool) ?X ?Y c)
      y)
    ?(beta ?(T4Ty X)).

elet T4Desc : Desc := "T4", [Param|], [CDesc|"t4", [ADesc|adRecN (θ{T4Ty}, θ{monoT4Ty})]].
runMeta DefineTy T4Desc.
