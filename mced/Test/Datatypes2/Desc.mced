--------------------------------------------------------------------------------
-- Descriptions of inductive datatypes
--------------------------------------------------------------------------------

-- Currently missing:
-- - Parameters
-- - Indices
-- - PIs in constructors
-- - Function arguments to constructors
-- - Recursion schemes
-- - Match schemes

--------------------------------------------------------------------------------
-- Argument description

let ADesc := Term         -- non-recursive
           ⊎ Unit         -- recursive, not nested
           ⊎ Term × Term. -- recursive, nested

let adNonRec (t : Term)       : ADesc := inl ?Term ?(Unit ⊎ Term × Term) t.
let adRecNN                   : ADesc := inr ?Term ?(Unit ⊎ Term × Term) (inl ?Unit ?(Term × Term) tt).
let adRecN (ts : Term × Term) : ADesc := inr ?Term ?(Unit ⊎ Term × Term) (inr ?Unit ?(Term × Term) ts).

elet TyConst (T : *) : * -> * := λ _ : *. T.
elet TyId : * -> * := λ R : *. R.

elet ADescTy : ADesc -> Term := recursionTripleSum ?_ ?_ ?_ ?_
  (λ t : Term. θ{TyConst γ{t}})
  (λ _ : Unit. θ{TyId})
  (pr1 ?Term ?Term).

elet ADescF (a : ADesc) (t : Term) : Term := recursionTripleSum ?_ ?_ ?_ ?_
  (λ t' : Term. t')
  (λ _  : Unit. t)
  (λ ts : Term × Term. θ{γ{pr1 ?Term ?Term ts} γ{t}})
  a.

-- TODO: P' should come from ADesc
-- Variations of Π n : T. (P n) -> ...
elet ADescP (a : ADesc) (n : Name) (t, P, P', r : Term) : Term :=
  piTerm n (ADescF a t) $ recursionTripleSum ?_ ?_ ?_ ?_
    (λ _  : Term. r)
    (λ _  : Unit. θ{γ{P} γ{var n} -> γ{r}})
    (λ ts : Term × Term. θ{γ{P'} γ{var n} -> γ{r}})
    a.

elet ADescMono : ADesc -> Term := recursionTripleSum ?_ ?_ ?_ ?_
  (λ t : Term. θ{monoConst ?γ{t}})
  (λ _ : Unit. θ{monoId})
  (pr2 ?Term ?Term).

--------------------------------------------------------------------------------
-- Constructor description

let CDesc := Name × List ADesc.

elet CDescName (d : CDesc) : Name := pr1 ?_ ?(List ADesc) d.
elet CDescAs (d : CDesc) : List ADesc := pr2 ?_ ?(List ADesc) d.

elet cArgTelTerm (t : Term) (as : List ADesc) : Telescope :=
  zipWithIndex ?_ ?_
    (λ k : Nat. λ ad : ADesc. false, φ"a${showNatDecimal k}", ADescF ad t)
    as.

elet cArgTelName (rn : Name) (as : List ADesc) : Telescope :=
  cArgTelTerm (sVarTerm rn) as.

elet cArgTel (rn : Name) (c : CDesc) : Telescope :=
  cArgTelName rn (CDescAs c).

elet CDescToTy' (qn, rn : Name) (as : List ADesc) : Term :=
  foldWithPi (cArgTelName rn as) (sVarTerm qn).

elet CDescToTy (qn, rn : Name) (d : CDesc) : Term :=
  foldWithPi (cArgTel rn d) (sVarTerm qn).

elet appCtor (rn : Name) (d : CDesc) : Term :=
  applyTelescope (sVarTerm φ"${CDescName d}F") ((true, rn, θ{*}) ∷ cArgTel rn d).

elet CDescToTyP (rn, pn : Name) (d : CDesc) : Term :=
  foldWithPi (cArgTel rn d) θ{γ{sVarTerm pn} γ{appCtor rn d}}.

--------------------------------------------------------------------------------
-- Datatype description

let Desc := Name × List CDesc.

elet DescName (d : Desc) : Name := pr1 ?_ ?(List CDesc) d.
elet DescCs (d : Desc) : List CDesc := pr2 ?_ ?(List CDesc) d.

--------------------------------------------------------------------------------
-- castCtor: convert a term of type F1 R -> ... -> Fn R -> X to F1 S -> ... -> Fn S -> X
-- where cn : Cast R S and the Fi come from a constructor

elet genElimMono (S, T, cast : Term) (f : Term -> Term) (monoT : Term) (t : Term) : Term :=
  θ{elimCast ?γ{f S} ?γ{f T} ?(γ{monoT} ?γ{S} ?γ{T} γ{cast}) γ{t}}.

elet CDescToCastApp (S, T, cast : Term) (c : CDesc) : List App :=
  zipWith ?_ ?_ ?_
    (λ p : Param. λ ad : ADesc.
      mkAppU $ genElimMono S T cast (ADescF ad) (ADescMono ad) (sVarTerm $ paramName p))
    (cArgTelTerm S (CDescAs c))
    (CDescAs c).

elet castCtorApp (S, T, cast : Term) (t : Term) (c : CDesc) : Term :=
  appLTerm t $ CDescToCastApp S T cast c.

elet castCtor (S, T, cast : Term) (t : Term) (c : CDesc) : Term :=
  foldWithLambdas (cArgTelTerm S (CDescAs c)) $ castCtorApp S T cast t c.

elet castCtorPi (S, T, cast : Term) (t : List App -> Term) (c : CDesc) : Term :=
  foldWithPi (cArgTelTerm S (CDescAs c)) $ t $ CDescToCastApp S T cast c.

elet castApp (an, bn, cn : Name) (ns : List Name) (d : Desc) : List App :=
  zipWith ?_ ?_ ?_
    (λ c : CDesc. λ n : Name. mkAppU $ castCtor (sVarTerm an) (sVarTerm bn) (sVarTerm cn) (sVarTerm n) c)
    (DescCs d) ns.
