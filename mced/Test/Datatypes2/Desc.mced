--------------------------------------------------------------------------------
-- Descriptions of simple datatypes
--------------------------------------------------------------------------------

-- module Datatypes2:Desc.

-- importModule Bootstrap:Product.
-- importModule Bootstrap:String.

-- Given String stringNil stringCons.
-- Given Term quoteAst appLTerm binderTerm lambdaBinder App sVarTerm.
-- Given List nil cons.

import Datatypes2/Mono.

let castIota [A : *] [P : A -> *] : Cast (Iota A P) A :=
  intrCast ?(Iota A P) ?A ?(iPr1 ?A ?P) ?(beta ?(Iota A P)).

let Name := String.

elet mkNames (n : Name) (k : Nat) : List Name :=
  map ?_ ?_ (λ i : Nat. φ"${n}${showNatDecimal i}") (upTo k).

elet appNsU (t : Term) (ns : List Name) :=
  appLTerm t $ map ?_ ?_ (λ n : Name. mkAppU $ sVarTerm n) ns.

elet defineMulti (l : List LetInfo) : Eval Unit :=
  voidEval ?_ $ traverseEval ?_ ?_ letInfoToNewStmt l.

elet mkLetInfoWithTel (n : String) (tel : Telescope) (t : Term) (mty : Maybe Term) :=
  appendTelToLetInfo tel $ mkLetInfo n t mty.

elet applyTelescope (t : Term) (tel : Telescope) : Term :=
  appLTerm t (telescopeToApp tel).

elet telNames : Telescope -> List Name := map ?_ ?_ paramName.

elet naryFun (l : List Term) (t : Term) : Term :=
  recursionList' ?_ ?_ t (λ t' : Term. λ acc : Term. θ{γ{t'} -> γ{acc}}) l.

--------------------------------------------------------------------------------
-- Argument description, taking the name of a recursive type

let ADesc := (Name -> Term) × Term.

let ADescTy (a : ADesc) := pr1 ?(Name -> Term) ?Term a.
let ADescMono (a : ADesc) := pr2 ?(Name -> Term) ?Term a.

--------------------------------------------------------------------------------
-- Constructor description

let CDesc := Name × List ADesc.

elet CDescName (d : CDesc) : Name := pr1 ?_ ?(List ADesc) d.
elet CDescAs (d : CDesc) : List ADesc := pr2 ?_ ?(List ADesc) d.

elet cArgTelTerm (rn : Name) (t : Term) (as : List ADesc) : Telescope :=
  zipWithIndex ?_ ?_
    (λ k : Nat. λ ad : ADesc.
      false, φ"a${showNatDecimal k}", θ{γ{lambdaTerm rn θ{*} $ ADescTy ad rn} γ{t}})
    as.

elet cArgTel' (rn : Name) (as : List ADesc) : Telescope :=
  zipWithIndex ?_ ?_
    (λ k : Nat. λ ad : ADesc. false, φ"a${showNatDecimal k}", ADescTy ad rn)
    as.

elet cArgTel (rn : Name) (c : CDesc) : Telescope :=
  cArgTel' rn (CDescAs c).

elet CDescToTy' (qn, rn : Name) (as : List ADesc) : Term :=
  foldWithPi (cArgTel' rn as) (sVarTerm qn).

elet CDescToTy (qn, rn : Name) (d : CDesc) : Term :=
  foldWithPi (cArgTel rn d) (sVarTerm qn).

elet appCtor (rn : Name) (d : CDesc) : Term :=
  applyTelescope (sVarTerm φ"${CDescName d}F") ((true, rn, θ{*}) ∷ cArgTel rn d).

elet CDescToTyP (rn, pn : Name) (d : CDesc) : Term :=
  foldWithPi (cArgTel rn d) θ{γ{sVarTerm pn} γ{appCtor rn d}}.

--------------------------------------------------------------------------------
-- Datatype description

let Desc := Name × List CDesc.

elet DescName (d : Desc) : Name := pr1 ?_ ?(List CDesc) d.
elet DescCs (d : Desc) : List CDesc := pr2 ?_ ?(List CDesc) d.

elet NatDesc : Desc := "TestNat" , [CDesc|"tZero" , [ADesc|]; "tSuc" , [ADesc|sVarTerm, θ{monoId}]].

--------------------------------------------------------------------------------
-- castCtor: convert a term of type F1 R -> ... -> Fn R -> X to F1 S -> ... -> Fn S -> X
-- where cn : Cast R S and the Fi come from a constructor

elet genElimMono (an, bn, cn : Name) (f : Name -> Term) (monoT : Term) (t : Term) : Term :=
  θ{elimCast ?γ{f an} ?γ{f bn} ?(γ{monoT} ?γ{sVarTerm an} ?γ{sVarTerm bn} γ{sVarTerm cn}) γ{t}}.

elet CDescToCastApp (an, bn, cn : Name) (c : CDesc) : List App :=
  zipWith ?_ ?_ ?_
    (λ p : Param. λ ad : ADesc.
      mkAppU $ genElimMono an bn cn (ADescTy ad) (ADescMono ad) (sVarTerm $ paramName p))
    (cArgTel' an (CDescAs c))
    (CDescAs c).

elet castCtor (an, bn, cn : Name) (n : Name) (c : CDesc) : Term :=
  foldWithLambdas (cArgTel' an (CDescAs c)) $
    appLTerm (sVarTerm n) $ CDescToCastApp an bn cn c.

elet castApp' (an, bn, cn : Name) (ns : List Name) (d : Desc) : List App :=
  zipWith ?_ ?_ ?_
    (λ c : CDesc. λ n : Name. mkAppU $ castCtor' an bn cn n c)
    (DescCs d) ns.

--------------------------------------------------------------------------------
-- F

elet FName (d : Desc) : Name := φ"${DescName d}F".
elet FTerm (d : Desc) : Term := sVarTerm (FName d).

elet FTel' (qn, rn : Name) : List CDesc -> Telescope :=
  map ?_ ?_ (λ c : CDesc. false, φ"${CDescName c}X", CDescToTy qn rn c).

elet FTel (qn, rn : Name) (d : Desc) : Telescope :=
  (true, qn, θ{*}) ∷ FTel' qn rn (DescCs d).

elet DescToF (qn, rn : Name) (d : Desc) : Term :=
  lambdaTerm rn θ{*} $ foldWithPi (FTel qn rn d) (sVarTerm qn).

elet DefineF (qn, rn : Name) (d : Desc) : Eval Unit :=
  letInfoToNewStmt (mkLetInfo (FName d) (DescToF qn rn d) (just ?_ θ{* -> *})).

--------------------------------------------------------------------------------
-- F Constructors

elet DescToFCtor (qn, rn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel rn c : Telescope.
  mkLetInfoWithTel φ"${CDescName c}F" ((true, rn, θ{*}) ∷ cArgTel)
    (foldWithLambdas (FTel qn rn d) $ applyTelescope (sVarTerm φ"${CDescName c}X") cArgTel)
    (just ?_ $ θ{γ{FTerm d} γ{sVarTerm rn}}).

elet DescToFCtors (qn, rn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToFCtor qn rn d) (DescCs d).

elet DefineFCtors (qn, rn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ DescToFCtors qn rn d.

--------------------------------------------------------------------------------
-- WkIndF

elet WkIndFName (d : Desc) : Name := φ"WkInd${DescName d}F".
elet WkIndFTerm (d : Desc) : Term := sVarTerm (WkIndFName d).

elet WkIndTel (rn, pn : Name) (d : Desc) : Telescope :=
  (true, pn, θ{γ{FTerm d} γ{sVarTerm rn} -> *}) ∷ map ?_ ?_
    (λ c : CDesc. false, φ"${CDescName c}P", CDescToTyP rn pn c)
    (DescCs d).

elet DescToWkIndF (rn, rn', pn : Name) (d : Desc) : Term :=
  foldWithPi (WkIndTel rn pn d) θ{γ{sVarTerm pn} γ{sVarTerm rn'}}.

elet DefineWkIndF (rn, rn', pn : Name) (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfoWithTel (WkIndFName d)
    [Param|(false, rn, θ{*}); (false, rn', θ{γ{FTerm d} γ{sVarTerm rn}})]
    (DescToWkIndF rn rn' pn d) (just ?_ θ{*}).

--------------------------------------------------------------------------------
-- WkIndF Constructors

elet DescToWkIndCtor (rn, pn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel rn c : Telescope.
  mkLetInfoWithTel φ"${CDescName c}WkIndF" ((true, rn, θ{*}) ∷ cArgTel)
    (foldWithLambdas (WkIndTel rn pn d) $ applyTelescope (sVarTerm φ"${CDescName c}P") cArgTel)
    (just ?_ $ θ{γ{WkIndFTerm d} γ{sVarTerm rn} γ{appCtor rn c}}).

elet DescToWkIndCtors (rn, pn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToWkIndCtor rn pn d) (DescCs d).

elet DefineWkIndCtors (rn, pn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ DescToWkIndCtors rn pn d.

--------------------------------------------------------------------------------
-- Mono F

elet MonoFName (d : Desc) : Name := φ"mono${DescName d}F".
elet MonoFTerm (d : Desc) : Term := sVarTerm (MonoFName d).

elet genCast (X, Y : Term) (cn : Name) (ct : Term) : Term :=
  θ{intrCast ?γ{X} ?γ{Y} ?γ{lambdaTerm cn X ct} ?(beta ?γ{X})}.

elet withMonoLams (an, bn, cn : Name) (t : Term) : Term :=
  LambdaTerm an θ{*} $ LambdaTerm bn θ{*} $ lambdaTerm cn θ{Cast γ{sVarTerm an} γ{sVarTerm bn}} t.

elet DescToMonoPf (qn, an, bn, cn, xn : Name) (d : Desc) : Term :=
  ψ ftel = FTel qn bn d : Telescope.
  withMonoLams an bn cn $ genCast θ{γ{FTerm d} γ{sVarTerm an}} θ{γ{FTerm d} γ{sVarTerm bn}} xn $
    foldWithLambdas ftel $ appLTerm (sVarTerm xn) $
      mkAppE (sVarTerm qn) ∷ castApp an bn cn (telNames (tail ?_ ftel)) d.

elet DefineMonoF (qn, an, bn, cn, xn : Name) (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfo (MonoFName d)
    (DescToMonoPf qn an bn cn xn d)
    (just ?_ θ{Mono γ{FTerm d}}).

--------------------------------------------------------------------------------
-- Mono WkIndF

elet MonoWkIndFName (d : Desc) : Name := φ"mono${WkIndFName d}".
elet MonoWkIndFTerm (d : Desc) : Term := sVarTerm (MonoWkIndFName d).

elet DescToMonoWkIndPf (pn, an, bn, cn, xn, yn, zn : Name) (d : Desc) : Term :=
  ψ ftel = WkIndTel bn pn d : Telescope.
  ψ elimMono
    = genElimMono an bn cn (λ n : Name. θ{γ{FTerm d} γ{sVarTerm n}}) (MonoFTerm d) : Term -> Term.
  withMonoLams an bn cn $ lambdaTerm yn θ{γ{FTerm d} γ{sVarTerm an}} $
    genCast θ{γ{WkIndFTerm d} γ{sVarTerm an} γ{sVarTerm yn}}
            θ{γ{WkIndFTerm d} γ{sVarTerm bn}
                  γ{elimMono $ sVarTerm yn}} xn $
    foldWithLambdas ftel $ appLTerm (sVarTerm xn) $
      mkAppE (lambdaTerm zn θ{γ{FTerm d} γ{sVarTerm an}} $ θ{γ{sVarTerm pn} γ{elimMono $ sVarTerm zn}}) ∷
      castApp an bn cn (telNames (tail ?_ ftel)) d.

elet DefineMonoWkIndF (pn, an, bn, cn, xn, yn, zn : Name) (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfo (MonoWkIndFName d)
    (DescToMonoWkIndPf pn an bn cn xn yn zn d)
    (just ?_ θ{MonoD γ{FTerm d} γ{WkIndFTerm d} γ{MonoFTerm d}}).

--------------------------------------------------------------------------------
-- FI & mono FI

elet FIName (d : Desc) : Name := φ"${DescName d}FI".
elet FITerm (d : Desc) : Term := sVarTerm (FIName d).

elet DefineFI (rn : Name) (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfoWithTel (FIName d) [Param|(false, rn, θ{*})]
    θ{Iota (γ{FTerm d} γ{sVarTerm rn}) (γ{WkIndFTerm d} γ{sVarTerm rn})}
    (just ?_ θ{*}).

elet DefineMonoFI (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfo φ"mono${DescName d}FI"
    θ{iotaMono γ{FTerm d} γ{WkIndFTerm d} γ{MonoFTerm d} γ{MonoWkIndFTerm d}}
    (just ?_ θ{Mono γ{FITerm d}}).

--------------------------------------------------------------------------------
-- Main type

elet TyName (d : Desc) : Name := DescName d.
elet TyTerm (d : Desc) : Term := sVarTerm (TyName d).

elet RollName (d : Desc) : Name := φ"roll${TyName d}".
elet RollTerm (d : Desc) : Term := sVarTerm (RollName d).

elet DefineTy (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfo (TyName d)
    θ{Rec γ{FITerm d}}
    (just ?_ θ{*}).

elet DefineRoll (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfo (RollName d)
    θ{roll γ{FITerm d} ?γ{sVarTerm φ"mono${DescName d}FI"}}
    (just ?_ θ{γ{FITerm d} γ{TyTerm d} -> γ{TyTerm d}}).

elet DefineUnroll (d : Desc) : Eval Unit :=
  letInfoToNewStmt $ mkLetInfo φ"unroll${TyName d}"
    θ{unroll γ{FITerm d} ?γ{sVarTerm φ"mono${DescName d}FI"}}
    (just ?_ θ{γ{TyTerm d} -> γ{FITerm d} γ{TyTerm d}}).

elet DescToCtor/appCtor (d : Desc) (c : CDesc) (t : Term) : Term := appLTerm t $
  mkAppE (TyTerm d) ∷ map ?_ ?_ (λ n : Name. mkAppU $ sVarTerm n) $ telNames (cArgTel (TyName d) c).

elet DescToCtor (d : Desc) (c : CDesc) : LetInfo :=
  ψ cArgTel = cArgTel (TyName d) c : Telescope.
  ψ appCtor = DescToCtor/appCtor d c : Term -> Term.
  ψ fCtor = appCtor (sVarTerm φ"${CDescName c}F") : Term.
  mkLetInfoWithTel φ"${CDescName c}" cArgTel
    θ{γ{RollTerm d} $ iPair ?(γ{FTerm d} γ{TyTerm d}) ?(γ{WkIndFTerm d} γ{TyTerm d})
        γ{fCtor} γ{appCtor $ sVarTerm φ"${CDescName c}WkIndF"} (beta ?(γ{FTerm d} γ{TyTerm d}) γ{fCtor})}
    (just ?_ $ TyTerm d).

elet DescToCtors (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtor d) (DescCs d).

elet DefineCtors (d : Desc) : Eval Unit :=
  defineMulti $ DescToCtors d.

--------------------------------------------------------------------------------
-- LR

elet DefineRec (pn, xn : Name) (d : Desc) : Eval Unit :=
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel = map ?_ ?_ (λ n : Name. (false, "", sVarTerm n)) ns : Telescope.
  letInfoToNewStmt $ mkLetInfoWithTel φ"Rec${DescName d}"
    ((false, pn, θ{γ{TyTerm d} -> *}) ∷ (false, xn, TyTerm d) ∷
      map ?_ ?_ (λ n : Name. (false, n, θ{*})) ns)
    (foldWithPi tel $ foldWithPi tel $ θ{γ{sVarTerm pn} γ{sVarTerm xn}})
    (just ?_ θ{*}).

elet DescToCtorF (pn, rn, xn : Name) (d : Desc) (c : CDesc) : LetInfo :=
  ψ ns  = mkNames "A" (length ?_ (DescCs d)) : List Name.
  ψ tel1 = map ?_ ?_ (λ n : Name. (true, n, θ{*})) ns : Telescope.
  ψ tel2 = map ?_ ?_ (λ n : Name. (false, "", sVarTerm n)) ns : Telescope.
  ψ cArgTel = cArgTelTerm rn
    θ{Iota γ{TyTerm d} γ{lambdaTerm xn (TyTerm d) $
        appNsU (sVarTerm φ"Rec${DescName d}") (pn ∷ xn ∷ ns)}}
    (CDescAs c) : Telescope.
  mkLetInfoWithTel φ"${CDescName c}F" [Param|(false, pn, θ{γ{TyTerm d} -> *})]
    (foldWithPi tel1 $ foldWithPi cArgTel $ foldWithLambdas tel2
      θ{γ{sVarTerm pn} γ{appLTerm (sVarTerm $ CDescName c) ..}})
    (just ?_ θ{*}).

elet DescToCtorFs (pn : Name) (d : Desc) : List LetInfo :=
  map ?_ ?_ (DescToCtorF pn d) (DescCs d).

elet DefineCtorFs (pn : Name) (d : Desc) : Eval Unit :=
  defineMulti $ DescToCtorFs pn d.

--------------------------------------------------------------------------------
-- Tests

echo showTerm $ DescToF "X" "R" NatDesc.
echo showList ?LetInfo showLetInfo $ DescToFCtors "X" "R" NatDesc.
echo showTerm $ DescToWkIndF "R" "r" "P" NatDesc.
echo showList ?LetInfo showLetInfo $ DescToWkIndCtors "R" "P" NatDesc.

runMeta DefineF     "X" "R" NatDesc.
runMeta DefineFCtors "X" "R" NatDesc.
runMeta DefineWkIndF "R" "r" "P" NatDesc.
runMeta DefineWkIndCtors "R" "P" NatDesc.

runMeta DefineMonoF' "X" "A" "B" "c" "x" NatDesc.
runMeta DefineMonoWkIndF "X" "A" "B" "c" "x" "y" "z" NatDesc.

runMeta DefineFI "R" NatDesc.
runMeta DefineMonoFI NatDesc.

runMeta DefineTy NatDesc.
runMeta DefineRoll NatDesc.
runMeta DefineUnroll NatDesc.

runMeta DefineCtors NatDesc.

runMeta DefineRec "P" "x" NatDesc.

RecTestNat

endModule.
