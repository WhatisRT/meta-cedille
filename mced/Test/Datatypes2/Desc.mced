--------------------------------------------------------------------------------
-- Descriptions of inductive datatypes
--------------------------------------------------------------------------------

-- Currently missing:
-- - Function arguments to constructors
-- - Recursion schemes
-- - Match schemes
-- - Nested types (other than List)

elet TyConst (T : *) : * -> * := λ _ : *. T.
elet TyId : * -> * := λ R : *. R.

--------------------------------------------------------------------------------
-- Argument description

let TDesc := Term         -- non-recursive
           ⊎ List Term    -- recursive, not nested
           ⊎ Term × Term. -- recursive, nested

let tdNonRec (t : Term)       : TDesc := inl ?Term ?(List Term ⊎ Term × Term) t.
let tdRecNN (ts : List Term)  : TDesc :=
  inr ?Term ?(List Term ⊎ Term × Term) (inl ?(List Term) ?(Term × Term) ts).
let tdRecN (ts : Term × Term) : TDesc :=
  inr ?Term ?(List Term ⊎ Term × Term) (inr ?(List Term) ?(Term × Term) ts).

elet TDescTy : TDesc -> Term := recursionTripleSum ?_ ?_ ?_ ?_
  (λ t : Term. θ{TyConst γ{t}})
  (λ _ : List Term. θ{TyId})
  (pr1 ?Term ?Term).

-- TDescF a is a functor from indexed types (I1 -> ... -> Ik -> *) to types (*)
elet TDescF (a : TDesc) (t : Term) : Term := recursionTripleSum ?_ ?_ ?_ ?_
  (λ t' : Term. t')
  (λ ts : List Term. appLTerm t (map ?_ ?_ mkAppU ts))
  (λ ts : Term × Term. θ{γ{pr1 ?Term ?Term ts} γ{t}})
  a.

-- TODO: P' should come from ADesc
-- Variations of Π n : T. (P n) -> ...
elet TDescP (a : TDesc) (n : Name) (t, P, P', r : Term) : Term :=
  piTerm n (TDescF a t) $ recursionTripleSum ?_ ?_ ?_ ?_
    (λ _  : Term. r)
    (λ _  : List Term. θ{γ{P} γ{var n} -> γ{r}})
    (λ ts : Term × Term. θ{γ{P'} γ{var n} -> γ{r}})
    a.

elet TDescMono : TDesc -> Term := recursionTripleSum ?_ ?_ ?_ ?_
  (λ t : Term. θ{monoConst ?γ{t}})
  (λ _ : List Term. θ{monoId})
  (pr2 ?Term ?Term).

let ADesc := Name × TDesc.

elet adUnnamed (a : TDesc) : ADesc := "_", a.

let adName : ADesc -> Name := pr1 ?Name ?TDesc.
let adTDesc : ADesc -> TDesc := pr2 ?Name ?TDesc.

--------------------------------------------------------------------------------
-- Constructor description

let CDesc := Name × List ADesc × List Term.

elet CDescName (d : CDesc) : Name := pr31 ?_ ?(List ADesc) ?(List Term) d.
elet CDescAs (d : CDesc) : List ADesc := pr32 ?_ ?(List ADesc) ?(List Term) d.
elet CDescApp (d : CDesc) : List Term := pr33 ?_ ?(List ADesc) ?(List Term) d.

elet preprocessCDesc (d : CDesc) : CDesc :=
  CDescName d, zipWithIndex ?_ ?_
    (λ k : Nat. λ ad : ADesc. ifthenelse ?_ (emptyName (adName ad))
      (φ"ctor${showNatDecimal k}", adTDesc ad)
      ad)
    (CDescAs d),
    CDescApp d.

--------------------------------------------------------------------------------
-- cArgTel variants: the telescope of arguments to a constructor

elet CDescApp' (t : Term) (c : CDesc) : Term :=
  appLTerm t (map ?_ ?_ mkAppU (CDescApp c)).

elet cArgTelTerm (t : Term) (as : List ADesc) : Telescope :=
  zipWithIndex ?_ ?_ (λ k : Nat. λ ad : ADesc.
    false, adName ad, TDescF (adTDesc ad) t)
    as.

elet cArgApp (c : CDesc) : List App :=
  telescopeToApp (cArgTelTerm θ{□} (CDescAs c)).

elet cArgTelName (rn : Name) (as : List ADesc) : Telescope :=
  cArgTelTerm (var rn) as.

elet cArgTel (rn : Name) (c : CDesc) : Telescope :=
  cArgTelName rn (CDescAs c).

elet CDescToTy' (qn, rn : Name) (as : List ADesc) : Term :=
  foldWithPi (cArgTelName rn as) (var qn).

let CDescToTy (qn, rn : Name) (c : CDesc) : Term :=
  foldWithPi (cArgTelTerm (var rn) (CDescAs c)) (CDescApp' (var qn) c).

--------------------------------------------------------------------------------
-- Datatype description

let Desc := Name
          × Telescope   -- parameters
          × List Term   -- indices
          × List CDesc. -- constructors

elet mkDesc (n : Name) (ps : Telescope) (ixs : List Term) (cs : List CDesc) :=
  (n, ps, ixs, cs).

elet DescName (d : Desc) : Name := pr1 ?_ ?(Telescope × List Term × List CDesc) d.
elet DescTel (d : Desc) : Telescope :=
  pr1 ?Telescope ?(List Term × List CDesc) $ pr2 ?_ ?(Telescope × List Term × List CDesc) d.
elet DescIxs (d : Desc) : List Term := pr1 ?(List Term) ?(List CDesc) $
  pr2 ?Telescope ?(List Term × List CDesc) $ pr2 ?_ ?(Telescope × List Term × List CDesc) d.
elet DescCs (d : Desc) : List CDesc := pr2 ?(List Term) ?(List CDesc) $
  pr2 ?Telescope ?(List Term × List CDesc) $ pr2 ?_ ?(Telescope × List Term × List CDesc) d.

elet genDescTy (d : Desc) : Term :=
  foldl ?_ ?_ (λ acc : Term. λ t : Term. θ{γ{t} -> γ{acc}}) (DescIxs d) θ{*}.

elet preprocessDesc (d : Desc) : Desc :=
  DescName d, DescTel d, DescIxs d, map ?_ ?_ preprocessCDesc (DescCs d).

elet ixTel (d : Desc) : Telescope :=
  zipWithIndex ?_ ?_ (λ k : Nat. λ t : Term. false, φ"k${showNatDecimal k}", t) (DescIxs d).

--------------------------------------------------------------------------------
-- genFreshD: generate a name which doesn't appear as a prefix in a Desc

elet genFreshD/adNs (ad : ADesc) : List Name := recursionTripleSum ?_ ?_ ?_ ?_
  termNonFreshNames
  (λ _ : List Term. [Name|])
  (recursionProduct ?_ ?_ ?_ (λ t, t' : Term. app ?_ (termNonFreshNames t) (termNonFreshNames t')))
  (adTDesc ad).

elet genFreshD/ns (d : Desc) : List Name :=
  remDup ?_ stringEq $ DescName d ∷ app ?_ (telNonFreshNames (DescTel d)) $ concat ?_ $
    map ?_ ?_ (λ c : CDesc. CDescName c ∷ concat ?_ $ map ?_ ?_ genFreshD/adNs (CDescAs c)) (DescCs d).

elet genFreshD (d : Desc) : Name -> Name :=
  genFreshPrefix (genFreshD/ns d).

--------------------------------------------------------------------------------
-- castCtor: convert a term of type F1 R -> ... -> Fn R -> X to F1 S -> ... -> Fn S -> X
-- where cn : Cast R S and the Fi come from a constructor

-- S, T: indexed, f : Indexed -> non-indexed
elet genElimMono (S, T, cast : Term) (f : Term -> Term) (monoT : Term) (t : Term) : Term :=
  θ{elimCast ?γ{f S} ?γ{f T} ?(γ{monoT} ?γ{S} ?γ{T} γ{cast}) γ{t}}.

elet genElimMonoIx (S, T, cast : Term) (tel : Telescope) (f : Term -> Term) (monoT : Term) (t : Term) : Term :=
  θ{elimCast ?γ{f S} ?γ{f T} ?(γ{applyTelescope θ{γ{monoT} ?γ{S} ?γ{T} γ{cast}} tel}) γ{t}}.

elet genCastTDesc (a : TDesc) (S, T, cast, t : Term) : Term := recursionTripleSum ?_ ?_ ?_ ?_
  (λ _  : Term. t)
  (λ ts : List Term. ψ appIxs = λ t' : Term. appLTerm t' (map ?_ ?_ mkAppU ts) : Term -> Term.
    θ{elimCast ?γ{appIxs S} ?γ{appIxs T} ?γ{appIxs cast} γ{t}})
  (λ ts : Term × Term. genElimMono S T cast (TDescF a) (TDescMono a) t)
  a.

elet CDescToCastApp (S, T, cast : Term) (c : CDesc) : List App :=
  zipWith ?_ ?_ ?_
    (λ p : Param. λ td : TDesc.
      mkAppU $ genCastTDesc td S T cast (var $ paramName p))
    (cArgTelTerm S (CDescAs c))
    (map ?_ ?_ adTDesc (CDescAs c)).

elet castCtorApp (S, T, cast : Term) (t : Term) (c : CDesc) : Term :=
  appLTerm t $ CDescToCastApp S T cast c.

elet castCtor (S, T, cast : Term) (t : Term) (c : CDesc) : Term :=
  foldWithLambdas (cArgTelTerm S (CDescAs c)) $ castCtorApp S T cast t c.

elet castCtorPi (S, T, cast : Term) (t : List App -> Term) (c : CDesc) : Term :=
  foldWithPi (cArgTelTerm S (CDescAs c)) $ t $ CDescToCastApp S T cast c.

elet castApp (S, T, cast : Term) (ns : List Name) (d : Desc) : List App :=
  zipWith ?_ ?_ ?_
    (λ c : CDesc. λ n : Name. mkAppU $ castCtor S T cast (var n) c)
    (DescCs d) ns.
