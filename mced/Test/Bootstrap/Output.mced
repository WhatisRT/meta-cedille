--------------------------------------------------------------------------------
-- Functions for printing to the terminal
--------------------------------------------------------------------------------

module Bootstrap:Output.

importModule Bootstrap:Binary.
importModule Bootstrap:Bool.
importModule Bootstrap:Builtins.
importModule Bootstrap:Eval.
importModule Bootstrap:List.
importModule Bootstrap:ListExt.
importModule Bootstrap:MLLet.
importModule Bootstrap:Maybe.
importModule Bootstrap:Nat.
importModule Bootstrap:Product.
importModule Bootstrap:ShowTerm.
importModule Bootstrap:StringExt.
importModule Bootstrap:StringHelpers.
importModule Bootstrap:StringNotation.
importModule Bootstrap:Term.
importModule Bootstrap:Unit.

let genEscapeCode (s : String) : String := Ï†"[${s}m".
let resetCode : String := genEscapeCode "0".

--------------------------------------------------------------------------------
-- Functional
--------------------------------------------------------------------------------

let backspaceCode := "".
elet undoPrint (s : String) : String :=
  stringConcat $ replicate ?_ backspaceCode $ stringLength s.

elet evalWithProgress [T : *] (progress, done : String) (x : Eval T) :=
  printEval progress >> (x >>= Î» x' : T.
  (printEval (undoPrint progress) >> printEval done) >> pureEval ?T x').

--------------------------------------------------------------------------------
-- Colors
--------------------------------------------------------------------------------

let ANSI8Color : * := âˆ€ X : *. X -> X -> X -> X -> X -> X -> X -> X -> X.

let ANSI8Black   := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. black.
let ANSI8Red     := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. red.
let ANSI8Green   := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. green.
let ANSI8Yellow  := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. yellow.
let ANSI8Blue    := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. blue.
let ANSI8Magenta := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. magenta.
let ANSI8Cyan    := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. cyan.
let ANSI8White   := Î› X : *. Î» black, red, green, yellow, blue, magenta, cyan, white : X. white.

let toColorCode8 (c : ANSI8Color) : String :=
  genEscapeCode (c ?String "30" "31" "32" "33" "34" "35" "36" "37").

let toBrightColorCode8 (c : ANSI8Color) : String :=
  genEscapeCode (stringApp (c ?String "30" "31" "32" "33" "34" "35" "36" "37") ";1").

let toBGColorCode8 (c : ANSI8Color) : String :=
  genEscapeCode (c ?String "40" "41" "42" "43" "44" "45" "46" "47").

let withColor8 (c : ANSI8Color) (s : String) : String :=
  stringConcat [String|toBrightColorCode8 c, s, resetCode].

let withColors8 (fg, bg : ANSI8Color) (s : String) : String :=
  stringConcat [String|toColorCode8 fg, toBGColorCode8 bg, s, resetCode].

let toColorCode256 (c : Byte) : String :=
  genEscapeCode Ï†"38;5;${showByte c}".

let toBGColorCode256 (c : Byte) : String :=
  genEscapeCode Ï†"48;5;${showByte c}".

let withColor256 (c : Byte) (s : String) : String :=
  stringConcat [String|toColorCode256 c, s, resetCode].

let withColors256 (fg, bg : Byte) (s : String) : String :=
  stringConcat [String|toColorCode256 fg, toBGColorCode256 bg, s, resetCode].

--------------------------------------------------------------------------------
-- Verbosity
--------------------------------------------------------------------------------

let LogType : * := âˆ€ X : *. X -> X -> X -> X -> X.

let LogTypeDebug := Î› X : *. Î» debug, info, warn, error : X. debug.
let LogTypeInfo  := Î› X : *. Î» debug, info, warn, error : X. info.
let LogTypeWarn  := Î› X : *. Î» debug, info, warn, error : X. warn.
let LogTypeError := Î› X : *. Î» debug, info, warn, error : X. error.

elet currentLogType : Eval LogType := pureEval ?_ LogTypeDebug.

elet doPrintLogType (t : LogType) : Eval Bool :=
  t ?(Eval Bool) (pureEval ?_ true)
                 (mapEval ?_ ?_ (Î» s : EvalState. getPrintInfo (getEvalOpts s)) getEval)
                 (pureEval ?_ true)
                 (pureEval ?_ true).

elet debugPrint (t : LogType) (level : Nat) (m : String) : Eval Unit :=
  doPrintLogType t >>= Î» b : Bool.
  ifthenelse ?_ b (printLineEval m) (pureEval ?_ tt).

elet showLetInfo (i : LetInfo) : String :=
  Ï†"${letInfoName i} := ${showTerm $ letInfoTerm i}${
      maybe ?_ ?_ "" (Î» T : Term. Ï†" : ${showTerm T}") $ letInfoType i}\n".

elet debugPrintLetInfo : ElabLet := Î» i : LetInfo.
  debugPrint LogTypeInfo zero Ï†"Defined: ${showLetInfo i}" >> pureEval ?_ i.

endModule.
