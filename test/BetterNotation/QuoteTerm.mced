--------------------------------------------------------------------------------
-- Quotation and antiquotation for terms
--
-- The syntax is θ{...} for quotation and γ{...} for antiquotation.
--------------------------------------------------------------------------------

b-let mapAppList [X, Y : *] (f : Π _ : X. Y) (l : List (Product Bool X)) : List (Product Bool Y) :=
  map ?(Product Bool X) ?(Product Bool Y)
    (λ bx : Product Bool X. prodPair ?Bool ?Y (pr1 ?Bool ?X bx) (f (pr2 ?Bool ?X bx))) l.

b-let recursionTerm [X : *]
  (fvar : Π _ : init$var. X)
  (fsort : Π _ : init$sort. X)
  (fbind : Π _ : Binder. Π _ : init$string. Π _ : Term. Π _ : Term. Π _ : X. Π _ : X. X)
  (fapp : Π _ : Term. Π _ : List App. Π _ : X. Π _ : List (Product Bool X). X)
  (funq : Π _ : Term. Π _ : X. X)
  (term : Term) : X :=
  pr1 ?X ?Term (term ?(Product X Term)
    (λ v : init$var. prodPair ?X ?Term (fvar v) (varTerm v))
    (λ s : init$sort. prodPair ?X ?Term (fsort s) (sortTerm s))
    (λ b : Binder. λ n : init$string. λ T : Product X Term. λ t : Product X Term.
      prodPair ?X ?Term
        (fbind b n (pr2 ?X ?Term T) (pr2 ?X ?Term t) (pr1 ?X ?Term T) (pr1 ?X ?Term t))
        (binderTerm b n (pr2 ?X ?Term T) (pr2 ?X ?Term t)))
    (λ t : Product X Term. λ l : List (Product Bool (Product X Term)).
      prodPair ?X ?Term
        (fapp (pr2 ?X ?Term t) (mapAppList ?(Product X Term) ?Term (pr2 ?X ?Term) l)
              (pr1 ?X ?Term t) (mapAppList ?(Product X Term) ?X (pr1 ?X ?Term) l))
        (appLTerm (pr2 ?X ?Term t) (mapAppList ?(Product X Term) ?Term (pr2 ?X ?Term) l)))
    (λ u : Product X Term.
      prodPair ?X ?Term (funq (pr2 ?X ?Term u) (pr1 ?X ?Term u)) (unquoteTerm (pr2 ?X ?Term u)))).

-- We want to define quoteTerm, the rest are helper functions

b-let appDouble (t, t', t'' : Term) :=  appLTerm t [App| mkAppU t', mkAppU t''].

b-let quoteAst : Term := sortTerm init$sort$=ast=.
b-let quoteSq : Term := sortTerm init$sort$=sq=.
b-let quoteTemp : Term := quoteSq. -- this is for things that are not yet implemented

b-let quoteVar (v : init$var) : Term :=
  appSingle
    (sVarTerm "sVarTerm")
    (v ?Term (λ n : init$string. quote$String n) (λ i : init$index. quoteTemp)). -- quotation of indices is not supported

b-let quoteBinder (b : Binder) : Term :=
  b ?Term (sVarTerm "lambdaBinder") (sVarTerm "LambdaBinder") (sVarTerm "piBinder") (sVarTerm "forallBinder").

b-let quoteBool (b : Bool) : Term := ifthenelse ?Term b (sVarTerm "true") (sVarTerm "false").

b-let quoteAppLeft (a : App) : Term :=
  appDouble (sVarTerm "mkApp") (quoteBool (appErased a)) (appTerm a). -- don't need to quote the term here

b-let quoteTerm (t : Term) : Term :=
  recursionTerm ?Term
    (λ v : init$var. quoteVar v)
    (λ s : init$sort. s ?Term (sVarTerm "quoteAst") (sVarTerm "quoteSq"))
    (λ b : Binder. λ n : init$string. λ T : Term. λ t : Term. λ recT : Term. λ rect : Term.
      appLTerm (sVarTerm "binderTerm") (toAppU [Term| quoteBinder b, quote$String n, recT, rect]))
    (λ t : Term. λ l : List App. λ rect : Term. λ recl : List App.
      appDouble (sVarTerm "appLTerm") rect (quoteTermList (sVarTerm "App") (map ?App ?Term quoteAppLeft recl)))
    (λ u : Term. λ recuf : Term. u)
    t.

-- Syntax

b-let init$singleTerm$=theta==lbrace=_space'__multiTerm_=rbrace= (_ : init$space') (t : Term) : Term := quoteTerm t.
b-let init$singleTerm$=gamma==lbrace=_space'__multiTerm_=rbrace= (_ : init$space') (t : Term) : Term := unquoteTerm t.
-- unquoteTerm is just a constructor of Term

seteval eval init stmt.