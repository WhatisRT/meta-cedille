let ConstrFunctor := ∀ X : *.
  Π _ : X. -- id
  Π _ : (Π _ : Term. X). -- const
  Π _ : (Π _ : init$string. Π _ : Term. Π _ : X. X). -- covHom with inner functor
  Π _ : (Π _ : init$string. Π _ : X. Π _ : X. X). -- dependent pair
  X.

let idConstrFunctor := Λ X : *.
  λ i : X.
  λ _ : (Π _ : Term. X).
  λ _ : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ _ : (Π _ : init$string. Π _ : X. Π _ : X. X).
  i.

let constConstrFunctor := λ t : Term. Λ X : *.
  λ _ : X.
  λ c : (Π _ : Term. X).
  λ _ : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ _ : (Π _ : init$string. Π _ : X. Π _ : X. X).
  c t.

let covDHomConstrFunctor := λ n : init$string. λ t : Term. λ f : ConstrFunctor. Λ X : *.
  λ i : X.
  λ c : (Π _ : Term. X).
  λ h : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ p : (Π _ : init$string. Π _ : X. Π _ : X. X).
  h n t (f ?X i c h p).

let pairConstrFunctor := λ s : init$string. λ f : ConstrFunctor. λ f' : ConstrFunctor. Λ X : *.
  λ i : X.
  λ c : (Π _ : Term. X).
  λ h : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ p : (Π _ : init$string. Π _ : X. Π _ : X. X).
  p s (f ?X i c h p) (f' ?X i c h p).

let recursionConstrFunctor [X : *]
  (idf : X)
  (constf : (Π _ : Term. X))
  (covHomf : (Π _ : init$string. Π _ : Term. Π _ : ConstrFunctor. Π _ : X. X))
  (pairf : (Π _ : init$string. Π _ : ConstrFunctor. Π _ : ConstrFunctor. Π _ : X. Π _ : X. X))
  (f : ConstrFunctor) : X :=
  pr1 ?X ?ConstrFunctor (f ?(Product X ConstrFunctor)
    (prodPair ?X ?ConstrFunctor idf idConstrFunctor)
    (λ t : Term. prodPair ?X ?ConstrFunctor (constf t) (constConstrFunctor t))
    (λ n : init$string. λ t : Term. λ t' : Product X ConstrFunctor.
      prodPair ?X ?ConstrFunctor
        (covHomf n t (pr2 ?X ?ConstrFunctor t') (pr1 ?X ?ConstrFunctor t'))
        (covDHomConstrFunctor n t (pr2 ?X ?ConstrFunctor t')))
    (λ s : init$string. λ t : Product X ConstrFunctor. λ t' : Product X ConstrFunctor.
      prodPair ?X ?ConstrFunctor
        (pairf s (pr2 ?X ?ConstrFunctor t) (pr2 ?X ?ConstrFunctor t') (pr1 ?X ?ConstrFunctor t) (pr1 ?X ?ConstrFunctor t'))
        (pairConstrFunctor s (pr2 ?X ?ConstrFunctor t) (pr2 ?X ?ConstrFunctor t')))).
let liftMaybe2 [X, Y, Z : *] (f : Π _ : X. Π _ : Y. Z) (x : Maybe' X) (y : Maybe' Y) : Maybe' Z :=
  maybe' ?X ?(Maybe' Z) (nothing' ?Z) (λ x' : X. mapMaybe' ?Y ?Z (λ y' : Y. f x' y') y) x.

let traverseMaybeList [X, Y : *] (f : Π _ : X. Maybe' Y) : Π _ : List X. Maybe' (List Y) :=
  recursionList ?X ?(Maybe' (List Y))
    (just' ?(List Y) [Y|])
    (λ x : X. λ xs : List X. λ rec : Maybe' (List Y). liftMaybe2 ?Y ?(List Y) ?(List Y) (cons ?Y) (f x) rec).

let varToName (v : init$var) : Maybe' init$string :=
  v ?(Maybe' init$string) (just' ?init$string) (λ _ : init$index. nothing' ?init$string).

-- if t is a name, returns that name
let termToName (t : Term) : Maybe' init$string :=
  t ?(Maybe' init$string)
    varToName
    (λ s : init$sort. nothing' ?init$string)
    (λ b : Binder. λ n : init$string. λ _ : Maybe' init$string. λ _ : Maybe' init$string. nothing' ?init$string)
    (λ t : Maybe' init$string. λ l : List (Product Bool (Maybe' init$string)). nothing' ?init$string)
    (λ _ : Maybe' init$string. nothing' ?init$string).

-- if t is of the form n n1 ... nk, returns that list
let termToNameList (t : Term) : Maybe' (List init$string) :=
  recursionTerm ?(Maybe' (List init$string))
    (λ v : init$var. mapMaybe' ?init$string ?(List init$string) (pureList ?init$string) (varToName v))
    (λ s : init$sort. nothing' ?(List init$string))
    (λ b : Binder. λ n : init$string. λ _ : Term. λ _ : Term. λ _ : Maybe' (List init$string). λ _ : Maybe' (List init$string).
      nothing' ?(List init$string))
    (λ _ : Term. λ l : List App. λ ns : Maybe' (List init$string). λ _ : List (Product Bool (Maybe' (List init$string))).
      liftMaybe2 ?(List init$string) ?(List init$string) ?(List init$string) (app ?init$string)
                 ns (traverseMaybeList ?App ?init$string (λ a : App. termToName (appTerm a)) l))
    (λ _ : Term. λ _ : Maybe' (List init$string). nothing' ?(List init$string))
    t.

let matchTerm (t : Term) (match : List init$string) : Bool :=
  maybe' ?(List init$string) ?Bool false (λ ns : List init$string. listEq ?init$string stringEq match ns) (termToNameList t).

let constrArgToFunctor (t : Term) (match : List init$string) : Error ConstrFunctor :=
  ifthenelse ?(Error ConstrFunctor) (matchTerm t match) (pureError ?ConstrFunctor idConstrFunctor)
    (recursionTerm ?(Error ConstrFunctor)
      (λ v : init$var. pureError ?ConstrFunctor (constConstrFunctor t))
      (λ s : init$sort. error ?ConstrFunctor "Cannot turn sort into functor")
      (λ b : Binder. λ n : init$string. λ T : Term. λ _ : Term. λ _ : Error ConstrFunctor. λ rect : Error ConstrFunctor.
        b ?(Error ConstrFunctor)
          (error ?ConstrFunctor "Can only have pi binder in constructors")
          (error ?ConstrFunctor "Can only have pi binder in constructors")
          (mapError ?ConstrFunctor ?ConstrFunctor (covDHomConstrFunctor n T) rect)
          (error ?ConstrFunctor "Can only have pi binder in constructors"))
      (λ t : Term. λ l : List App. λ _ : Error ConstrFunctor. λ _ : List (Product Bool (Error ConstrFunctor)).
        pureError ?ConstrFunctor (constConstrFunctor (appLTerm t l)))
      (λ u : Term. λ _ : Error ConstrFunctor. error ?ConstrFunctor "Cannot turn unquote into functor")
      t).

let ConstrData := Product Telescope Term.
let mkConstrData := prodPair ?Telescope ?Term.
let noArgConstrData : Π _ : Term. ConstrData := mkConstrData telNil.
let consArgConstrData (p : Param) (d : ConstrData) : ConstrData :=
  mkConstrData (cons ?Param p (pr1 ?Telescope ?Term d)) (pr2 ?Telescope ?Term d).
let ConstrDataTelescope := pr1 ?Telescope ?Term.
let ConstrDataTerm := pr2 ?Telescope ?Term.

let reduceTerm (term : Term) : Term :=
  term ?Term varTerm sortTerm binderTerm
    (λ t : Term. λ l : List App. ifthenelse ?Term (isNil ?App l) t (appLTerm t l))
    unquoteTerm.

let constrToFunctor (d : ConstrData) (match : List init$string) : Error ConstrFunctor :=
  ifthenelse ?(Error ConstrFunctor) (matchTerm (reduceTerm (ConstrDataTerm d)) match)
    (foldl ?Param ?(Error ConstrFunctor)
           (λ f : Error ConstrFunctor. λ p : Param.
             liftError2 ?ConstrFunctor ?ConstrFunctor ?ConstrFunctor (pairConstrFunctor (paramName p))
                        (constrArgToFunctor (paramType p) match) f)
           (ConstrDataTelescope d) (pureError ?ConstrFunctor (constConstrFunctor θ{Unit})))
    (error ?ConstrFunctor
           (stringConcat [init$string|
             "The final term in the constructor doesn't match! ",
             showTerm (ConstrDataTerm d),
             " and ",
             showList ?init$string (λ s : init$string. s) match])).

let getMatch (n : init$string) (t : Telescope) : List init$string := cons ?init$string n (map ?Param ?init$string paramName t).

let DatatypeData := TripleProduct init$string Telescope (List (TripleProduct init$string ConstrData ConstrFunctor)).
let mkDatatypeData := mkTripleProduct ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctor)).
let DatatypeName := pr31 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctor)).
let DatatypeTelescope := pr32 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctor)).
let DatatypeConstrs := pr33 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctor)).
let DatatypeConstrs' (d : DatatypeData) :=
  map ?(TripleProduct init$string ConstrData ConstrFunctor) ?ConstrFunctor (pr33 ?init$string ?ConstrData ?ConstrFunctor)
    (DatatypeConstrs d).

let toConstrData (term : Term) : ConstrData :=
  recursionTerm ?ConstrData
    (λ v : init$var. noArgConstrData (varTerm v))
    (λ s : init$sort. noArgConstrData (sortTerm s))
    (λ b : Binder. λ n : init$string. λ T : Term. λ t : Term. λ recT : ConstrData. λ rect : ConstrData.
      b ?ConstrData
        (noArgConstrData (binderTerm b n T t)) (noArgConstrData (binderTerm b n T t))
        (consArgConstrData (mkParam false (mkPreParam n T)) rect)
        (consArgConstrData (mkParam true (mkPreParam n T)) rect))
    (λ t : Term. λ l : List App. λ _ : ConstrData. λ _ : List (Product Bool ConstrData). noArgConstrData (appLTerm t l))
    (λ u : Term. λ recu : ConstrData. recu)
    (reduceTerm term).

let fromConstrData (d : ConstrData) : Term := foldWithPi (ConstrDataTelescope d) (ConstrDataTerm d).

let ConstrFunctorF (name : init$string) (f : ConstrFunctor) : Term :=
  lambdaTerm name θ{*} (f ?Term
    (sVarTerm name)
    (λ t : Term. t)
    (λ n : init$string. λ t : Term. λ recF : Term. piTerm n t recF)
    (λ s : init$string. λ recF : Term. λ recF' : Term. θ{DSum γ{recF} γ{lambdaTerm s recF recF'}})).

let ConstrsFunctorF' (name : init$string) : Π _ : List ConstrFunctor. Term :=
  recursionList ?ConstrFunctor ?Term θ{constF Void}
    (λ f : ConstrFunctor. λ fs : List ConstrFunctor. λ rec : Term. θ{FunctorSumF γ{ConstrFunctorF name f} γ{rec}}).
let ConstrsFunctorF (d : DatatypeData) : Term := ConstrsFunctorF' (DatatypeName d) (DatatypeConstrs' d).

let mapDSum [A, A' : *] [B : Π _ : A. *] [B' : Π _ : A'. *]
            (f : Π _ : A. A') (g : Π a : A. Π _ : B a. B' (f a)) (x : DSum A B) : DSum A' B' :=
  inductionDSum ?A ?B ?(λ _ : DSum A B. DSum A' B') (λ a : A. λ b : B a. pair ?A' ?B' (f a) (g a b)) x.
let mapDHom [A : *] [B, C : Π _ : A. *] (f : Π a : A. Π _ : B a. C a) (x : Π a : A. B a) : Π a : A. C a := λ a : A. f a (x a).

let ConstrFunctorFunctor (name : init$string) (outerFun : ConstrFunctor) : Term :=
  θ{Λ DataX : *. Λ DataY : *. λ DataF : (Π _ : DataX. DataY). γ{recursionConstrFunctor ?Term
    θ{idFunctor ?DataX ?DataY DataF}
    (λ t : Term. θ{constFunctor γ{t} ?DataX ?DataY DataF})
    (λ n : init$string. λ t : Term. λ fun : ConstrFunctor. λ intFmap : Term.
      θ{mapDHom ?γ{t} ?γ{lambdaTerm n t θ{γ{ConstrFunctorF name fun} DataX}} ?γ{lambdaTerm n t θ{γ{ConstrFunctorF name fun} DataY}}
                γ{lambdaTerm n t intFmap}})
    (λ s : init$string. λ fun : ConstrFunctor. λ fun' : ConstrFunctor. λ intFmap : Term. λ intFmap' : Term.
      θ{mapDSum ?(γ{ConstrFunctorF name fun} DataX) ?(γ{ConstrFunctorF name fun} DataY)
                ?γ{lambdaTerm s θ{γ{ConstrFunctorF name fun} DataX} θ{γ{ConstrFunctorF name fun'} DataX}}
                ?γ{lambdaTerm s θ{γ{ConstrFunctorF name fun} DataY} θ{γ{ConstrFunctorF name fun'} DataY}}
                γ{intFmap}
                γ{lambdaTerm s θ{γ{ConstrFunctorF name fun} DataX} intFmap'}}) outerFun}}.

let ConstrsFunctorFunctor (d : DatatypeData) : Term :=
  (λ name : init$string.
    recursionList ?ConstrFunctor ?Term θ{constFunctor Void}
      (λ f : ConstrFunctor. λ fs : List ConstrFunctor. λ rec : Term.
        θ{FunctorSumFunctor ?γ{ConstrFunctorF name f} ?γ{ConstrsFunctorF' name fs} γ{ConstrFunctorFunctor name f} γ{rec}})
      (DatatypeConstrs' d))
  (DatatypeName d).

let datatypeToAlgTerms (name : init$string) (apply : List App) (constrs : List ConstrFunctor) : List Term :=
  pr2 ?Term ?(List Term) (foldl ?(Product ConstrFunctor (List ConstrFunctor)) ?(Product Term (List Term))
    (λ acc : Product Term (List Term). λ arg : Product ConstrFunctor (List ConstrFunctor).
      (λ lfun : ConstrFunctor. λ rfuns : List ConstrFunctor. λ alg : Term. λ algs : List Term.
        prodPair ?Term ?(List Term)
          θ{composeRight ?γ{appLTerm (sVarTerm name) apply} ?γ{ConstrFunctorF name lfun}
                         ?γ{ConstrsFunctorF' name rfuns} γ{alg}}
          (cons ?Term
                θ{composeLeft ?γ{appLTerm (sVarTerm name) apply} ?γ{ConstrFunctorF name lfun}
                              ?γ{ConstrsFunctorF' name rfuns} γ{alg}}
                algs))
        (pr1 ?ConstrFunctor ?(List ConstrFunctor) arg)
        (pr2 ?ConstrFunctor ?(List ConstrFunctor) arg)
        (pr1 ?Term ?(List Term) acc)
        (pr2 ?Term ?(List Term) acc))
    (reverse ?(Product ConstrFunctor (List ConstrFunctor)) (initsNonEmpty ?ConstrFunctor constrs))
    (prodPair ?Term ?(List Term) (appLTerm (sVarTerm (stringApp name "Constrs")) apply) [Term|])).

let Dcurry [A : *] [B : Π _ : A. *] [C : *] (f : Π _ : DSum A B. C) (a : A) (b : B a) : C := f (pair ?A ?B a b).
let removeUnit [A : *] (f : Π _ : Unit. A) : A := f tt.

let convertAlgToConstr (name : init$string) (tel : Telescope) (d : ConstrData) (alg : Term) : Term :=
  foldWithLambdas (ConstrDataTelescope d) (foldr ?(Π _ : Term. Term) ?Term
    (λ acc : Term. λ f : Π _ : Term. Term. f acc)
    (recursionList ?Param ?(List (Π _ : Term. Term))
      [Π _ : Term. Term | λ t : Term. θ{removeUnit ?γ{ConstrDataTerm d} γ{t}}]
      (λ p : Param. λ ps : List Param. λ rec : List (Π _ : Term. Term).
        cons ?(Π _ : Term. Term)
          (λ t : Term.
            θ{Dcurry ?γ{paramType p}
                     ?γ{lambdaTerm (paramName p) (paramType p)
                                   θ{γ{ConstrFunctorF name (catchError ?ConstrFunctor ?ConstrFunctor
                                                      (constrToFunctor (mkConstrData ps (ConstrDataTerm d)) (getMatch name tel))
                                                      (λ _ : init$string. constConstrFunctor (sVarTerm "BUG! This should be impossible!"))
                                                      (λ fun : ConstrFunctor. fun))}
                                   γ{ConstrDataTerm d}}}
                     ?γ{ConstrDataTerm d} γ{t} γ{natToVar (length ?Param ps)}})
          rec)
      (ConstrDataTelescope d))
    alg).

let datatypeToConstrs'
  (name : init$string) (t : Telescope) (apply : List App) (constrs : List ConstrFunctor)
  (constrNames : List init$string) (constrDatas : List ConstrData) : List LetInfo :=
  zipWith3 ?init$string ?ConstrData ?Term ?LetInfo
    (λ constrName : init$string. λ d : ConstrData. λ alg : Term. mkLetInfo constrName (convertAlgToConstr name t d alg) (nothing' ?Term))
    (reverse ?init$string constrNames) (reverse ?ConstrData constrDatas) (datatypeToAlgTerms name apply constrs).

let telescopeToApp (tel : Telescope) : List App := map ?Param ?App (λ p : Param. mkApp (paramErased p) (sVarTerm (paramName p))) tel.

let datatypeToConstrs (d : DatatypeData) : List LetInfo :=
  datatypeToConstrs' (DatatypeName d) (DatatypeTelescope d) (telescopeToApp (DatatypeTelescope d)) (DatatypeConstrs' d)
    (map ?(TripleProduct init$string ConstrData ConstrFunctor) ?init$string (pr31 ?init$string ?ConstrData ?ConstrFunctor) (DatatypeConstrs d))
    (map ?(TripleProduct init$string ConstrData ConstrFunctor) ?ConstrData (pr32 ?init$string ?ConstrData ?ConstrFunctor) (DatatypeConstrs d)).

let datatypeToLet (d : DatatypeData) : init$newStmt :=
  (λ name : Π _ : init$string. init$string. λ apply : List App.
    seqNewStmts (map ?LetInfo ?init$newStmt (λ i : LetInfo. letInfoToNewStmt (appendTelToLetInfo (DatatypeTelescope d) i))
      (app ?LetInfo [LetInfo|
        mkLetInfo (name "F") (ConstrsFunctorF d) (just' ?Term θ{Π _ : *. *}),
        mkLetInfo (name "Functor") (ConstrsFunctorFunctor d) (just' ?Term θ{Functor γ{ConstrsFunctorF d}}),
        mkLetInfo (name "") θ{FixC γ{appLTerm (sVarTerm (name "F")) apply}} (just' ?Term θ{*}),
        mkLetInfo (name "Constrs")
                  θ{inC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "Functor")) apply}}
                  (just' ?Term θ{AlgC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "")) apply}})]
        (datatypeToConstrs d))))
  (stringApp (DatatypeName d)) (telescopeToApp (DatatypeTelescope d)).