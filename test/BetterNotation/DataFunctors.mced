let ConstrFunctor := ∀ X : *.
  Π _ : X. -- id
  Π _ : (Π _ : Term. X). -- const
  Π _ : (Π _ : init$string. Π _ : Term. Π _ : X. X). -- covHom with inner functor
  Π _ : (Π _ : init$string. Π _ : X. Π _ : X. X). -- dependent pair
  X.

let idConstrFunctor := Λ X : *.
  λ i : X.
  λ _ : (Π _ : Term. X).
  λ _ : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ _ : (Π _ : init$string. Π _ : X. Π _ : X. X).
  i.

let constConstrFunctor := λ t : Term. Λ X : *.
  λ _ : X.
  λ c : (Π _ : Term. X).
  λ _ : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ _ : (Π _ : init$string. Π _ : X. Π _ : X. X).
  c t.

let covDHomConstrFunctor := λ n : init$string. λ t : Term. λ f : ConstrFunctor. Λ X : *.
  λ i : X.
  λ c : (Π _ : Term. X).
  λ h : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ p : (Π _ : init$string. Π _ : X. Π _ : X. X).
  h n t (f ?X i c h p).

let pairConstrFunctor := λ s : init$string. λ f : ConstrFunctor. λ f' : ConstrFunctor. Λ X : *.
  λ i : X.
  λ c : (Π _ : Term. X).
  λ h : (Π _ : init$string. Π _ : Term. Π _ : X. X).
  λ p : (Π _ : init$string. Π _ : X. Π _ : X. X).
  p s (f ?X i c h p) (f' ?X i c h p).

let recursionConstrFunctor [X : *]
  (idf : X)
  (constf : (Π _ : Term. X))
  (covHomf : (Π _ : init$string. Π _ : Term. Π _ : ConstrFunctor. Π _ : X. X))
  (pairf : (Π _ : init$string. Π _ : ConstrFunctor. Π _ : ConstrFunctor. Π _ : X. Π _ : X. X))
  (f : ConstrFunctor) : X :=
  pr1 ?X ?ConstrFunctor (f ?(Product X ConstrFunctor)
    (prodPair ?X ?ConstrFunctor idf idConstrFunctor)
    (λ t : Term. prodPair ?X ?ConstrFunctor (constf t) (constConstrFunctor t))
    (λ n : init$string. λ t : Term. λ t' : Product X ConstrFunctor.
      prodPair ?X ?ConstrFunctor
        (covHomf n t (pr2 ?X ?ConstrFunctor t') (pr1 ?X ?ConstrFunctor t'))
        (covDHomConstrFunctor n t (pr2 ?X ?ConstrFunctor t')))
    (λ s : init$string. λ t : Product X ConstrFunctor. λ t' : Product X ConstrFunctor.
      prodPair ?X ?ConstrFunctor
        (pairf s (pr2 ?X ?ConstrFunctor t) (pr2 ?X ?ConstrFunctor t') (pr1 ?X ?ConstrFunctor t) (pr1 ?X ?ConstrFunctor t'))
        (pairConstrFunctor s (pr2 ?X ?ConstrFunctor t) (pr2 ?X ?ConstrFunctor t')))).

let ConstrFunctorF (name : init$string) (f : ConstrFunctor) : Term :=
  lambdaTerm name θ{*} (f ?Term
    (sVarTerm name)
    (λ t : Term. t)
    (λ n : init$string. λ t : Term. λ recF : Term. piTerm n t recF)
    (λ s : init$string. λ recF : Term. λ recF' : Term. θ{DSum γ{recF} γ{lambdaTerm s recF recF'}})).

let DatatypeData := TripleProduct init$string Telescope (List (Product init$string ConstrFunctor)).
let mkDatatypeData := mkTripleProduct ?init$string ?Telescope ?(List (Product init$string ConstrFunctor)).
let DatatypeName := pr31 ?init$string ?Telescope ?(List (Product init$string ConstrFunctor)).
let DatatypeTelescope := pr32 ?init$string ?Telescope ?(List (Product init$string ConstrFunctor)).
let DatatypeConstrs := pr33 ?init$string ?Telescope ?(List (Product init$string ConstrFunctor)).
let DatatypeConstrs' (d : DatatypeData) :=
  map ?(Product init$string ConstrFunctor) ?ConstrFunctor (pr2 ?init$string ?ConstrFunctor) (DatatypeConstrs d).

let ConstrsFunctorF' (name : init$string) : Π _ : List ConstrFunctor. Term :=
  recursionList ?ConstrFunctor ?Term θ{constF Void}
    (λ f : ConstrFunctor. λ fs : List ConstrFunctor. λ rec : Term. θ{FunctorSumF γ{ConstrFunctorF name f} γ{rec}}).
let ConstrsFunctorF (d : DatatypeData) : Term := ConstrsFunctorF' (DatatypeName d) (DatatypeConstrs' d).

let mapDSum [A, A' : *] [B : Π _ : A. *] [B' : Π _ : A'. *]
            (f : Π _ : A. A') (g : Π a : A. Π _ : B a. B' (f a)) (x : DSum A B) : DSum A' B' :=
  inductionDSum ?A ?B ?(λ _ : DSum A B. DSum A' B') (λ a : A. λ b : B a. pair ?A' ?B' (f a) (g a b)) x.
let mapDHom [A : *] [B, C : Π _ : A. *] (f : Π a : A. Π _ : B a. C a) (x : Π a : A. B a) : Π a : A. C a := λ a : A. f a (x a).

let ConstrFunctorFunctor (name : init$string) (outerFun : ConstrFunctor) : Term :=
  θ{Λ DataX : *. Λ DataY : *. λ DataF : (Π _ : DataX. DataY). γ{recursionConstrFunctor ?Term
    θ{idFunctor ?DataX ?DataY DataF}
    (λ t : Term. θ{constFunctor γ{t} ?DataX ?DataY DataF})
    (λ n : init$string. λ t : Term. λ fun : ConstrFunctor. λ intFmap : Term.
      θ{mapDHom ?γ{t} ?γ{lambdaTerm n t θ{γ{ConstrFunctorF name fun} DataX}} ?γ{lambdaTerm n t θ{γ{ConstrFunctorF name fun} DataY}}
                γ{lambdaTerm n t intFmap}})
    (λ s : init$string. λ fun : ConstrFunctor. λ fun' : ConstrFunctor. λ intFmap : Term. λ intFmap' : Term.
      θ{mapDSum ?(γ{ConstrFunctorF name fun} DataX) ?(γ{ConstrFunctorF name fun} DataY)
                ?γ{lambdaTerm s θ{γ{ConstrFunctorF name fun} DataX} θ{γ{ConstrFunctorF name fun'} DataX}}
                ?γ{lambdaTerm s θ{γ{ConstrFunctorF name fun} DataY} θ{γ{ConstrFunctorF name fun'} DataY}}
                γ{intFmap}
                γ{lambdaTerm s θ{γ{ConstrFunctorF name fun} DataX} intFmap'}}) outerFun}}.

let ConstrsFunctorFunctor (d : DatatypeData) : Term :=
  (λ name : init$string.
    recursionList ?ConstrFunctor ?Term θ{constFunctor Void}
      (λ f : ConstrFunctor. λ fs : List ConstrFunctor. λ rec : Term.
        θ{FunctorSumFunctor ?γ{ConstrFunctorF name f} ?γ{ConstrsFunctorF' name fs} γ{ConstrFunctorFunctor name f} γ{rec}})
      (DatatypeConstrs' d))
  (DatatypeName d).

let datatypeToAlgTerms (name : init$string) (apply : List App) (constrs : List ConstrFunctor) : List Term :=
  pr2 ?Term ?(List Term) (foldl ?(Product ConstrFunctor (List ConstrFunctor)) ?(Product Term (List Term))
    (λ acc : Product Term (List Term). λ arg : Product ConstrFunctor (List ConstrFunctor).
      (λ lfun : ConstrFunctor. λ rfuns : List ConstrFunctor. λ alg : Term. λ algs : List Term.
        prodPair ?Term ?(List Term)
          θ{composeRight ?γ{appLTerm (sVarTerm (stringApp name "Type")) apply} ?γ{ConstrFunctorF name lfun}
                         ?γ{ConstrsFunctorF' name rfuns} γ{alg}}
          (cons ?Term
                θ{composeLeft ?γ{appLTerm (sVarTerm (stringApp name "Type")) apply} ?γ{ConstrFunctorF name lfun}
                              ?γ{ConstrsFunctorF' name rfuns} γ{alg}}
                algs))
        (pr1 ?ConstrFunctor ?(List ConstrFunctor) arg)
        (pr2 ?ConstrFunctor ?(List ConstrFunctor) arg)
        (pr1 ?Term ?(List Term) acc)
        (pr2 ?Term ?(List Term) acc))
    (reverse ?(Product ConstrFunctor (List ConstrFunctor)) (initsNonEmpty ?ConstrFunctor constrs))
    (prodPair ?Term ?(List Term) (appLTerm (sVarTerm (stringApp name "Constrs")) apply) [Term|])).

let datatypeToConstrs'
  (name : init$string) (apply : List App) (constrs : List ConstrFunctor) (constrNames : List init$string) : List LetInfo :=
  zipWith ?init$string ?Term ?LetInfo (λ constrName : init$string. λ alg : Term. mkLetInfo constrName alg (nothing' ?Term))
          (reverse ?init$string constrNames) (datatypeToAlgTerms name apply constrs).

let telescopeToApp (tel : Telescope) : List App := map ?Param ?App (λ p : Param. mkApp (paramErased p) (sVarTerm (paramName p))) tel.

let datatypeToConstrs (d : DatatypeData) : List LetInfo :=
  datatypeToConstrs' (DatatypeName d) (telescopeToApp (DatatypeTelescope d)) (DatatypeConstrs' d)
    (map ?(Product init$string ConstrFunctor) ?init$string (pr1 ?init$string ?ConstrFunctor) (DatatypeConstrs d)).

let datatypeToLet (d : DatatypeData) : init$newStmt :=
  (λ name : Π _ : init$string. init$string. λ apply : List App.
    seqNewStmts (map ?LetInfo ?init$newStmt (λ i : LetInfo. letInfoToNewStmt (appendTelToLetInfo (DatatypeTelescope d) i))
      (app ?LetInfo [LetInfo|
        mkLetInfo (name "F") (ConstrsFunctorF d) (just' ?Term θ{Π _ : *. *}),
        mkLetInfo (name "Functor") (ConstrsFunctorFunctor d) (just' ?Term θ{Functor γ{ConstrsFunctorF d}}),
        mkLetInfo (name "Type") θ{FixC γ{appLTerm (sVarTerm (name "F")) apply}} (just' ?Term θ{*}),
        mkLetInfo (name "Constrs")
                  θ{inC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "Functor")) apply}}
                  (just' ?Term θ{AlgC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "Type")) apply}})]
        (datatypeToConstrs d))))
  (stringApp (DatatypeName d)) (telescopeToApp (DatatypeTelescope d)).