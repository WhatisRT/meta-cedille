--------------------------------------------------------------------------------
-- Parsing datatype declarations
--------------------------------------------------------------------------------

let Constr := Product init$string Term.
let ConstrName := pr1 ?init$string ?Term.
let ConstrType := pr2 ?init$string ?Term.
let mkConstr (n : init$string) (t : Term) := prodPair ?init$string ?Term n t.

let init$constr$_string__space_=colon=_space__multiTerm_
  (name : init$string) (_, _ : init$space) (type : Term) : Constr := mkConstr name type.

let Constrs := List Constr.

let init$constrs$ : Constrs := nil ?Constr.
let init$constrs$=pipe=_space__constr__constrs_ (_ : init$space) (c : Constr) (cs : Constrs) := cons ?Constr c cs.

let init$data$_string__space__telescope_where_space__constrs_
  (name : init$string) (_ : init$space) (t : Telescope) (_ : init$space) (cs : Constrs) : Error DatatypeData :=
    mkDatatypeData name t cs.

let init$newStmt'$data_space__data_=dot= (_ : init$space) (d : Error DatatypeData) : init$newStmt :=
  catchError ?DatatypeData ?init$newStmt d (Î» e : init$string. echoStmt (stringApp "Error: not a valid datatype! " e)) datatypeToLet.

o-seteval [evalNewStmt emptyEvaluatorState] init newStmt.