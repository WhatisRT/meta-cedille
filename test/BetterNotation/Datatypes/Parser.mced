--------------------------------------------------------------------------------
-- Parsing datatype declarations
--------------------------------------------------------------------------------

let Entries := List PreParam.

let DatatypeDecl := TripleProduct init$string Telescope Entries.

let toRecordDecl (d : DatatypeDecl) : DatatypeDecl :=
  recursionTripleProduct ?init$string ?Telescope ?Entries ?DatatypeDecl
    (位 name : init$string. 位 t : Telescope. 位 es : Entries.
      mkTripleProduct ?init$string ?Telescope ?Entries name t
        [PreParam| prodPair ?init$string ?Term
          (stringApp "mk" name)
          (applyMultiBinder piBinder es (appLTerm (sVarTerm name) (telescopeToApp t)))])
    d.

let DatatypeDeclToStmt (d : DatatypeDecl) (m : init$string) : init$newStmt :=
  catchError ?DatatypeData ?init$newStmt
    (recursionTripleProduct ?init$string ?Telescope ?Entries ?(Error DatatypeData) mkDatatypeData d)
    (位 e : init$string. echoStmt (stringApp m e))
    datatypeToLet.

let init$entry$_string__space_=colon=_space__multiTerm_
  (name : init$string) (_, _ : init$space) (type : Term) : PreParam := mkPreParam name type.

let init$entries$ : Entries := nil ?PreParam.
let init$entries$=pipe=_space__entry__entries_ (_ : init$space) (e : PreParam) (es : Entries) := cons ?PreParam e es.

let init$data$_string__space__telescope_where_space__entries_
  (name : init$string) (_ : init$space) (t : Telescope) (_ : init$space) (es : Entries)
  : DatatypeDecl :=
    mkTripleProduct ?init$string ?Telescope ?Entries name t es.

let init$newStmt'$data_space__data_=dot= (_ : init$space) (d : DatatypeDecl) : init$newStmt :=
  DatatypeDeclToStmt d "Error: not a valid datatype! ".

let init$newStmt'$record_space__data_=dot= (_ : init$space) (d : DatatypeDecl) : init$newStmt :=
  DatatypeDeclToStmt (toRecordDecl d) "Error: not a valid record! ".

o-seteval [evalNewStmt emptyEvaluatorState] init newStmt.