--------------------------------------------------------------------------------
-- This file provides the function datatypeToLet
--
-- It takes a `DatatypeData` and turns it into all the definitions for a
-- datatype, including constructors and a fold. Some aspects are still
-- incomplete.
--------------------------------------------------------------------------------

let DatatypeData := TripleProduct init$string Telescope (List (TripleProduct init$string ConstrData ConstrFunctorData)).
let mkDatatypeData' := mkTripleProduct ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeName := pr31 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeTelescope := pr32 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeConstrs := pr33 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).

let DatatypeConstrs' (d : DatatypeData) : List ConstrFunctorData :=
  map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrFunctorData
      (pr33 ?init$string ?ConstrData ?ConstrFunctorData)
      (DatatypeConstrs d).

let mkDatatypeData (name : init$string) (t : Telescope) (cs : List (Product init$string Term)) : Error DatatypeData :=
  mapError ?(List (TripleProduct init$string ConstrData ConstrFunctorData)) ?DatatypeData (mkDatatypeData' name t)
           (traverseErrorList ?(Product init$string Term) ?(TripleProduct init$string ConstrData ConstrFunctorData)
                              (λ c : Product init$string Term.
                                mapError ?ConstrFunctorData ?(TripleProduct init$string ConstrData ConstrFunctorData)
                                         (mkTripleProduct ?init$string ?ConstrData ?ConstrFunctorData
                                                          (pr1 ?init$string ?Term c) (toConstrData (pr2 ?init$string ?Term c)))
                                         (constrToFunctorData (toConstrData (pr2 ?init$string ?Term c)) (getMatch name t))) cs).

let DatatypeF (d : DatatypeData) : Term := ConstrsFunctorF' (DatatypeName d) (DatatypeConstrs' d).
let DatatypeFunctor (d : DatatypeData) : Term := ConstrsFunctorFunctor' (DatatypeName d) (DatatypeConstrs' d).

-- Helper functions
let preCurryHelper (curry : Term) (name : init$string) (tel : Telescope) (t : Term)
  (p : CFParam) (ps : List CFParam) : Term :=
  θ{γ{curry} ?γ{ApplyConstrFunctor t (cfParamFunctor p)} ?γ{lambdaTerm (cfParamName p) (ApplyConstrFunctor t (cfParamFunctor p)) θ{γ{ConstrFunctorF name ps} γ{t}}} ?γ{t}}.

let curryHelper := preCurryHelper θ{Dcurry}.
let uncurryHelper := preCurryHelper θ{Duncurry}.

-- Generate algebras for constructors
let datatypeToAlgTerms (name : init$string) (apply : List App) (constrs : List ConstrFunctorData) : List Term :=
  pr2 ?Term ?(List Term) (foldl ?(Product ConstrFunctorData (List ConstrFunctorData)) ?(Product Term (List Term))
    (λ acc : Product Term (List Term). λ arg : Product ConstrFunctorData (List ConstrFunctorData).
      (λ applyCompose : Π _ : Term. Term. prodPair ?Term ?(List Term)
          (applyCompose θ{composeRight})
          (cons ?Term (applyCompose θ{composeLeft}) (pr2 ?Term ?(List Term) acc)))
        (λ t : Term. θ{γ{t} ?γ{appLTerm (sVarTerm name) apply}
                            ?γ{ConstrFunctorF name (pr1 ?ConstrFunctorData ?(List ConstrFunctorData) arg)}
                            ?γ{ConstrsFunctorF' name (pr2 ?ConstrFunctorData ?(List ConstrFunctorData) arg)}
                            γ{(pr1 ?Term ?(List Term) acc)}}))
    (reverse ?(Product ConstrFunctorData (List ConstrFunctorData)) (initsNonEmpty ?ConstrFunctorData constrs))
    (prodPair ?Term ?(List Term) (appLTerm (sVarTerm (stringApp name "Constrs")) apply) [Term|])).

-- Convert the algebra corresponding to a single constructor to a proper constructor
let convertAlgToConstr (name : init$string) (tel : Telescope) (type : Term) (d : ConstrFunctorData) (alg : Term) : Term :=
  foldWithLambdas (functorDataToTelescope d type) (foldr ?(Π _ : Term. Term) ?Term
    (λ acc : Term. λ f : Π _ : Term. Term. f acc)
    (recursionList ?(Product init$string ConstrFunctor) ?(List (Π _ : Term. Term))
      [Π _ : Term. Term | λ t : Term. θ{removeUnit ?γ{type} γ{t}}]
      (λ x : Product init$string ConstrFunctor. λ xs : List (Product init$string ConstrFunctor). λ rec : List (Π _ : Term. Term).
        cons ?(Π _ : Term. Term)
          (λ t : Term. θ{γ{curryHelper name tel type x xs} γ{t} γ{natToVar (length ?(Product init$string ConstrFunctor) xs)}}) rec)
      d)
    alg).

let datatypeToConstrs'
  (name : init$string) (t : Telescope) (apply : List App) (constrNames : List init$string)
  (constrs : List ConstrData) (constrDatas : List ConstrFunctorData) : List LetInfo :=
  zipWith4 ?init$string ?ConstrData ?ConstrFunctorData ?Term ?LetInfo
    (λ constrName : init$string. λ d : ConstrData. λ funD : ConstrFunctorData. λ alg : Term.
      mkLetInfo constrName (convertAlgToConstr name t (ConstrDataTerm d) funD alg) (nothing ?Term))
    (reverse ?init$string constrNames) (reverse ?ConstrData constrs)
    (reverse ?ConstrFunctorData constrDatas)
    (datatypeToAlgTerms name apply constrDatas).

let telescopeToApp (tel : Telescope) : List App := map ?Param ?App (λ p : Param. mkApp (paramErased p) (sVarTerm (paramName p))) tel.

let datatypeToConstrs (d : DatatypeData) : List LetInfo :=
  datatypeToConstrs' (DatatypeName d) (DatatypeTelescope d) (telescopeToApp (DatatypeTelescope d))
    (map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?init$string
      (pr31 ?init$string ?ConstrData ?ConstrFunctorData) (DatatypeConstrs d))
    (map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrData
      (pr32 ?init$string ?ConstrData ?ConstrFunctorData) (DatatypeConstrs d))
    (map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrFunctorData
      (pr33 ?init$string ?ConstrData ?ConstrFunctorData) (DatatypeConstrs d)).

-- -- Transform inputs to Π _ : F X. X
-- let uncurryFoldArg (c : ConstrFunctorData) (tel : Telescope) (arg : Term) :=
--   recursionList ?Param ?Term
--     θ{γ{arg} n n-1 ... 0}
--     (λ p : Param. λ ps : List Param. λ rec : Term.
--       θ{Duncurry ?γ{ParamType p} ?... ?X γ{lambdaTerm "_" (ParamType p) rec}})
--     tel

let datatypeToFold (name : init$string) (constrs : List ConstrFunctorData) (apply : List App) : Term :=
  θ{λ X : *. γ{foldl ?ConstrFunctorData ?Term
    (λ t : Term. λ c : ConstrFunctorData. lambdaTerm "_" θ{Π _ : γ{ConstrFunctorF name c} X. X} t)
    constrs
    θ{foldC γ{appLTerm (sVarTerm (stringApp name "F")) apply} ?X
      γ{recursionList ?(Product ConstrFunctorData (List ConstrFunctorData)) ?Term
        θ{voidElim ?X}
        (λ c : Product ConstrFunctorData (List ConstrFunctorData).
        λ cs : List (Product ConstrFunctorData (List ConstrFunctorData)).
        λ t : Term.
          θ{sumAlg ?X ?γ{ConstrFunctorF name (pr1 ?ConstrFunctorData ?(List ConstrFunctorData) c)}
                   ?γ{ConstrsFunctorF' name (pr2 ?ConstrFunctorData ?(List ConstrFunctorData) c)}
                   γ{natToVar (length ?(Product ConstrFunctorData (List ConstrFunctorData)) cs)} γ{t}})
        (initsNonEmpty ?ConstrFunctorData constrs)}}}}.

let datatypeToLet (d : DatatypeData) : init$newStmt :=
  (λ name : Π _ : init$string. init$string. λ apply : List App.
    seqNewStmts (map ?LetInfo ?init$newStmt (λ i : LetInfo. letInfoToNewStmt (appendTelToLetInfo (DatatypeTelescope d) i))
      (app ?LetInfo [LetInfo|
        mkLetInfo (name "F") (DatatypeF d) (just ?Term θ{Π _ : *. *}),
        mkLetInfo (name "Functor") (DatatypeFunctor d) (just ?Term θ{Functor γ{DatatypeF d}}),
        mkLetInfo (name "") θ{FixC γ{appLTerm (sVarTerm (name "F")) apply}} (just ?Term θ{*}),
        mkLetInfo (name "Constrs")
                  θ{inC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "Functor")) apply}}
                  (just ?Term θ{AlgC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "")) apply}}),
        mkLetInfo (name "Fold") (datatypeToFold (DatatypeName d) (DatatypeConstrs' d) apply) (nothing ?Term)]
        (datatypeToConstrs d))))
  (stringApp (DatatypeName d)) (telescopeToApp (DatatypeTelescope d)).