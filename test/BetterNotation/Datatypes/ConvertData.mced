--------------------------------------------------------------------------------
-- This file provides the function datatypeToLet
--
-- It takes a `DatatypeData` and turns it into all the definitions for a
-- datatype, including constructors and a fold. Some aspects are still
-- incomplete.
--------------------------------------------------------------------------------

let DatatypeData := TripleProduct init$string Telescope (List (TripleProduct init$string ConstrData ConstrFunctorData)).
let mkDatatypeData' := mkTripleProduct ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeName := pr31 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeTelescope := pr32 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeConstrs := pr33 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).

let DatatypeConstrs' (d : DatatypeData) : List ConstrFunctorData :=
  map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrFunctorData
      (pr33 ?init$string ?ConstrData ?ConstrFunctorData)
      (DatatypeConstrs d).

let mkDatatypeData (name : init$string) (t : Telescope) (cs : List (Product init$string Term)) : Error DatatypeData :=
  mapError ?(List (TripleProduct init$string ConstrData ConstrFunctorData)) ?DatatypeData (mkDatatypeData' name t)
           (traverseErrorList ?(Product init$string Term) ?(TripleProduct init$string ConstrData ConstrFunctorData)
                              (λ c : Product init$string Term.
                                mapError ?ConstrFunctorData ?(TripleProduct init$string ConstrData ConstrFunctorData)
                                         (mkTripleProduct ?init$string ?ConstrData ?ConstrFunctorData
                                                          (pr1 ?init$string ?Term c) (toConstrData (pr2 ?init$string ?Term c)))
                                         (constrToFunctorData (toConstrData (pr2 ?init$string ?Term c)) (getMatch name t))) cs).

let DatatypeF (d : DatatypeData) : Term := ConstrsFunctorF' (DatatypeName d) (DatatypeConstrs' d).
let DatatypeFunctor (d : DatatypeData) : Term := ConstrsFunctorFunctor' (DatatypeName d) (DatatypeConstrs' d).

let datatypeToAlgTerms (name : init$string) (apply : List App) (constrs : List ConstrFunctorData) : List Term :=
  pr2 ?Term ?(List Term) (foldl ?(Product ConstrFunctorData (List ConstrFunctorData)) ?(Product Term (List Term))
    (λ acc : Product Term (List Term). λ arg : Product ConstrFunctorData (List ConstrFunctorData).
      (λ lfun : ConstrFunctorData. λ rfuns : List ConstrFunctorData. λ alg : Term. λ algs : List Term.
        prodPair ?Term ?(List Term)
          θ{composeRight ?γ{appLTerm (sVarTerm name) apply} ?γ{ConstrFunctorF name lfun}
                         ?γ{ConstrsFunctorF' name rfuns} γ{alg}}
          (cons ?Term
                θ{composeLeft ?γ{appLTerm (sVarTerm name) apply} ?γ{ConstrFunctorF name lfun}
                              ?γ{ConstrsFunctorF' name rfuns} γ{alg}}
                algs))
        (pr1 ?ConstrFunctorData ?(List ConstrFunctorData) arg)
        (pr2 ?ConstrFunctorData ?(List ConstrFunctorData) arg)
        (pr1 ?Term ?(List Term) acc)
        (pr2 ?Term ?(List Term) acc))
    (reverse ?(Product ConstrFunctorData (List ConstrFunctorData)) (initsNonEmpty ?ConstrFunctorData constrs))
    (prodPair ?Term ?(List Term) (appLTerm (sVarTerm (stringApp name "Constrs")) apply) [Term|])).

-- Convert the algebra corresponding to a single constructor to a proper constructor
let convertAlgToConstr (name : init$string) (tel : Telescope) (d : ConstrData) (funD : ConstrFunctorData) (alg : Term) : Term :=
  foldWithLambdas (ConstrDataTelescope d) (foldr ?(Π _ : Term. Term) ?Term
    (λ acc : Term. λ f : Π _ : Term. Term. f acc)
    (recursionList ?Param ?(List (Π _ : Term. Term))
      [Π _ : Term. Term | λ t : Term. θ{removeUnit ?γ{ConstrDataTerm d} γ{t}}]
      (λ p : Param. λ ps : List Param. λ rec : List (Π _ : Term. Term).
        cons ?(Π _ : Term. Term)
          (λ t : Term.
            θ{Dcurry ?γ{paramType p}
                     ?γ{lambdaTerm (paramName p) (paramType p)
                        θ{γ{ConstrFunctorF name
                          (catchError ?ConstrFunctorData ?ConstrFunctorData
                            (constrToFunctorData (mkConstrData ps (ConstrDataTerm d)) (getMatch name tel))
                            (λ _ : init$string. [Product init$string ConstrFunctor|])
                            -- If we can parse the whole constructor properly
                            -- (which we can, because we have `funD`) then we
                            -- should also be able to parse parts properly. Thus
                            -- we should never enter this code path.
                            (λ fun : ConstrFunctorData. fun))}
                        γ{ConstrDataTerm d}}}
                     ?γ{ConstrDataTerm d} γ{t} γ{natToVar (length ?Param ps)}})
          rec)
      (ConstrDataTelescope d))
    alg).

let datatypeToConstrs'
  (name : init$string) (t : Telescope) (apply : List App) (constrNames : List init$string)
  (constrs : List ConstrData) (constrDatas : List ConstrFunctorData) : List LetInfo :=
  zipWith4 ?init$string ?ConstrData ?ConstrFunctorData ?Term ?LetInfo
    (λ constrName : init$string. λ d : ConstrData. λ funD : ConstrFunctorData. λ alg : Term.
      mkLetInfo constrName (convertAlgToConstr name t d funD alg) (nothing ?Term))
    (reverse ?init$string constrNames) (reverse ?ConstrData constrs)
    (reverse ?ConstrFunctorData constrDatas)
    (datatypeToAlgTerms name apply constrDatas).

let telescopeToApp (tel : Telescope) : List App := map ?Param ?App (λ p : Param. mkApp (paramErased p) (sVarTerm (paramName p))) tel.

let datatypeToConstrs (d : DatatypeData) : List LetInfo :=
  datatypeToConstrs' (DatatypeName d) (DatatypeTelescope d) (telescopeToApp (DatatypeTelescope d))
    (map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?init$string
      (pr31 ?init$string ?ConstrData ?ConstrFunctorData) (DatatypeConstrs d))
    (map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrData
      (pr32 ?init$string ?ConstrData ?ConstrFunctorData) (DatatypeConstrs d))
    (map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrFunctorData
      (pr33 ?init$string ?ConstrData ?ConstrFunctorData) (DatatypeConstrs d)).

-- let uncurryFoldArg (c : ConstrFunctor) (tel : Telescope) (arg : Term) :=
--   recursionList ?Param ?Term
--     θ{γ{arg} n n-1 ... 0}
--     (λ p : Param. λ ps : List Param. λ rec : Term.
--       θ{Duncurry ?γ{ParamType p} ?... ?X γ{lambdaTerm "_" (ParamType p) rec}})
--     tel

let datatypeToFold (name : init$string) (constrs : List ConstrFunctorData) (apply : List App) : Term :=
  θ{λ X : *. γ{foldl ?ConstrFunctorData ?Term
    (λ t : Term. λ c : ConstrFunctorData. lambdaTerm "_" θ{Π _ : γ{ConstrFunctorF name c} X. X} t)
    constrs
    θ{foldC γ{appLTerm (sVarTerm (stringApp name "F")) apply} ?X
      γ{recursionList ?(Product ConstrFunctorData (List ConstrFunctorData)) ?Term
        θ{voidElim ?X}
        (λ c : Product ConstrFunctorData (List ConstrFunctorData).
        λ cs : List (Product ConstrFunctorData (List ConstrFunctorData)).
        λ t : Term.
          θ{sumAlg ?X ?γ{ConstrFunctorF name (pr1 ?ConstrFunctorData ?(List ConstrFunctorData) c)}
                   ?γ{ConstrsFunctorF' name (pr2 ?ConstrFunctorData ?(List ConstrFunctorData) c)}
                   γ{natToVar (length ?(Product ConstrFunctorData (List ConstrFunctorData)) cs)} γ{t}})
        (initsNonEmpty ?ConstrFunctorData constrs)}}}}.

let datatypeToLet (d : DatatypeData) : init$newStmt :=
  (λ name : Π _ : init$string. init$string. λ apply : List App.
    seqNewStmts (map ?LetInfo ?init$newStmt (λ i : LetInfo. letInfoToNewStmt (appendTelToLetInfo (DatatypeTelescope d) i))
      (app ?LetInfo [LetInfo|
        mkLetInfo (name "F") (DatatypeF d) (just ?Term θ{Π _ : *. *}),
        mkLetInfo (name "Functor") (DatatypeFunctor d) (just ?Term θ{Functor γ{DatatypeF d}}),
        mkLetInfo (name "") θ{FixC γ{appLTerm (sVarTerm (name "F")) apply}} (just ?Term θ{*}),
        mkLetInfo (name "Constrs")
                  θ{inC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "Functor")) apply}}
                  (just ?Term θ{AlgC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "")) apply}}),
        mkLetInfo (name "Fold") (datatypeToFold (DatatypeName d) (DatatypeConstrs' d) apply) (nothing ?Term)]
        (datatypeToConstrs d))))
  (stringApp (DatatypeName d)) (telescopeToApp (DatatypeTelescope d)).