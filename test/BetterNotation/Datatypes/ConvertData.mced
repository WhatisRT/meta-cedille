--------------------------------------------------------------------------------
-- This file provides the function datatypeToLet
--
-- It takes a `DatatypeData` and turns it into all the definitions for a
-- datatype, including constructors and a fold. Some aspects are still
-- incomplete.
--------------------------------------------------------------------------------

let DatatypeData := TripleProduct init$string Telescope (List (TripleProduct init$string ConstrData ConstrFunctorData)).
let mkDatatypeData' := mkTripleProduct ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeName := pr31 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeTelescope := pr32 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).
let DatatypeConstrs := pr33 ?init$string ?Telescope ?(List (TripleProduct init$string ConstrData ConstrFunctorData)).

let DatatypeConstrs' (d : DatatypeData) : List ConstrFunctorData :=
  map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrFunctorData
      (pr33 ?init$string ?ConstrData ?ConstrFunctorData)
      (DatatypeConstrs d).

let mkDatatypeData (name : init$string) (t : Telescope) (cs : List (Product init$string Term)) : Error DatatypeData :=
  mapError ?(List (TripleProduct init$string ConstrData ConstrFunctorData)) ?DatatypeData (mkDatatypeData' name t)
           (traverseErrorList ?(Product init$string Term) ?(TripleProduct init$string ConstrData ConstrFunctorData)
                              (λ c : Product init$string Term.
                                mapError ?ConstrFunctorData ?(TripleProduct init$string ConstrData ConstrFunctorData)
                                         (mkTripleProduct ?init$string ?ConstrData ?ConstrFunctorData
                                                          (pr1 ?init$string ?Term c) (toConstrData (pr2 ?init$string ?Term c)))
                                         (constrToFunctorData (toConstrData (pr2 ?init$string ?Term c)) (getMatch name t))) cs).

let DatatypeF (d : DatatypeData) : Term := ConstrsFunctorF' (DatatypeName d) (DatatypeConstrs' d).
let DatatypeFunctor (d : DatatypeData) : Term := ConstrsFunctorFunctor' (DatatypeName d) (DatatypeConstrs' d).

-- Helper functions
let preCurryHelper (curry : Term) (name : init$string) (t : Term) (p : CFParam) (ps : List CFParam) : Term :=
  θ{γ{curry} ?γ{ApplyConstrFunctor t (cfParamFunctor p)}
             ?γ{lambdaTerm (cfParamName p) (ApplyConstrFunctor t (cfParamFunctor p)) θ{γ{ConstrFunctorF name ps} γ{t}}}
             ?γ{t}}.

let curryHelper := preCurryHelper θ{Dcurry}.
let uncurryHelper := preCurryHelper θ{Duncurry}.

-- Generate algebras for constructors
let datatypeToAlgTerms (name : init$string) (apply : List App) (constrs : List ConstrFunctorData) : List Term :=
  pr2 ?Term ?(List Term) (foldl ?(Product ConstrFunctorData (List ConstrFunctorData)) ?(Product Term (List Term))
    (λ acc : Product Term (List Term). λ arg : Product ConstrFunctorData (List ConstrFunctorData).
      (λ applyCompose : Π _ : Term. Term. prodPair ?Term ?(List Term)
          (applyCompose θ{composeRight})
          (cons ?Term (applyCompose θ{composeLeft}) (pr2 ?Term ?(List Term) acc)))
        (λ t : Term. θ{γ{t} ?γ{appLTerm (sVarTerm name) apply}
                            ?γ{ConstrFunctorF name (pr1 ?ConstrFunctorData ?(List ConstrFunctorData) arg)}
                            ?γ{ConstrsFunctorF' name (pr2 ?ConstrFunctorData ?(List ConstrFunctorData) arg)}
                            γ{pr1 ?Term ?(List Term) acc}}))
    (reverse ?(Product ConstrFunctorData (List ConstrFunctorData)) (initsNonEmpty ?ConstrFunctorData constrs))
    (prodPair ?Term ?(List Term) (appLTerm (sVarTerm (stringApp name "Constrs")) apply) [Term|])).

-- Convert the algebra corresponding to a single constructor to a proper constructor
let convertAlgToConstr (name : init$string) (type : Term) (d : ConstrFunctorData) (alg : Term) : Term :=
  foldWithLambdas (functorDataToTelescope d type) (foldr ?(Π _ : Term. Term) ?Term
    (λ acc : Term. λ f : Π _ : Term. Term. f acc)
    (recursionList ?(Product init$string ConstrFunctor) ?(List (Π _ : Term. Term))
      [Π _ : Term. Term | λ t : Term. θ{removeUnit ?γ{type} γ{t}}]
      (λ p : CFParam. λ ps : List CFParam. λ rec : List (Π _ : Term. Term).
        cons ?(Π _ : Term. Term) (λ t : Term. θ{γ{curryHelper name type p ps} γ{t} γ{natToVar (length ?CFParam ps)}}) rec)
      d)
    alg).

let datatypeToConstrs (d : DatatypeData) : List LetInfo :=
  zipWith ?(TripleProduct init$string ConstrData ConstrFunctorData) ?Term ?LetInfo
    (recursionTripleProduct ?init$string ?ConstrData ?ConstrFunctorData ?(Π _ : Term. LetInfo)
      (λ constrName : init$string. λ cD : ConstrData. λ funD : ConstrFunctorData. λ alg : Term.
        mkLetInfo constrName (convertAlgToConstr (DatatypeName d) (ConstrDataTerm cD) funD alg) (nothing ?Term)))
    (reverse ?(TripleProduct init$string ConstrData ConstrFunctorData) (DatatypeConstrs d))
    (datatypeToAlgTerms (DatatypeName d) (telescopeToApp (DatatypeTelescope d))
      (map ?(TripleProduct init$string ConstrData ConstrFunctorData) ?ConstrFunctorData
           (pr33 ?init$string ?ConstrData ?ConstrFunctorData) (DatatypeConstrs d))).

-- Transform inputs to Π _ : F X. X
let uncurryFoldArg (name : init$string) (c : ConstrFunctorData) (d : ConstrData) (arg : Term) :=
  recursionList ?CFParam ?Term
    θ{addUnit ?X (appLTerm γ{arg} (map ?Nat ?App (λ n : Nat. mkAppU (natToVar n)) (countToZero n)))}
    (λ p : CFParam. λ ps : List CFParam. λ rec : Term.
      θ{γ{uncurryHelper name θ{X} p ps} γ{lambdaTerm "_" (ApplyConstrFunctor arg (cfParamFunctor p)) rec}})
    c.

let datatypeToFold (name : init$string) (constrs : List ConstrFunctorData) (apply : List App) : Term :=
  θ{λ X : *. γ{foldl ?ConstrFunctorData ?Term
    (λ t : Term. λ c : ConstrFunctorData. lambdaTerm "_" θ{Π _ : γ{ConstrFunctorF name c} X. X} t)
    constrs
    θ{foldC γ{appLTerm (sVarTerm (stringApp name "F")) apply} ?X
      γ{recursionList ?(Product ConstrFunctorData (List ConstrFunctorData)) ?Term
        θ{voidElim ?X}
        (λ c : Product ConstrFunctorData (List ConstrFunctorData).
        λ cs : List (Product ConstrFunctorData (List ConstrFunctorData)).
        λ t : Term.
          θ{sumAlg ?X ?γ{ConstrFunctorF name (pr1 ?ConstrFunctorData ?(List ConstrFunctorData) c)}
                   ?γ{ConstrsFunctorF' name (pr2 ?ConstrFunctorData ?(List ConstrFunctorData) c)}
                   γ{natToVar (length ?(Product ConstrFunctorData (List ConstrFunctorData)) cs)} γ{t}})
        (initsNonEmpty ?ConstrFunctorData constrs)}}}}.

let datatypeToLet (d : DatatypeData) : init$newStmt :=
  (λ name : Π _ : init$string. init$string. λ apply : List App.
    seqNewStmts (map ?LetInfo ?init$newStmt (λ i : LetInfo. letInfoToNewStmt (appendTelToLetInfo (DatatypeTelescope d) i))
      (app ?LetInfo [LetInfo|
        mkLetInfo (name "F") (DatatypeF d) (just ?Term θ{Π _ : *. *}),
        mkLetInfo (name "Functor") (DatatypeFunctor d) (just ?Term θ{Functor γ{DatatypeF d}}),
        mkLetInfo (name "") θ{FixC γ{appLTerm (sVarTerm (name "F")) apply}} (just ?Term θ{*}),
        mkLetInfo (name "Constrs")
                  θ{inC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "Functor")) apply}}
                  (just ?Term θ{AlgC γ{appLTerm (sVarTerm (name "F")) apply} γ{appLTerm (sVarTerm (name "")) apply}}),
        mkLetInfo (name "Fold") (datatypeToFold (DatatypeName d) (DatatypeConstrs' d) apply) (nothing ?Term)]
        (datatypeToConstrs d))))
  (stringApp (DatatypeName d)) (telescopeToApp (DatatypeTelescope d)).